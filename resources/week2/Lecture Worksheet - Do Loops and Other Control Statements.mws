{VERSION 6 0 "Windows 10" "6.0" }
{USTYLETAB {PSTYLE "Heading 1" -1 3 1 {CSTYLE "" -1 -1 "Times" 1 18 0
 0 0 1 2 1 2 2 2 2 1 0 0 1 }1 1 0 0 8 4 2 0 2 0 2 2 -1 1 }{PSTYLE "War
ning" -1 7 1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0
 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple Outp
ut" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 
}1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Fixed Width" -1 17 1 {CSTYLE "
" -1 -1 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 
0 2 2 -1 1 }{PSTYLE "Normal264" -1 200 1 {CSTYLE "" -1 -1 "Times" 1 12
 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "H
elp" -1 10 1 {CSTYLE "" -1 -1 "Courier" 1 9 0 0 255 1 2 2 2 2 2 1 1 0 
0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal263" -1 201 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0
 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 4" -1 20 1 {CSTYLE "" -1 -1 "Times
" 1 10 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Line Printed Output" -1 6 1 {CSTYLE "" -1 -1 "Courier" 1 10 0
 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "H
eading 2" -1 4 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 0
 0 1 }1 1 0 0 8 2 2 0 2 0 2 2 -1 1 }{PSTYLE "Maple Output" -1 11 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0
 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 3" -1 5 1 {CSTYLE "" -1 -1 "Times"
 1 12 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Normal267" -1 202 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2
 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Diagnostic" 
-1 9 1 {CSTYLE "" -1 -1 "Courier" 1 10 64 128 64 1 2 2 2 2 2 1 1 0 0 1
 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Ordered List 1" -1 203 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3
 2 0 2 0 2 2 -1 1 }{PSTYLE "Text Output" -1 2 1 {CSTYLE "" -1 -1 "Cour
ier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 
}{PSTYLE "Ordered List 2" -1 204 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0
 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 36 2 0 2 2 -1 1 }{PSTYLE "Ordere
d List 3" -1 205 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1
 0 0 1 }1 1 0 0 3 3 2 72 2 0 2 2 -1 1 }{PSTYLE "Normal262" -1 206 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0
 2 0 2 0 2 2 -1 1 }{PSTYLE "Ordered List 4" -1 207 1 {CSTYLE "" -1 -1 
"Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 108 2 0 2 2 -1
 1 }{PSTYLE "Normal261" -1 208 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1
 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Ordered L
ist 5" -1 209 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 
0 1 }1 1 0 0 3 3 2 144 2 0 2 2 -1 1 }{PSTYLE "Annotation Title" -1 210
 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 1 0 0 1 }3 1 0 0 
12 12 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal260" -1 211 1 {CSTYLE "" -1 -1 
"Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1
 }{PSTYLE "HyperlinkError" -1 212 1 {CSTYLE "" -1 -1 "Courier New" 1 
12 255 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "HyperlinkWarning" -1 213 1 {CSTYLE "" -1 -1 "Courier New" 1 
12 0 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Bullet Item" -1 15 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 
2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Maple Plot" 
-1 13 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1
 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "List Item" -1 14 1 {CSTYLE "" -1 
-1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 
-1 1 }{PSTYLE "Normal259" -1 214 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0
 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal2
58" -1 215 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1
 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal257" -1 216 1 {CSTYLE "
" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 
2 2 -1 1 }{PSTYLE "Normal256" -1 217 1 {CSTYLE "" -1 -1 "Times" 1 12 0
 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 36 2 36 2 2 -1 1 }{PSTYLE "D
ash Item" -1 16 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 
0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Error" -1 8 1 {CSTYLE ""
 -1 -1 "Courier" 1 10 255 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0
 2 0 2 2 -1 1 }{PSTYLE "Title" -1 18 1 {CSTYLE "" -1 -1 "Times" 1 18 0
 0 0 1 2 1 1 2 2 2 1 0 0 1 }3 1 0 0 12 12 2 0 2 0 2 2 -1 1 }{PSTYLE "N
ormal" -1 0 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 
1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 1265" -1 218 1 
{CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 1 0 0 1 }3 1 0 0 8 4
 2 0 2 0 2 2 -1 1 }{PSTYLE "Author" -1 19 1 {CSTYLE "" -1 -1 "Times" 1
 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 8 8 2 0 2 0 2 2 -1 1 }{PSTYLE
 "Heading 1266" -1 219 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2
 2 2 1 0 0 1 }3 1 0 0 8 4 2 0 2 0 2 2 -1 1 }{CSTYLE "Help Variable" -1
 25 "Courier" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Popup" -1 31 
"Times" 1 12 0 128 128 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "Atomic Variable
" -1 200 "Times" 1 12 175 0 175 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Code" 
-1 201 "Courier New" 1 12 255 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D M
ath Italic" -1 3 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D
 Math Small" -1 7 "Times" 1 1 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "He
lp Normal" -1 30 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Ma
ple Input" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE 
"Output Labels" -1 29 "Times" 1 8 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "Help Underlined" -1 44 "Times" 1 12 0 0 0 1 2 2 1 2 2 2 0 0 0 1 }
{CSTYLE "Plot Title" -1 27 "Times" 1 10 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "Help Italic Bold" -1 40 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 
0 1 }{CSTYLE "LaTeX" -1 32 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "Equation Label" -1 202 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0
 1 }{CSTYLE "Hyperlink" -1 17 "Times" 1 12 0 128 128 1 2 2 1 2 2 2 0 0
 0 1 }{CSTYLE "Dictionary Hyperlink" -1 45 "Times" 1 12 147 0 15 1 2 2
 1 2 2 2 0 0 0 1 }{CSTYLE "Page Number" -1 33 "Times" 1 12 0 0 0 1 2 2
 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic Small" -1 203 "Times" 1 1 0 
0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Symbol 2" -1 16 "Times" 1 
12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 1 12 0 
0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Annotation Text" -1 204 "Times" 1 
12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underlined Italic" -1 43
 "Times" 1 12 0 0 0 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "2D Comment" -1 18 
"Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Maple Comment" -1 
21 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Plot Text" -1 
28 "Times" 1 8 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Bold Smal
l" -1 10 "Times" 1 1 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Bold" 
-1 39 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Menus" 
-1 36 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Header and Fo
oter" -1 205 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help N
otes" -1 37 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Text" 
-1 206 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Default" -1 
38 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Maple Input Plac
eholder" -1 207 "Courier New" 1 12 200 0 200 1 2 1 2 2 1 2 0 0 0 1 }
{CSTYLE "Help Emphasized" -1 22 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0
 1 }{CSTYLE "Help Italic" -1 42 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0
 1 }{CSTYLE "Prompt" -1 1 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "2D Math Bold" -1 5 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "Caption Text" -1 208 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1
 }{CSTYLE "Help Underlined Bold" -1 41 "Times" 1 12 0 0 0 1 1 1 2 2 2 
2 0 0 0 1 }{CSTYLE "Copyright" -1 34 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 
0 0 0 1 }{CSTYLE "2D Input" -1 19 "Times" 1 12 255 0 0 1 2 2 2 2 1 2 0
 0 0 1 }{CSTYLE "Help Heading" -1 26 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 
0 0 0 1 }{CSTYLE "2D Output" -1 20 "Times" 1 12 0 0 255 1 2 2 2 2 2 2 
0 0 0 1 }{CSTYLE "2D Inert Output" -1 209 "Times" 1 12 144 144 144 1 2
 2 2 2 1 2 0 0 0 1 }{CSTYLE "Help Fixed" -1 23 "Courier" 1 10 0 0 0 1 
2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Nonterminal" -1 24 "Courier" 1 12 0
 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Maple Name" -1 35 "Times" 1 
12 104 64 92 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Caption Reference" -1 210
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 211 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 212 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 213 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 214 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 215 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 216 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 217
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 218 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 219 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 220 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 221 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 222 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 223 "Times" 1 12 0 0 0 1 1 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 224
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 225 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 226 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 227 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 228 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 229 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 230 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 231
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 232 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 233 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 234 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 235 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 236 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 237 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 238
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 239 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 240 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 241 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 242 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 243 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 244 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 245
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 246 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 247 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 248 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 249 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 250 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 251 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 252
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 253 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 254 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 255 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 256 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 257 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 258 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 259
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 260 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 261 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 262 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 263 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 264 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 265 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 266
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 267 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 268 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 269 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 270 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 271 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 272 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 273
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 274 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 275 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 276 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 277 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 278 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 279 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 280
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 281 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 282 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 283 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 284 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 285 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 286 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 287
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 288 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 289 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 290 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 291 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 292 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 293 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 294
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 295 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 296 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 297 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 298 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 299 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 300 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 301
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 302 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 303 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 304 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 305 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 306 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 307 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 308
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 309 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 310 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 311 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 312 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 313 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 314 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 315
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 316 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 317 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 318 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 319 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 320 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 321 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 322
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 323 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 324 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 325 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 326 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 327 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 328 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 329
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 330 "Times" 1
 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 331 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 332 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 333 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 334 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 335 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 336
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 337 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 338 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 339 "Times" 1 12 0 0 0 1 1 2 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 340 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 341 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 342 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 343
 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 344 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 345 "Times" 1 12 0 0 0 
1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 346 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 347 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 348 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 349 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 350
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 351 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 352 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 353 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{CSTYLE "" -1 354 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "" -1 355 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "" -1 356 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 357
 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 358 "Times" 1
 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 359 "Times" 1 12 0 0 0 
1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 360 "Times" 1 12 0 0 0 1 2 1 2 2 
2 2 0 0 0 1 }{PSTYLE "" -1 220 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0
 0 1 2 1 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "" -1 
221 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 2 2 1 0 0 1 }3
 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{CSTYLE "" -1 361 "Times" 1 12 0 0 0 1 1 
2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 362 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 
0 0 0 1 }{CSTYLE "" -1 363 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "" -1 364 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE ""
 -1 365 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 366 "T
imes" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }}
{SECT 0 {PARA 219 "" 0 "" {TEXT 367 21 "Repetition statements" }}
{PARA 202 "" 0 "" {TEXT 368 0 "" }}{PARA 218 "" 0 "" {TEXT 369 27 " Ma
ple's Control Statements" }}{SECT 0 {PARA 3 "" 0 "" {TEXT 370 18 "17.1
. Introduction" }}{PARA 0 "" 0 "" {TEXT 371 109 "In order to write int
eresting examples of procedures, we need to define two new kinds of Ma
ple commands, the " }{TEXT 211 20 "repetition statement" }{TEXT 371 9 
" and the " }{TEXT 212 21 "conditional statement" }{TEXT 371 19 ". The
se are called " }{TEXT 213 18 "control statements" }{TEXT 371 359 " si
nce they control the order in which Maple commands are executed. So fa
r, whenever we have lumped Maple commands into a group, either in an e
xecution group or in a procedure body, the commands in the group have \+
been executed in a sequential, or linear, order, one after the other. \+
Now we will see how to get Maple to execute commands in a \"nonlinear
\" order." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 0 
{PARA 3 "" 0 "" {TEXT 370 27 "17.2. Repetition statements" }}{PARA 0 "
" 0 "" {TEXT 371 294 "Sometimes we want Maple to do more or less the s
ame thing many times in a row. Another way to put this is that sometim
es we might want Maple to repeat a command (or group of commands) many
 times. How can we get Maple to do something in a very repetitious way
? By using a Maple command called a " }{TEXT 214 8 "for-loop" }{TEXT 
371 65 ". Here is a basic example of a for-loop; it computes powers of
 2." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 0 to 6 do
\n" }{MPLTEXT 1 0 7 "  2^i;\n" }{MPLTEXT 1 0 3 "od;" }}{PARA 11 "" 1 "
" {XPPMATH 20 "6#\"\"\"" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"#" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"%" }}{PARA 11 "" 1 "" {XPPMATH 20 
"6#\"\")" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#;" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#\"#K" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#k" }}}{PARA 
0 "" 0 "" {TEXT 371 52 "This for-loop told Maple to evaluate the expre
ssion " }{TEXT 0 3 "2^i" }{TEXT 371 46 " seven times but to use a diff
erent value for " }{TEXT 0 1 "i" }{TEXT 371 104 " each time. The comma
nd produced seven lines of output, one line for each of the successive
 values that " }{TEXT 0 1 "i" }{TEXT 371 209 " takes from 0  to 6.  Wh
at if you wanted a lot more, say 20 or 30 lines of output? Notice how \+
easy it would be to go back and change the command to generate as many
 lines of output as you might want. (Try it.)" }}{PARA 0 "" 0 "" {TEXT
 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 158 "Here are some simple modifi
cations of this last for-loop. First of all, we can have Maple do more
 then one command each time the for-loop loops (or iterates)." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 0 to 6 do\n" }
{MPLTEXT 1 0 7 "  2^i;\n" }{MPLTEXT 1 0 7 "  3^i;\n" }{MPLTEXT 1 0 3 "
od;" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"\"" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#\"\"\"" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"#" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"$" }}{PARA 11 "" 1 "" {XPPMATH 20 
"6#\"\"%" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"*" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#\"\")" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#F" }}{PARA 
11 "" 1 "" {XPPMATH 20 "6#\"#;" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#
\")" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#K" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#\"$V#" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"#k" }}{PARA 
11 "" 1 "" {XPPMATH 20 "6#\"$H(" }}}{PARA 0 "" 0 "" {TEXT 371 75 "For \+
each time the loop looped, Maple executed two commands, one evaluating
 " }{TEXT 0 3 "2^i" }{TEXT 371 26 " and the other evaluating " }{TEXT 
0 3 "3^i" }{TEXT 371 264 ", so there are 14 lines of results. But this
 is hard to read so instead of having Maple execute two commands per l
oop, let us have it compute two results per loop and put those results
 into one expression sequence per loop (i.e., change a semi colon into
 a comma)." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 0 t
o 6 do\n" }{MPLTEXT 1 0 7 "  2^i,\n" }{MPLTEXT 1 0 7 "  3^i;\n" }
{MPLTEXT 1 0 4 " od;" }}{PARA 11 "" 1 "" {XPPMATH 20 "6$\"\"\"F#" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6$\"\"#\"\"$" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6$\"\"%\"\"*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6$\"\")\"#F
" }}{PARA 11 "" 1 "" {XPPMATH 20 "6$\"#;\"#\")" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6$\"#K\"$V#" }}{PARA 11 "" 1 "" {XPPMATH 20 "6$\"#k\"$H("
 }}}{PARA 0 "" 0 "" {TEXT 371 152 "Now we are back to seven lines of o
utput and this time each line has two numbers on it. Let us add a thir
d number to each output line, the loop counter " }{TEXT 0 1 "i" }{TEXT
 371 43 ", so that we can easily see which value of " }{TEXT 0 1 "i" }
{TEXT 371 41 " was used to compute each line of output." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 0 to 6 do\n" }{MPLTEXT 
1 0 17 " i, 2^i, 3^i; od;" }}}{PARA 0 "" 0 "" {TEXT 371 64 "Let us try
 to make those results a little more self explanatory." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "for i from 0 to 6 do 'i' = i, '2^i'
 = 2^i, '3^i' = 3^i; od;" }}}{PARA 0 "" 0 "" {TEXT 371 117 "Notice how
 the right quotes, for delayed evaluation, were useful. What output wo
uld the next command produce and why?" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 59 "for i from 0 to 6 do 'i' = i; '2^i' = 2^i, '3^i' = 3^
i; od;" }}}{PARA 0 "" 0 "" {TEXT 371 50 "We can have our loop begin wi
th a negative number." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "for
 i from -4 to 2 do i, 2^i, 3^i; od;" }}}{PARA 0 "" 0 "" {TEXT 371 95 "
We can also make our loop count by twos. We just add an extra clause t
o the for-loop statement." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 43 
"for i from 0 to 10 by 2 do i, 2^i, 3^i; od;" }}}{PARA 0 "" 0 "" {TEXT
 371 42 "We can even make our loop count backwards." }}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 43 "for i from 6 to 0 by -1 do i, 2^i, 3^i; od;
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 215 8 "Exercise" }{TEXT 371 
115 ": Write a loop that will count backwards by threes from 12 to -9.
 (Replace the question marks in the next command)." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 42 "for i from ? to ? by ? do i, 2^i, 3^i; od;" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT
 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 44 "The syntax for a basic for-l
oop in Maple is " }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 25 "                         " }{TEXT 0 3 "for" }{TEXT 371 
2 "  " }{TEXT 216 15 "index_variable " }{TEXT 371 1 " " }{TEXT 0 4 "fr
om" }{TEXT 371 2 "  " }{TEXT 217 13 "initial_value" }{TEXT 371 2 "  " 
}{TEXT 0 2 "to" }{TEXT 218 1 " " }{TEXT 371 1 " " }{TEXT 219 11 "final
_value" }{TEXT 371 2 "  " }{TEXT 0 2 "by" }{TEXT 371 1 " " }{TEXT 220 
9 "step_size" }{TEXT 371 1 " " }{TEXT 0 2 "do" }}{PARA 0 "" 0 "" {TEXT
 371 30 "                              " }{TEXT 221 26 "sequence_of_Ma
ple_commands" }}{PARA 0 "" 0 "" {TEXT 371 24 "                        
" }{TEXT 222 1 " " }{TEXT 0 2 "od" }{TEXT 223 1 ";" }}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 31 "The Maple commands betw
een the " }{TEXT 0 2 "do" }{TEXT 371 5 " and " }{TEXT 0 2 "od" }{TEXT 
371 16 " are called the " }{TEXT 224 20 "body of the for-loop" }{TEXT 
371 203 ". The for-loop executes (or \"loops through\", or \"iterates
\") its body over and over again, as the index variable increments (or
 decrements) by the step size from the initial value to the final valu
e. The " }{TEXT 0 2 "by" }{TEXT 371 1 " " }{TEXT 225 9 "step_size" }
{TEXT 371 38 " part of the for-loop is optional. If " }{TEXT 226 13 "i
nitial_value" }{TEXT 371 14 " is less than " }{TEXT 227 11 "final_valu
e" }{TEXT 371 17 " and there is no " }{TEXT 228 9 "step_size" }{TEXT 
371 7 ", then " }{TEXT 229 9 "step_size" }{TEXT 371 56 " defaults to o
ne. The for-loop stops iterating when the " }{TEXT 230 14 "index_varia
ble" }{TEXT 371 24 " is incremented, by the " }{TEXT 231 9 "step_size"
 }{TEXT 371 34 ", to a value that is greater than " }{TEXT 232 11 "fin
al_value" }{TEXT 371 9 " (or, if " }{TEXT 233 9 "step_size" }{TEXT 
371 38 " is negative, looping stops after the " }{TEXT 234 14 "index_v
ariable" }{TEXT 371 19 " is decremented by " }{TEXT 235 9 "step_size" 
}{TEXT 371 22 " to a value less than " }{TEXT 236 11 "final_value" }
{TEXT 371 103 "). Notice that this implies that the for-loop is not co
mpleted until the index variable is incremented " }{TEXT 237 4 "past" 
}{TEXT 371 62 " the final value. We will look at examples of this just
 below." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 238 
8 "Exercise" }{TEXT 371 45 ": What happens with a for-loop for which t
he " }{TEXT 239 11 "final_value" }{TEXT 371 18 " is less than the " }
{TEXT 240 13 "initial_value" }{TEXT 371 17 " and there is no " }{TEXT 
241 9 "step_size" }{TEXT 371 7 "? Does " }{TEXT 242 9 "step_size" }
{TEXT 371 12 " default to " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesett
ing:-mi(\"\", italic = \"true\", executable = \"true\", font_style_nam
e = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typeset
ting:-mo(\"&uminus0;\", mathvariant = \"normal\", fence = \"false\", s
eparator = \"false\", stretchy = \"false\", symmetric = \"false\", lar
geop = \"false\", movablelimits = \"false\", accent = \"false\", lspac
e = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mn(\"1\",
 mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", \+
executable = \"true\", font_style_name = \"2D Input\", mathvariant = \+
\"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6
%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)
2D~InputF'/%,mathvariantGQ'italicF'-F#6$-I#moGF$6-Q*&uminus0;F'/F8Q'no
rmalF'/%&fenceGQ&falseF'/%*separatorGFD/%)stretchyGFD/%*symmetricGFD/%
(largeopGFD/%.movablelimitsGFD/%'accentGFD/%'lspaceGQ,0.2222222emF'/%'
rspaceGFS-I#mnGF$6$Q\"1F'F@F+" }{TEXT 371 1 "?" }}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 
0 "" {TEXT 371 54 "The formatting of a for-loop as shown above, with t
he " }{TEXT 0 2 "od" }{TEXT 371 25 " on its own line and the " }{TEXT 
243 26 "sequence_of_Maple_commands" }{TEXT 371 485 " indented a bit, i
s not part of the syntax of a for-loop. This way of formatting a for-l
oop is just a way to help a reader understand the structure of the loo
p. It is a very good idea to write for-loops using a format like this.
 But be careful to have all of the lines that make up the for-loop in \+
one execution group. (As far as Maple is concerned, the entire for-loo
p is just one single Maple command, so you can also have the entire fo
r-loop on a single line if it is a short loop)." }}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 152 "Here are some examples
 of simple for-loops. Notice that a for-loop ignores whatever value th
e index variable might have before the for-loop is executed." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "i := -100;\n" }{MPLTEXT 1 0 
39 "for i from 5 to 10 by 2 do 'i' = i od;\n" }}}{PARA 0 "" 0 "" {TEXT
 371 50 "Notice that the last output from the for-loop was " }{TEXT 0 
4 "i=10" }{TEXT 371 36 ". Let us check the current value of " }{TEXT 
0 1 "i" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "i;" }}}{PARA 0 "" 0
 "" {TEXT 371 41 "When a for-loop terminates, the value of " }{TEXT 
244 14 "index_variable" }{TEXT 371 24 " is always greater than " }
{TEXT 245 11 "final_value" }{TEXT 371 142 ". But exactly how much grea
ter depends on all three of the initial value, the final value, and th
e step size. Consider the following examples." }}{EXCHG {PARA 0 "> " 0
 "" {MPLTEXT 1 0 31 "for i from 3 to 7 do 'i'=i od;\n" }{MPLTEXT 1 0 
3 "i;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "for i from 3 to 7 by 2 do 'i'=i od;\n" }{MPLTEXT 1 0 
3 "i;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "for i from 3 to 8 by 2 do 'i'=i od;\n" }{MPLTEXT 1 0 
3 "i;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "for i from 2 to 8 by 2 do 'i'=i od;\n" }{MPLTEXT 1 0 
3 "i;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "for i from 2 to 8 by 3 do 'i'=i od;\n" }{MPLTEXT 1 0 
3 "i;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0
 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 246 8 "Exercise" }{TEXT 
371 22 ": For a for-loop, let " }{TEXT 247 1 "i" }{TEXT 371 12 " denot
e the " }{TEXT 248 13 "initial_value" }{TEXT 371 6 ", let " }{TEXT 
249 1 "f" }{TEXT 371 12 " denote the " }{TEXT 250 11 "final_value" }
{TEXT 371 10 ", and let " }{TEXT 251 1 "s" }{TEXT 371 12 " denote the 
" }{TEXT 252 9 "step_size" }{TEXT 371 46 ". Suppose all three of these
 are positive and " }{TEXT 253 1 "i" }{TEXT 371 3 " < " }{TEXT 254 1 "
f" }{TEXT 371 6 ". Let " }{TEXT 255 1 "a" }{TEXT 371 25 " denote the v
alue of the " }{TEXT 256 14 "index_variable" }{TEXT 371 63 " after the
 loop has completed. Find a formula for the value of " }{TEXT 257 1 "a
" }{TEXT 371 13 " in terms of " }{TEXT 258 1 "i" }{TEXT 371 2 ", " }
{TEXT 259 1 "f" }{TEXT 371 6 ", and " }{TEXT 260 1 "s" }{TEXT 371 35 "
. Use Maple to verify your formula." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 4 "The " }{TEXT 0 4 "from" }{TEXT 371 1 " " }{TEXT 261 13 "i
nitial_value" }{TEXT 371 9 " and the " }{TEXT 0 2 "to" }{TEXT 371 1 " 
" }{TEXT 262 11 "final_value" }{TEXT 371 212 " parts of a for-loop can
 be omitted. This is more likely to happen by accident than by design,
 but if you do leave them out, even accidentally, Maple will not warn \+
you since it is not a syntax error. If you omit " }{TEXT 0 4 "from" }
{TEXT 371 1 " " }{TEXT 263 13 "initial_value" }{TEXT 371 11 ", then th
e " }{TEXT 264 13 "initial_value" }{TEXT 371 16 " defaults to 1. " }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "for i to 5 do 'i'=i od;" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 32 "However, if you should omit the " }{TEXT 0 2 "to" }{TEXT 371 
1 " " }{TEXT 265 11 "final_value" }{TEXT 371 162 " part of a for-loop,
 then the for-loop never terminates! This can be inconvenient. If this
 should happen, sometimes you can get Maple to stop by clicking on the
 \"" }{TEXT 266 4 "Stop" }{TEXT 371 85 "\" button near the top of the \+
Maple window. But Maple does not always respond to the \"" }{TEXT 267 
4 "Stop" }{TEXT 371 378 "\" button. If Maple refuses to respond to the
 stop button, then you have no choice but to wait for some kind of err
or to occur, which will stop Maple, or you need to use the operating s
ystem to halt the Maple program, which will cause you to loose all of \+
your work since the last time you saved your worksheet. So look over y
our for-loops carefully before hitting the return key." }}{PARA 0 "" 0
 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 60 "The for-loop syntax
 we just looked at is the syntax for the " }{TEXT 268 5 "basic" }{TEXT
 371 119 " loop. Maple has many other forms of loops. We will look at \+
some of these other forms in some of our examples later on." }}{PARA 0
 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 159 "For-loops are
 useful for generating \"tables\" of results. For example the next com
mand lists the binary and hexadecimal number system versions of some i
ntegers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "for i from 100 t
o 110 do\n" }{MPLTEXT 1 0 42 "  i, convert(i, binary), convert(i, hex)
;\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 434 "Notice \+
how the for-loop was written on three lines and the middle line was in
dented. This is to try and make the for-loop easier to read. It is imp
ortant that all three of those lines be in the same execution group, o
therwise Maple will generate error messages. But it is also important \+
to realize that those three lines were not separate Maple commands. Th
e three lines together make one for-loop and Maple treats that for-loo
p as a " }{TEXT 269 6 "single" }{TEXT 371 15 " Maple command." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 86 "The next command creates an i
nteresting table of polynomials and their factorizations." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "for i from 1 to 10 do\n" }{MPLTEXT 
1 0 30 "  exp1 := add( x^j, j=0..i );\n" }{MPLTEXT 1 0 26 "  exp2 := f
actor( exp1 );\n" }{MPLTEXT 1 0 24 "  print( exp1 = exp2 );\n" }
{MPLTEXT 1 0 4 "od:\n" }}}{PARA 0 "" 0 "" {TEXT 371 107 "Let us examin
e this for-loop more carefully since it has a few new features. First \+
of all, notice that the " }{TEXT 0 2 "od" }{TEXT 371 111 " at the end \+
of the for-loop has a colon after it, not a semi colon. That actually \+
means that the for-loop does " }{TEXT 270 3 "not" }{TEXT 371 98 " prin
t out any result. So why do we get ten lines of output? The output lin
es are produced by the " }{TEXT 0 5 "print" }{TEXT 371 184 " command, \+
which always prints out a result. For example, consider the next two p
rint commands. One has a colon and the other has a semi colon after it
 but they both print out a result." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "print( \"hello\" ):" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "print( \"hello again\" );" }}}{PARA 0 "" 0 "" {TEXT 
371 67 "Now go back up to the last for-loop and change the colon after
 the " }{TEXT 0 2 "od" }{TEXT 371 573 " to a semi colon. If you re-exe
cute the loop it will now produce 30 lines of output since there are t
hree commands in the loop body and the body is executed ten times. Try
 changing the semi colons in the loop body to colons and re-executing \+
the for-loop. If you do, you will still get 30 lines of output. In the
 body of a for-loop (as in the body of a procedure) there is no differ
ence between a colon and a semi colon. So either all the commands in t
he body of a for-loop produce an output or they all do not produce an \+
output, and it is the semi colon or colon after the " }{TEXT 0 2 "od" 
}{TEXT 371 177 " that controls this. The best way to control which res
ults you want printed out and which results you want to suppress from \+
the body of a loop is to put a colon after the final " }{TEXT 0 2 "od"
 }{TEXT 371 34 " of the for-loop and then use the " }{TEXT 0 5 "print"
 }{TEXT 371 192 " command inside the body of the loop to selectively p
rint out the results that you want to see. (There is an optional secti
on later in this worksheet that has more to say about the use of the "
 }{TEXT 0 5 "print" }{TEXT 371 23 " command inside loops.)" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 371 135 "Notice that for-loops can quickly and
 easily produce a lot of results. For example, the next for-loop produ
ces quite a few polynomials." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
21 "for i from 1 to 5 do\n" }{MPLTEXT 1 0 23 "   add( x^j, j=0..i );\n
" }{MPLTEXT 1 0 16 "   factor( % );\n" }{MPLTEXT 1 0 4 "od;\n" }}}
{PARA 0 "" 0 "" {TEXT 371 528 "What if we wanted to give these polynom
ials names so that we can refer to them later on? We need a way for th
e for-loop to automatically generate names, similar to how it can auto
matically generate the polynomials. In fact, Maple provides two ways f
or a for-loop to create names as it loops. Here we will look briefly a
t these two ways, which are called dotted names and indexed names. (In
 an earlier worksheet there were optional sections on dotted and index
ed names that had more information in it them then what we need now.)"
 }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 72 "A do
tted name is a name followed by a dot followed by a number, such as " 
}{TEXT 0 3 "x.3" }{TEXT 371 165 ". The dot is really an operator and M
aple evaluates the dot by taking the number on the right of the dot an
d concatenating it to the name on the left of the dot. So " }{TEXT 0 
3 "x.3" }{TEXT 371 9 " becomes " }{TEXT 0 2 "x3" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "x||3;" }}}{PARA 0 "" 0 "" 
{TEXT 371 125 "What makes this so useful is that the number on the rig
ht of the dot can come from evaluating a variable. So if the value of 
" }{TEXT 0 1 "i" }{TEXT 371 11 " is 3 them " }{TEXT 0 3 "x.i" }{TEXT 
371 14 " evaluates to " }{TEXT 0 2 "x3" }{TEXT 371 1 "." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "i := 3;\n" }{MPLTEXT 1 0 6 "x||i;\n"
 }}}{PARA 0 "" 0 "" {TEXT 371 94 "In our loop that created lots of pol
ynomials, here is how we can give the factored ones names." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 1 to 5 do\n" }{MPLTEXT 
1 0 23 "   add( x^j, j=0..i );\n" }{MPLTEXT 1 0 24 "   p||i := factor(
 % );\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 8 "And n
ow " }{TEXT 0 2 "p3" }{TEXT 371 63 ", for example, is a name for one o
f these factored polynomials." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 3 "p3;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 
0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 85 "An indexed name is
 a name followed by a pair of brackets enclosing a number, such as " }
{TEXT 0 4 "x[3]" }{TEXT 371 130 ". (We have seen indexed names used be
fore as a way of accessing the data items in expression sequences, lis
ts, sets, and strings.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "x[
3];" }}}{PARA 0 "" 0 "" {TEXT 371 162 "Notice how Maple typesets the i
ndexed name as a subscripted variable. The number inside the brackets \+
can come from evaluating a variable. So if 3 is the value of " }{TEXT 
0 1 "i" }{TEXT 371 7 ", then " }{TEXT 0 4 "x[i]" }{TEXT 371 31 " evalu
ates to the indexed name " }{TEXT 0 4 "x[3]" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "i := 3;\n" }{MPLTEXT 1 0 6 "x
[i];\n" }}}{PARA 0 "" 0 "" {TEXT 371 123 "In our loop that created a l
ot of polynomials, here is how we can associate indexed names with the
 rest of the polynomials." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 
"for i from 1 to 5 do\n" }{MPLTEXT 1 0 30 "   p[i] = add( x^j, j=0..i \+
);\n" }{MPLTEXT 1 0 24 "   p||i := factor( % );\n" }{MPLTEXT 1 0 4 "od
;\n" }}}{PARA 0 "" 0 "" {TEXT 371 259 "Notice how in this example the \+
indexed names were used in equations, not in assignment statements. So
metimes we only want the names for display purposes, not for assigning
 to. (If you want, you can try changing the equations into assignments
 in the for-loop.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 113 "This n
ext loop computes the first ten prime numbers. Each prime is displayed
 in an equation with an indexed name." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "for j from 1 to 10 do \n" }{MPLTEXT 1 0 26 "  prime[j
] = ithprime(j);\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 
371 51 "We can assign dotted names to the primes like this." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "for j from 1 to 10 do \n" }{MPLTEXT
 1 0 27 "  prime||j := ithprime(j);\n" }{MPLTEXT 1 0 4 "od;\n" }}}
{PARA 0 "" 0 "" {TEXT 371 73 "Here is a fancy way to list a few of our
 primes using their dotted names." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 14 "prime||(5..9);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 271 8 "Exer
cise" }{TEXT 371 74 ": Compute the one thousandth through one thousand
 and tenth prime numbers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 104 "F
or-loops can take on forms other than the ones used in the examples gi
ven above. One other form is the " }{TEXT 272 11 "for-in-loop" }{TEXT 
371 15 ". Its syntax is" }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 ""
 0 "" {TEXT 371 24 "                        " }{TEXT 0 3 "for" }{TEXT 
371 1 " " }{TEXT 273 14 "index_variable" }{TEXT 371 1 " " }{TEXT 0 2 "
in" }{TEXT 371 1 " " }{TEXT 274 14 "data_structure" }{TEXT 371 1 " " }
{TEXT 0 2 "do" }{TEXT 371 1 " " }{TEXT 275 26 "sequence_of_Maple_comma
nds" }{TEXT 371 1 " " }{TEXT 0 2 "od" }}{PARA 0 "" 0 "" {TEXT 371 0 ""
 }}{PARA 0 "" 0 "" {TEXT 371 79 "Here are a few examples. Study them c
arefully. Try making some changes in them." }}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 62 "for i in [10!, 11!, 12!, 13!, 14!, 15!, 16!] do leng
th(i); od;" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 14 "counter := 0;\n" }{MPLTEXT 1 0 52 "for i in f(x, y
, z, w) do counter := counter+1; od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 
0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "for letter in \"Hello
 world.\" do letter; od;" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "for term in x^2+2*x+(1/x)-y+z do te
rm, whattype(term); od;" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "
" 0 "" {TEXT 371 35 "What does the following command do?" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "for n in seq(i!, i=10..16) do ifact
or(n); od;" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 
371 53 "Here is a way to get one line from Pascal's triangle." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "for term in expand((a+b)^8) \+
do coeffs(term); od;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 53 "Still \+
another form for a repetition statement is the " }{TEXT 276 10 "while-
loop" }{TEXT 371 30 ". It has the following syntax." }}{PARA 0 "" 0 ""
 {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 23 "                      \+
 " }{TEXT 0 5 "while" }{TEXT 371 1 " " }{TEXT 277 18 "boolean_expressi
on" }{TEXT 371 1 " " }{TEXT 0 2 "do" }{TEXT 371 1 " " }{TEXT 278 26 "s
equence_of_Maple_commands" }{TEXT 371 1 " " }{TEXT 0 2 "od" }}{PARA 0 
"" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 291 "The while-loop
 iterates as long as the boolean expression is true (we will say more \+
about boolean expressions later in this worksheet). Here is an example
 of how we can make a while-loop iterate exactly ten times. This loop \+
determines which numbers between one and ten are or are not primes." }
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "i := 1;  # Give i an initia
l value.\n" }{MPLTEXT 1 0 18 "while i <= 10 do \n" }{MPLTEXT 1 0 36 " \+
  i, \"Is it a prime?\", isprime(i);\n" }{MPLTEXT 1 0 13 "   i := i+1;
\n" }{MPLTEXT 1 0 4 "od;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}}{PARA 0 "" 0 "" {TEXT 371 128 "Let us go over this example in \+
detail. Notice from the syntax for a while-loop that while-loops do no
t have index variables, so " }{TEXT 0 1 "i" }{TEXT 371 4 " is " }{TEXT
 279 3 "not" }{TEXT 371 54 " an index variable. That is why we have to
 initialize " }{TEXT 0 1 "i" }{TEXT 371 69 " before executing the whil
e-loop. The while-loop iterates as long as " }{TEXT 0 1 "i" }{TEXT 
371 21 " is less than 10 (so " }{TEXT 0 1 "i" }{TEXT 371 133 " acts a \+
lot like an index variable, but it is not one). Notice that the body o
f the loop has two statements, one of which increments " }{TEXT 0 1 "i
" }{TEXT 371 129 " to the next value. In a for-loop, the index variabl
e is incremented automatically from one iterate of the loop to the nex
t, but " }{TEXT 0 1 "i" }{TEXT 371 89 " is not an index variable so we
 need to increment it ourselves. Notice what the value of " }{TEXT 0 
1 "i" }{TEXT 371 29 " is when the loop terminates." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 2 "i;" }}}{PARA 0 "" 0 "" {TEXT 371 13 "The valu
e of " }{TEXT 0 1 "i" }{TEXT 371 51 " needed to reach 11 so that the b
oolean expression " }{TEXT 0 5 "i<=10" }{TEXT 371 69 " could become fa
lse and terminate the loop. If we were to forget the " }{TEXT 0 6 "i:=
i+1" }{TEXT 371 270 " statement in the body of this while-loop, the lo
op would iterate for ever (why?), which is sometimes called an \"infin
ite loop\". (You can try this if you wish, but be careful. First be su
re to save all of your work, in case you cannot get Maple to stop. The
n delete the " }{TEXT 0 6 "i:=i+1" }{TEXT 371 53 " statement, execute \+
the infinite loop, then use the \"" }{TEXT 280 4 "Stop" }{TEXT 371 80 
"\" button at the top of the Maple window to bring the loop to a prema
ture end.)  " }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT
 281 8 "Exercise" }{TEXT 371 99 ": Modify the while-loop so that it do
es not output all the results from the incrementing statement " }{TEXT
 0 5 "i=i+1" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 282 8 "
Exercise" }{TEXT 371 102 ": Modify the while-loop example so that it d
etermines which integers between 1000 and 1010 are primes." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 283 8 "Exercise" }{TEXT 371 184 ": Even number
s are never prime (except for 2) so there is no point in testing them.
 Modify the while-loop example so that it skips over the even numbers \+
and only tests the odd numbers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 
284 8 "Exercise" }{TEXT 371 200 ": Rewrite the while-loop example as a
 for-loop. Notice that the for-loop version is much more straight forw
ard. In the next example we will look at a while-loop that cannot be r
ewritten as a for-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 422 "The
 previous example is really not a good use for a while-loop. It is bet
ter written as a for-loop. This is because we know in advance exactly \+
how many times we want the loop to iterate. The strength of a while-lo
op is that it can be used for loops in which we do not know in advance
 how many times the loop will need to iterate. For example, the follow
ing while-loop finds the first prime number greater than the integer "
 }{TEXT 0 1 "n" }{TEXT 371 175 ". Since we do not know which prime num
ber this will be, we do not know in advance how many times the loop wi
ll iterate as it searches for the answer. Notice that the variable " }
{TEXT 0 1 "n" }{TEXT 371 106 ", which is not an index variable, needs \+
to be initialized before the loop starts and we need to increment " }
{TEXT 0 1 "n" }{TEXT 371 35 " ourselves in the body of the loop." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "n := 1000:\n" }{MPLTEXT 1 0 
37 "while not isprime(n) do n := n+1 od;\n" }}}{PARA 0 "" 0 "" {TEXT 
371 76 "This next while-loop will find the first prime number less tha
n the integer " }{TEXT 0 1 "n" }{TEXT 371 34 ". Notice how we have to \+
decrement " }{TEXT 0 1 "n" }{TEXT 371 35 " ourselves in the body of th
e loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "n := 1000:\n" }
{MPLTEXT 1 0 37 "while not isprime(n) do n := n-1 od;\n" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 285 8 "Exercise" }{TEXT 371 85 ": What is the \+
output from either of the last two while-loops if the initial value of
 " }{TEXT 0 1 "n" }{TEXT 371 32 " is a prime number? Explain why." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 286 8 "Exercise" }{TEXT 371 56 ": Wha
t happens in either of the last two while loops if " }{TEXT 0 1 "n" }
{TEXT 371 72 " is a negative number. (Warning: Think about this before
 trying it out!)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 144 "A comm
on way to use loops is to nest them inside of each other. The followin
g nested for-loops count how many prime numbers there are less than " 
}{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-msup(Typesetting:-mn(\"
2\", mathvariant = \"normal\"), Typesetting:-mi(\"i\", italic = \"true
\", mathvariant = \"italic\"), superscriptshift = \"0\"));" "-I%mrowG6
#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I%msupGF$6%-I#mnGF$6$Q
\"2F'/%,mathvariantGQ'normalF'-I#miGF$6%Q\"iF'/%'italicGQ%trueF'/F3Q'i
talicF'/%1superscriptshiftGQ\"0F'" }{TEXT 371 10 " for each " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"i\", italic = \"tru
e\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typese
ttingGI(_syslibGF'6#-I#miGF$6%Q\"iF'/%'italicGQ%trueF'/%,mathvariantGQ
'italicF'" }{TEXT 371 137 " from 2 to 18. The outer for-loop increment
s i from 2 to 18 and it contains two commands in the body of the loop,
 another for-loop and a " }{TEXT 0 5 "print" }{TEXT 371 70 " command. \+
The inner for-loop counts how many primes there are between " }{TEXT 
0 7 "2^(i-1)" }{TEXT 371 5 " and " }{TEXT 0 3 "2^i" }{TEXT 371 187 " (
notice how the index variable from the outer loop is used to set the i
nitial and final values for the index variable in the inner loop). Whe
n the inner loop completes its iterates, the " }{TEXT 0 5 "print" }
{TEXT 371 156 " command in the outer loop prints out the running total
 of primes found so far. Notice how the for-loops are indented to make
 it easier to distinguish them." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 14 "counter := 1:\n" }{MPLTEXT 1 0 22 "for i from 2 to 18 do\n" }
{MPLTEXT 1 0 42 "  for j from 2^(i-1)+1 to (2^i)-1 by 2 do\n" }
{MPLTEXT 1 0 47 "    if isprime(j) then counter := counter+1 fi\n" }
{MPLTEXT 1 0 6 "  od;\n" }{MPLTEXT 1 0 50 "  print( '2^i'=2^i, `number
 of primes`=counter );\n" }{MPLTEXT 1 0 4 "od:\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 150 "The following nested loops do the same calculation as t
he above nested loops, but the following version uses a while-loop nes
ted inside of a for-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "
j := 1:\n" }{MPLTEXT 1 0 22 "for i from 2 to 18 do\n" }{MPLTEXT 1 0 
42 "  while ithprime(j) < 2^i do j := j+1 od;\n" }{MPLTEXT 1 0 46 "  p
rint( '2^i'=2^i, `number of primes`=j-1 );\n" }{MPLTEXT 1 0 4 "od:\n" 
}}}{PARA 0 "" 0 "" {TEXT 371 252 "It is interesting to note that when \+
the above two examples have their outer loop index run from 2 to 18, t
hen the examples run in about the same amount of time. But when the ou
ter loop index is changed to go from 2 to 19, then the second example \+
takes " }{TEXT 287 4 "much" }{TEXT 371 38 " longer to run then the fir
st example." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "" }}}{PARA 0 
"" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 113 "The following \+
while-loop finds the first integer whose factorial has 1000 digits. No
tice again that the variable " }{TEXT 0 1 "i" }{TEXT 371 106 ", which \+
is not an index variable, needs to be initialized before the loop star
ts and we need to increment " }{TEXT 0 1 "i" }{TEXT 371 35 " ourselves
 in the body of the loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "
i := 1:\n" }{MPLTEXT 1 0 38 "while length(i!)<1000 do i := i+1 od:\n" 
}{MPLTEXT 1 0 26 "%;  # Display the result.\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 61 "What would happen if you changed the colon at the end of
 the " }{TEXT 0 2 "od" }{TEXT 371 17 " to a semi colon?" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 371 141 "The next loop does the same calculati
on as the last loop but uses a combination while and for-loop. Notice \+
that there is nothing between the " }{TEXT 0 2 "do" }{TEXT 371 9 " and
 the " }{TEXT 0 2 "od" }{TEXT 371 156 ". This loop has no body! In the
 previous while-loop, the only statement in the body was the increment
ing statement. But notice that in this for-while-loop, " }{TEXT 0 1 "i
" }{TEXT 371 167 " is an index variable and it is initialized and incr
emented by the for-loop part of the for-while-loop (so there is no nee
d for an incrementing statement in the body)." }}{EXCHG {PARA 0 "> " 0
 "" {MPLTEXT 1 0 42 "for i from 1 while length(i!)<1000 do od;\n" }
{MPLTEXT 1 0 26 "i;  # Display the result.\n" }}}{PARA 0 "" 0 "" {TEXT
 371 82 "What would happen in this example if you changed the semi col
on at the end of the " }{TEXT 0 2 "od" }{TEXT 371 17 " to a colon? Why
?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 117 "Here is an example of \+
a loop that combines while and for-in. This for-in-while-loop finds th
e first number in a list." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 
"L := [a,b,c,d,e,10,9,8,7];\n" }{MPLTEXT 1 0 45 "for i in L while not \+
type(i, numeric) do od;\n" }{MPLTEXT 1 0 3 "i;\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 347 "As the last couple of \+
examples showed, Maple has a number of variations on the basic idea of
 a loop. The three basic kinds of loops, for-loop, for-in-loop, and wh
ile-loop, can be combined to form other kinds of loops such as for-whi
le-loop, and for-in-while-loop. There are still other forms that a loo
p can take, but we will not make use of them." }}{PARA 0 "" 0 "" {TEXT
 371 0 "" }}{PARA 0 "" 0 "" {TEXT 288 8 "Exercise" }{TEXT 371 68 ": Re
write the two while-loops for finding primes as for-while-loops." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 289 8 "Exercise" }{TEXT 371 27 ": Wri
te a procedure called " }{TEXT 0 13 "prime_bracket" }{TEXT 371 274 " t
hat takes as input any positive real number (not just an integer) and \+
finds the smallest prime number larger than or equal to the input and \+
the largest prime number smaller than or equal to the input. The proce
dure should return the two primes in a list. So the output of " }{TEXT
 0 19 "prime_bracket(11.5)" }{TEXT 371 18 " will be the list " }{TEXT 
0 7 "[11,13]" }{TEXT 371 5 ". Do " }{TEXT 290 3 "not" }{TEXT 371 25 " \+
use the Maple functions " }{TEXT 0 9 "nextprime" }{TEXT 371 5 " and " 
}{TEXT 0 9 "prevprime" }{TEXT 371 19 " in your procedure." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 291 8 "Exercise" }{TEXT 371 143 ": If you had \+
to choose between writing all of your loops as for-loops or writing al
l of your loops as while-loops, which would you choose? Why?" }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 292 8 "Exercise" }{TEXT 371 34 ": Doe
s Maple have a while-in-loop?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 293 
8 "Exercise" }{TEXT 371 94 ": What doe the following loops tell you ab
out how Maple executes a for-loop and a for-in-loop?" }}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 16 "L := [a, b, c]:\n" }{MPLTEXT 1 0 50 "for n
 from 1 to nops(L) do L := [n, op(L), n] od;\n" }}}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 16 "L := [a, b, c]:\n" }{MPLTEXT 1 0 37 "for n in L
 do L := [n, op(L), n] od;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 294 
8 "Exercise" }{TEXT 371 7 ": From " }{TEXT 295 21 "Introduction to Map
le" }{TEXT 371 71 ", 2nd Ed., by Andre Heck, page 221-222. Define the \+
following procedure." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "f :=
 proc( x, n )\n" }{MPLTEXT 1 0 14 "  local i, t;\n" }{MPLTEXT 1 0 10 "
  t := 1;\n" }{MPLTEXT 1 0 23 "  for i from 1 to n do\n" }{MPLTEXT 1 
0 14 "    t := x^t;\n" }{MPLTEXT 1 0 6 "  od;\n" }{MPLTEXT 1 0 5 "  t;
\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 92 "Now call
 this procedure a couple of times. Explain how the procedure computes \+
these results." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "f( x, 22 )
;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "f( sin(x), 12 );" }}}
{PARA 0 "" 0 "" {TEXT 371 54 "For fun, ask Maple to differentiate the \+
above results." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "diff( f(x,
7), x );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "diff( f(sin(x),
12), x );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 ""
 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 97 "In the next secti
on we will do some longer, more complicated examples that make use of \+
for-loops." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 ""
 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}
{SECT 0 {PARA 3 "" 0 "" {TEXT 370 24 "17.3. More loop examples" }}
{PARA 0 "" 0 "" {TEXT 371 62 "In this section we work on more involved
 examples using loops." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{SECT 0 {PARA 5 "" 0 "" {TEXT 372 31 "17.3.1. Example 1: Riemann sum
s" }}{PARA 0 "" 0 "" {TEXT 371 197 "A common use a for-loop is to comp
ute a sum. In this example we show how to use a loop to compute Rieman
n sums from calculus. But first let us look at a couple of simple sums
 written as for-loops. " }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 ""
 0 "" {TEXT 371 72 "A well known result about sums of integers is that
 the sum of the first " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:
-mi(\"n\", italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#
/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"nF'/%'italic
GQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 22 " positive integers \+
is " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic \+
= \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&InvisibleTim
es;\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rs
pace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:
-mi(\"n\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-
mo(\"+\", mathvariant = \"normal\", fence = \"false\", separator = \"f
alse\", stretchy = \"false\", symmetric = \"false\", largeop = \"false
\", movablelimits = \"false\", accent = \"false\", lspace = \"0.222222
2em\", rspace = \"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant =
 \"normal\")), mathvariant = \"normal\")), Typesetting:-mi(\"\", itali
c = \"true\", executable = \"true\", font_style_name = \"2D Input\", m
athvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingG
I(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_
style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"nF'F/F7-I
#moGF$6-Q1&InvisibleTimes;F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separato
rGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'ac
centGFG/%'lspaceGQ&0.0emF'/%'rspaceGFV-I(mfencedGF$6$-F#6%F<-F@6-Q\"+F
'FCFEFHFJFLFNFPFR/FUQ,0.2222222emF'/FXF\\o-I#mnGF$6$Q\"1F'FCFCF+" }
{TEXT 371 27 "/2. Let us verify this for " }{XPPEDIT 18 0 "Typesetting
:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\",
 font_style_name = \"2D Input\", mathvariant = \"italic\"), Typesettin
g:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"ital
ic\"), Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"fals
e\", separator = \"false\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mn
(\"1000\", mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_s
yslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_styl
e_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"nF'F/F7-I#moG
F$6-Q\"=F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG
/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ
,0.2777778emF'/%'rspaceGFV-I#mnGF$6$Q%1000F'FCF+" }{TEXT 371 101 " usi
ng a for-loop. We want a for-loop that will compute the following sum,
 written in sigma notation." }}{PARA 200 "" 0 "" {XPPEDIT 18 0 "Typese
tting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"tr
ue\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Types
etting:-mrow(Typesetting:-munderover(Typesetting:-mo(\"&Sum;\", foregr
ound = \"[144,144,144]\", mathvariant = \"normal\", Typesetting:-msema
ntics = \"inert\", fence = \"false\", separator = \"false\", stretchy \+
= \"true\", symmetric = \"false\", largeop = \"true\", movablelimits =
 \"true\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.166666
7em\"), Typesetting:-mrow(Typesetting:-mi(\"i\", italic = \"true\", ma
thvariant = \"italic\"), Typesetting:-mo(\"=\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.2777778em\", rspace = \"0.2777778em\")
, Typesetting:-mn(\"1\", mathvariant = \"normal\")), Typesetting:-mn(
\"1000\", mathvariant = \"normal\"), accent = \"false\", accentunder =
 \"false\"), Typesetting:-mi(\"\", italic = \"true\", executable = \"t
rue\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Type
setting:-mspace(height = \"0.0ex\", width = \"5.0\", depth = \"0.0ex\"
, linebreak = \"auto\"), Typesetting:-mi(\"i\", italic = \"true\", mat
hvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", exec
utable = \"true\", font_style_name = \"2D Input\", mathvariant = \"ita
lic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#m
iGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~In
putF'/%,mathvariantGQ'italicF'-F#6&-I+munderoverGF$6'-I#moGF$6/Q&&Sum;
F'/%+foregroundGQ.[144,144,144]F'/F8Q'normalF'/I+msemanticsGF$Q&inertF
'/%&fenceGQ&falseF'/%*separatorGFM/%)stretchyGF1/%*symmetricGFM/%(larg
eopGF1/%.movablelimitsGF1/%'accentGFM/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.
1666667emF'-F#6%-F,6%Q\"iF'F/F7-F@6-Q\"=F'FFFKFN/FQFMFR/FUFM/FWFMFX/Fe
nQ,0.2777778emF'/FhnFfo-I#mnGF$6$Q\"1F'FF-Fio6$Q%1000F'FFFX/%,accentun
derGFMF+-I'mspaceGF$6&/%'heightGQ&0.0exF'/%&widthGQ$5.0F'/%&depthGFfp/
%*linebreakGQ%autoF'F\\oF+" }{TEXT 373 0 "" }}{PARA 0 "" 0 "" {TEXT 
371 356 "The basic idea of using a for-loop to compute a sum is that w
e compute a running total. If you want to add 1+2+3+4+5+6+7, we start \+
with 0, then we add 1 to 0, then we take the result and add 2 to it, t
hen we take that result and add 3 to it, then we take that result and \+
add 4 to it, etc. In the following for-loop, we will let the running t
otal be called " }{TEXT 0 1 "s" }{TEXT 371 6 " (for " }{TEXT 0 1 "s" }
{TEXT 371 27 "um) and we will initialize " }{TEXT 0 1 "s" }{TEXT 371 
252 " with the value 0. Notice how the single command in the body of t
he for-loop adds another integer to the sum for each iterate of the lo
op. Compare this for-loop with the sigma notation above. In what ways \+
are they alike and in what ways do they differ." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 8 "s := 0:\n" }{MPLTEXT 1 0 39 "for i from 1 to 100
0 do s := s + i od:\n" }}}{PARA 0 "" 0 "" {TEXT 371 121 "Notice that w
e have a colon at the end of the loop so that we do not see 1000 lines
 of output. Let us check the value of " }{TEXT 0 1 "s" }{TEXT 371 10 "
, the sum." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "s;" }}}{PARA 0 
"" 0 "" {TEXT 371 36 "Now verify this against the formula " }{XPPEDIT 
18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", execu
table = \"true\", font_style_name = \"2D Input\", mathvariant = \"ital
ic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mat
hvariant = \"italic\"), Typesetting:-mo(\"&ApplyFunction;\", mathvaria
nt = \"normal\", fence = \"false\", separator = \"false\", stretchy = \+
\"false\", symmetric = \"false\", largeop = \"false\", movablelimits =
 \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"
), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"\", italic
 = \"true\", executable = \"true\", font_style_name = \"2D Input\", ma
thvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", ital
ic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", mathv
ariant = \"normal\", fence = \"false\", separator = \"false\", stretch
y = \"false\", symmetric = \"false\", largeop = \"false\", movablelimi
ts = \"false\", accent = \"false\", lspace = \"0.2222222em\", rspace =
 \"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant = \"normal\")), \+
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\")), mathvariant = \"
normal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"tr
ue\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'
italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathv
ariantGQ'italicF'-F#6%-F,6%Q\"nF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8Q
'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGF
G/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ&0.0emF'/%'rsp
aceGFV-I(mfencedGF$6$-F#6%F+-F#6%F<-F@6-Q\"+F'FCFEFHFJFLFNFPFR/FUQ,0.2
222222emF'/FXF^o-I#mnGF$6$Q\"1F'FCF+FCF+" }{TEXT 371 3 "/2." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "1000*(1000+1)/2;" }}}{PARA 0 "" 0 "
" {TEXT 371 78 "By the way, Maple can verify the above (symbolic) form
ula for us by using the " }{TEXT 0 3 "sum" }{TEXT 371 9 " command." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "i:='i': n:='n':" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "sum( i, i=1..n );" }}}{EXCHG {PARA 
0 "> " 0 "" {MPLTEXT 1 0 12 "factor( % );" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 ""
 {TEXT 296 8 "Exercise" }{TEXT 371 27 ": Write a procedure called " }
{TEXT 0 8 "add_list" }{TEXT 371 110 " that takes one input, a list of \+
numbers, and computes the sum of the numbers in the list. Do not use M
aple's " }{TEXT 0 3 "add" }{TEXT 371 4 " or " }{TEXT 0 3 "sum" }{TEXT 
371 10 " commands." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 82 "Here is
 another example of computing a sum. We know from calculus that the nu
mber " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mo(\"&Exponentia
lE;\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rs
pace = \"0.1111111em\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI
(_syslibGF'6#-I#moGF$6-Q/&ExponentialE;F'/%,mathvariantGQ'normalF'/%&f
enceGQ&falseF'/%*separatorGF4/%)stretchyGF4/%*symmetricGF4/%(largeopGF
4/%.movablelimitsGF4/%'accentGF4/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.11111
11emF'" }{TEXT 371 92 " is the sum of the reciprocals of all the facto
rials. So we can compute an approximation of " }{XPPEDIT 18 0 "Typeset
ting:-mrow(Typesetting:-mo(\"&ExponentialE;\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.0em\", rspace = \"0.1111111em\"));" "-
I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#moGF$6-Q/&Exp
onentialE;F'/%,mathvariantGQ'normalF'/%&fenceGQ&falseF'/%*separatorGF4
/%)stretchyGF4/%*symmetricGF4/%(largeopGF4/%.movablelimitsGF4/%'accent
GF4/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.1111111emF'" }{TEXT 371 151 " by s
umming the reciprocals of the factorials from say 0! to 10!. So we wan
t a for-loop that will compute the following sum, written in sigma not
ation." }}{PARA 217 "" 0 "" {XPPEDIT 18 0 "Typesetting:-mrow(Typesetti
ng:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name
 = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesett
ing:-munderover(Typesetting:-mo(\"&Sum;\", foreground = \"[144,144,144
]\", mathvariant = \"normal\", Typesetting:-msemantics = \"inert\", fe
nce = \"false\", separator = \"false\", stretchy = \"true\", symmetric
 = \"false\", largeop = \"true\", movablelimits = \"true\", accent = \+
\"false\", lspace = \"0.0em\", rspace = \"0.1666667em\"), Typesetting:
-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"italic
\"), Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"false
\", separator = \"false\", stretchy = \"false\", symmetric = \"false\"
, largeop = \"false\", movablelimits = \"false\", accent = \"false\", \+
lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mn(
\"0\", mathvariant = \"normal\")), Typesetting:-mn(\"10\", mathvariant
 = \"normal\"), accent = \"false\", accentunder = \"false\"), Typesett
ing:-mi(\"\", italic = \"true\", executable = \"true\", font_style_nam
e = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mspace(heigh
t = \"0.0ex\", width = \"5.0\", depth = \"0.0ex\", linebreak = \"auto
\"), Typesetting:-mfrac(Typesetting:-mrow(Typesetting:-mn(\"1\", mathv
ariant = \"normal\")), Typesetting:-mrow(Typesetting:-mi(\"\", italic \+
= \"true\", executable = \"true\", font_style_name = \"2D Input\", mat
hvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", itali
c = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"!\", mathva
riant = \"normal\", fence = \"false\", separator = \"false\", stretchy
 = \"false\", symmetric = \"false\", largeop = \"false\", movablelimit
s = \"false\", accent = \"false\", lspace = \"0.1111111em\", rspace = \+
\"0.1111111em\")), Typesetting:-mi(\"\", italic = \"true\", executable
 = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")
), linethickness = \"1\", denomalign = \"center\", numalign = \"center
\", bevelled = \"false\")), Typesetting:-mi(\"\", italic = \"true\", e
xecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"
italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-
I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D
~InputF'/%,mathvariantGQ'italicF'-F#6&-I+munderoverGF$6'-I#moGF$6/Q&&S
um;F'/%+foregroundGQ.[144,144,144]F'/F8Q'normalF'/I+msemanticsGF$Q&ine
rtF'/%&fenceGQ&falseF'/%*separatorGFM/%)stretchyGF1/%*symmetricGFM/%(l
argeopGF1/%.movablelimitsGF1/%'accentGFM/%'lspaceGQ&0.0emF'/%'rspaceGQ
,0.1666667emF'-F#6%-F,6%Q\"nF'F/F7-F@6-Q\"=F'FFFKFN/FQFMFR/FUFM/FWFMFX
/FenQ,0.2777778emF'/FhnFfo-I#mnGF$6$Q\"0F'FF-Fio6$Q#10F'FFFX/%,accentu
nderGFMF+-I'mspaceGF$6&/%'heightGQ&0.0exF'/%&widthGQ$5.0F'/%&depthGFfp
/%*linebreakGQ%autoF'-I&mfracGF$6(-F#6#-Fio6$Q\"1F'FF-F#6%F+-F#6$F\\o-
F@6-Q\"!F'FFFKFNFboFRFcoFdoFX/FenQ,0.1111111emF'/FhnF_rF+/%.linethickn
essGFfq/%+denomalignGQ'centerF'/%)numalignGFer/%)bevelledGFMF+" }{TEXT
 374 0 "" }}{PARA 0 "" 0 "" {TEXT 371 51 "Compare the next for-loop wi
th this sigma notation." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "e \+
:= 0;\n" }{MPLTEXT 1 0 42 "for n from 0 to 10 do e := e + 1/(n!) od;\n
" }}}{PARA 0 "" 0 "" {TEXT 371 97 "That is not what we really want. Le
t us modify the loop so that it computes with decimal numbers." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "e := 0;\n" }{MPLTEXT 1 0 44 "
for i from 0 to 10 do e := e + 1.0/(i!) od;\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 125 "In this example we put a semi colon at the end of the l
oop so that we could see the answers converge to the correct value of 
" }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mo(\"&ExponentialE;\"
, mathvariant = \"normal\", fence = \"false\", separator = \"false\", \+
stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mova
blelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace \+
= \"0.1111111em\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_sys
libGF'6#-I#moGF$6-Q/&ExponentialE;F'/%,mathvariantGQ'normalF'/%&fenceG
Q&falseF'/%*separatorGF4/%)stretchyGF4/%*symmetricGF4/%(largeopGF4/%.m
ovablelimitsGF4/%'accentGF4/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.1111111emF
'" }{TEXT 371 61 ", which is given by the next command (to ten decimal
 places)." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "evalf( exp(1) )
;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 119 "Now let us turn to Rie
mann sums. The following execution group will compute a (left hand) Ri
emann sum for the function " }{TEXT 0 1 "f" }{TEXT 371 24 " over the i
nterval from " }{TEXT 0 1 "a" }{TEXT 371 4 " to " }{TEXT 0 1 "b" }
{TEXT 371 7 " using " }{TEXT 0 1 "n" }{TEXT 371 66 " rectangles. If yo
u want to, you can change any of the values for " }{TEXT 0 1 "f" }
{TEXT 371 2 ", " }{TEXT 0 1 "a" }{TEXT 371 2 ", " }{TEXT 0 1 "b" }
{TEXT 371 4 " or " }{TEXT 0 1 "n" }{TEXT 371 1 "." }}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 41 "f := x -> sin(x);        # The function.\n" }
{MPLTEXT 1 0 47 "a := 0;                  # Left hand endpoint.\n" }
{MPLTEXT 1 0 48 "b := 2*Pi;               # Right hand endpoint.\n" }
{MPLTEXT 1 0 48 "n := 100;                # How many rectangles.\n" }
{MPLTEXT 1 0 56 "L||n := 0:                # Set the running total to \+
0.\n" }{MPLTEXT 1 0 26 "for i from 0 to n-1 do   \n" }{MPLTEXT 1 0 60 
"   x||i := a+i*(b-a)/n;        # Compute a partition point.\n" }
{MPLTEXT 1 0 65 "   L||n := L||n+f(x||i)*(b-a)/n  # Add area of rectan
gle to sum.\n" }{MPLTEXT 1 0 4 "od:\n" }{MPLTEXT 1 0 58 "'L[n]' = %;  \+
          # Display the result symbolically,\n" }{MPLTEXT 1 0 41 "'L[n
]' = evalf(%%);    # and numerically\n" }}}{PARA 0 "" 0 "" {TEXT 371 
117 "You should think of the for-loop in this execution group as the M
aple version of the following formula from calculus." }}{PARA 0 "" 0 "
" {TEXT 371 62 "                                                      \+
        " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", ital
ic = \"true\", executable = \"true\", font_style_name = \"2D Input\", \+
mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-msub(Typeset
ting:-mi(\"L\", italic = \"true\", mathvariant = \"italic\"), Typesett
ing:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"it
alic\")), subscriptshift = \"0\"), Typesetting:-mo(\"=\", mathvariant \+
= \"normal\", fence = \"false\", separator = \"false\", stretchy = \"f
alse\", symmetric = \"false\", largeop = \"false\", movablelimits = \"
false\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.27
77778em\"), Typesetting:-mrow(Typesetting:-munderover(Typesetting:-mo(
\"&Sum;\", foreground = \"[144,144,144]\", mathvariant = \"normal\", T
ypesetting:-msemantics = \"inert\", fence = \"false\", separator = \"f
alse\", stretchy = \"true\", symmetric = \"false\", largeop = \"true\"
, movablelimits = \"true\", accent = \"false\", lspace = \"0.0em\", rs
pace = \"0.1666667em\"), Typesetting:-mrow(Typesetting:-mi(\"i\", ital
ic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"=\", mathv
ariant = \"normal\", fence = \"false\", separator = \"false\", stretch
y = \"false\", symmetric = \"false\", largeop = \"false\", movablelimi
ts = \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace =
 \"0.2777778em\"), Typesetting:-mn(\"0\", mathvariant = \"normal\")), \+
Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvarian
t = \"italic\"), Typesetting:-mo(\"&minus;\", mathvariant = \"normal\"
, fence = \"false\", separator = \"false\", stretchy = \"false\", symm
etric = \"false\", largeop = \"false\", movablelimits = \"false\", acc
ent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), \+
Typesetting:-mn(\"1\", mathvariant = \"normal\")), accent = \"false\",
 accentunder = \"false\"), Typesetting:-mi(\"\", italic = \"true\", ex
ecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"i
talic\"), Typesetting:-mspace(height = \"0.0ex\", width = \"5.0\", dep
th = \"0.0ex\", linebreak = \"auto\"), Typesetting:-mrow(Typesetting:-
mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting
:-mi(\"f\", italic = \"true\", mathvariant = \"italic\"), Typesetting:
-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", \+
separator = \"false\", stretchy = \"false\", symmetric = \"false\", la
rgeop = \"false\", movablelimits = \"false\", accent = \"false\", lspa
ce = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:
-mrow(Typesetting:-msub(Typesetting:-mi(\"x\", italic = \"true\", math
variant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"i\", italic
 = \"true\", mathvariant = \"italic\")), subscriptshift = \"0\")), mat
hvariant = \"normal\")), Typesetting:-mo(\"&InvisibleTimes;\", mathvar
iant = \"normal\", fence = \"false\", separator = \"false\", stretchy \+
= \"false\", symmetric = \"false\", largeop = \"false\", movablelimits
 = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em
\"), Typesetting:-mi(\"\1624\", italic = \"false\", mathvariant = \"no
rmal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesettin
g:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")), Typesettin
g:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name \+
= \"2D Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", ital
ic = \"true\", executable = \"true\", font_style_name = \"2D Input\", \+
mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", e
xecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"
italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-
I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D
~InputF'/%,mathvariantGQ'italicF'-F#6&-I%msubGF$6%-F,6%Q\"LF'F/F7-F#6#
-F,6%Q\"nF'F/F7/%/subscriptshiftGQ\"0F'-I#moGF$6-Q\"=F'/F8Q'normalF'/%
&fenceGQ&falseF'/%*separatorGFR/%)stretchyGFR/%*symmetricGFR/%(largeop
GFR/%.movablelimitsGFR/%'accentGFR/%'lspaceGQ,0.2777778emF'/%'rspaceGF
[o-F#6'-I+munderoverGF$6'-FK6/Q&&Sum;F'/%+foregroundGQ.[144,144,144]F'
FN/I+msemanticsGF$Q&inertF'FPFS/FVF1FW/FZF1/FfnF1Fgn/FjnQ&0.0emF'/F]oQ
,0.1666667emF'-F#6%-F,6%Q\"iF'F/F7FJ-I#mnGF$6$FIFN-F#6%FD-FK6-Q(&minus
;F'FNFPFSFUFWFYFenFgn/FjnQ,0.2222222emF'/F]oFaq-Fip6$Q\"1F'FNFgn/%,acc
entunderGFRF+-I'mspaceGF$6&/%'heightGQ&0.0exF'/%&widthGQ$5.0F'/%&depth
GF]r/%*linebreakGQ%autoF'-F#6(F+-F#6%-F,6%Q\"fF'F/F7-FK6-Q0&ApplyFunct
ion;F'FNFPFSFUFWFYFenFgnF_p/F]oF`p-I(mfencedGF$6$-F#6#-F=6%-F,6%Q\"xF'
F/F7-F#6#FepFGFN-FK6-Q1&InvisibleTimes;F'FNFPFSFUFWFYFenFgnF_pF`s-F,6%
Q(&Delta;F'/F0FRFNF]tFhsF+F+F+" }}{PARA 0 "" 0 "" {TEXT 371 288 "This \+
sigma-notation represents the sum and the for-loop in the execution gr
oup computes the sum. An interesting feature of actually computing the
 sum, instead of just representing it abstractly, is that the computat
ion must be very precise about what it is doing. For example, notice h
ow " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-msub(Typesetting:-
mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-m
row(Typesetting:-mi(\"i\", italic = \"true\", mathvariant = \"italic\"
)), subscriptshift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesetti
ngGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,math
variantGQ'italicF'-F#6#-F/6%Q\"iF'F2F5/%/subscriptshiftGQ\"0F'" }{TEXT
 371 64 " in the sigma-notation is a short hand for the Maple expressi
on " }{TEXT 0 11 "a+i*(b-a)/n" }{TEXT 371 101 ". In calculus courses w
here this sigma-notation is used, students often do not realize just w
hat the " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-msub(Typesett
ing:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetti
ng:-mrow(Typesetting:-mi(\"i\", italic = \"true\", mathvariant = \"ita
lic\")), subscriptshift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,Type
settingGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%
,mathvariantGQ'italicF'-F#6#-F/6%Q\"iF'F2F5/%/subscriptshiftGQ\"0F'" }
{TEXT 371 134 "  represents. But if you have to write a Maple for-loop
 to implement the sum, then you are forced to explicitly state what th
e symbol " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-msub(Typeset
ting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesett
ing:-mrow(Typesetting:-mi(\"i\", italic = \"true\", mathvariant = \"it
alic\")), subscriptshift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,Typ
esettingGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'-F#6#-F/6%Q\"iF'F2F5/%/subscriptshiftGQ\"0F'" 
}{TEXT 371 58 " means. Maple will not be able to figure out for you wh
at " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-msub(Typesetting:-
mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-m
row(Typesetting:-mi(\"i\", italic = \"true\", mathvariant = \"italic\"
)), subscriptshift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesetti
ngGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,math
variantGQ'italicF'-F#6#-F/6%Q\"iF'F2F5/%/subscriptshiftGQ\"0F'" }{TEXT
 371 60 " represents if you use it in a for-loop without defining it."
 }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT
 371 0 "" }}{PARA 0 "" 0 "" {TEXT 297 8 "Exercise" }{TEXT 371 43 ": Mo
dify the execution group for computing " }{XPPEDIT 18 0 "Typesetting:-
mrow(Typesetting:-msub(Typesetting:-mi(\"L\", italic = \"true\", mathv
ariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic \+
= \"true\", mathvariant = \"italic\")), subscriptshift = \"0\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I%msubGF$6%-I#mi
GF$6%Q\"LF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'-F#6#-F/6%Q\"nF'
F2F5/%/subscriptshiftGQ\"0F'" }{TEXT 371 12 " to compute " }{XPPEDIT 
18 0 "Typesetting:-mrow(Typesetting:-msub(Typesetting:-mi(\"R\", itali
c = \"true\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting
:-mi(\"n\", italic = \"true\", mathvariant = \"italic\")), subscriptsh
ift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'
6#-I%msubGF$6%-I#miGF$6%Q\"RF'/%'italicGQ%trueF'/%,mathvariantGQ'itali
cF'-F#6#-F/6%Q\"nF'F2F5/%/subscriptshiftGQ\"0F'" }{TEXT 371 32 ", righ
t hand sums, and then try " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesett
ing:-msub(Typesetting:-mi(\"T\", italic = \"true\", mathvariant = \"it
alic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", m
athvariant = \"italic\")), subscriptshift = \"0\"));" "-I%mrowG6#/I+mo
dulenameG6\"I,TypesettingGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6%Q\"TF'/%
'italicGQ%trueF'/%,mathvariantGQ'italicF'-F#6#-F/6%Q\"nF'F2F5/%/subscr
iptshiftGQ\"0F'" }{TEXT 371 4 " nd " }{XPPEDIT 18 0 "Typesetting:-mrow
(Typesetting:-msub(Typesetting:-mi(\"S\", italic = \"true\", mathvaria
nt = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"
true\", mathvariant = \"italic\")), subscriptshift = \"0\"));" "-I%mro
wG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I%msubGF$6%-I#miGF$6
%Q\"SF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'-F#6#-F/6%Q\"nF'F2F5
/%/subscriptshiftGQ\"0F'" }{TEXT 371 40 ", the trapezoid sums and Simp
son's rule." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "
" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
}{SECT 0 {PARA 5 "" 0 "" {TEXT 372 36 "17.3.2. Example 2: Pascal's tri
angle" }}{PARA 0 "" 0 "" {TEXT 371 144 "Our next example shows how we \+
can develop a procedure for printing out Pascal's triangle. The next f
or-loop prints out a table of expansions of " }{XPPEDIT 18 0 "Typesett
ing:-mrow(Typesetting:-msup(Typesetting:-mfenced(Typesetting:-mrow(Typ
esetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Type
setting:-mo(\"+\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mi(\"y\", ita
lic = \"true\", mathvariant = \"italic\")), mathvariant = \"normal\"),
 Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"italic\"), \+
superscriptshift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesetting
GI(_syslibGF'6#-I%msupGF$6%-I(mfencedGF$6$-F#6%-I#miGF$6%Q\"xF'/%'ital
icGQ%trueF'/%,mathvariantGQ'italicF'-I#moGF$6-Q\"+F'/F;Q'normalF'/%&fe
nceGQ&falseF'/%*separatorGFE/%)stretchyGFE/%*symmetricGFE/%(largeopGFE
/%.movablelimitsGFE/%'accentGFE/%'lspaceGQ,0.2222222emF'/%'rspaceGFT-F
46%Q\"yF'F7F:FA-F46%Q\"nF'F7F:/%1superscriptshiftGQ\"0F'" }{TEXT 371 
1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "x:='x': y:='y': \n" 
}{MPLTEXT 1 0 22 "for i from 0 to 8 do \n" }{MPLTEXT 1 0 21 "  expand(
 (x+y)^i );\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 
289 "The coefficients in these polynomials have a name (the binomial c
oefficients) and they make up what is called Pascal's triangle. Pascal
's triangle and the binomial coefficients have a lot of interesting pr
operties, so let us see if we can extract Pascal's triangle out of the
 last example." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 18 "The Maple command " }{TEXT 0 6 "coeffs" }{TEXT 371 204 "
 returns the coefficients of a polynomial as an expression sequence. T
he coefficients of the above polynomials make up Pascal's triangle. So
 let us see if the next for-loop will give us Pascal's triangle." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for i from 0 to 8 do\n" }
{MPLTEXT 1 0 31 "  coeffs( expand( (x+y)^i ) );\n" }{MPLTEXT 1 0 4 "od
;\n" }}}{PARA 0 "" 0 "" {TEXT 371 35 "That did not work. The output fr
om " }{TEXT 0 6 "coeffs" }{TEXT 371 168 " gives the coefficients of ea
ch polynomial as an expression sequence, but the coefficients are not \+
in the same order as in the polynomial (see the next two commands).  "
 }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "expand( (x+y)^8 );" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "coeffs( % );" }}}{PARA 0 "" 
0 "" {TEXT 371 319 "So we do not yet have Pascal's triangle. Let us tr
y another approach. Since polynomials are data structures, let us use \+
our knowledge of Maple's data structure commands to get the coefficien
ts of each polynomial in the order we want them. Since we want the coe
fficients to be in an expression sequence, we will use the " }{TEXT 0 
3 "seq" }{TEXT 371 24 " command. We can use an " }{TEXT 0 2 "op" }
{TEXT 371 85 " command to pick off the individual terms of the polynom
ial, and then we can use the " }{TEXT 0 6 "coeffs" }{TEXT 371 62 " com
mand to return the coefficient of just one term at a time." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "expand( (x+y)^8 );" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "seq( coeffs(op(j, %)), j=1..nops(%)
 );" }}}{PARA 0 "" 0 "" {TEXT 371 67 "That worked. Here is a for-loop \+
built around the last two commands." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "for i from 0 to 8 do\n" }{MPLTEXT 1 0 22 "   expand( \+
(x+y)^i );\n" }{MPLTEXT 1 0 42 "   seq( coeffs(op(j, %)), j=1..nops(%)
 );\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 59 "Oops, \+
too much output. Put a colon at the end of the final " }{TEXT 0 2 "od"
 }{TEXT 371 11 " and use a " }{TEXT 0 5 "print" }{TEXT 371 33 " comman
d in the body of the loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
21 "for i from 0 to 8 do\n" }{MPLTEXT 1 0 22 "   expand( (x+y)^i );\n"
 }{MPLTEXT 1 0 42 "   seq( coeffs(op(j, %)), j=1..nops(%) );\n" }
{MPLTEXT 1 0 15 "   print( % );\n" }{MPLTEXT 1 0 4 "od:\n" }}}{PARA 0 
"" 0 "" {TEXT 371 103 "There we go. Notice that every number in Pascal
's triangle is the sum of the two numbers just above it." }}{PARA 0 ""
 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 188 "Of course, if bi
nomial coefficients are important in mathematics, then we should expec
t Maple to have a command for computing them directly instead of picki
ng them out of the expansion of " }{XPPEDIT 18 0 "Typesetting:-mrow(Ty
pesetting:-msup(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi
(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"+\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em
\", rspace = \"0.2222222em\"), Typesetting:-mi(\"y\", italic = \"true
\", mathvariant = \"italic\")), mathvariant = \"normal\"), Typesetting
:-mi(\"n\", italic = \"true\", mathvariant = \"italic\"), superscripts
hift = \"0\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF
'6#-I%msupGF$6%-I(mfencedGF$6$-F#6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'-I#moGF$6-Q\"+F'/F;Q'normalF'/%&fenceGQ&falseF
'/%*separatorGFE/%)stretchyGFE/%*symmetricGFE/%(largeopGFE/%.movableli
mitsGFE/%'accentGFE/%'lspaceGQ,0.2222222emF'/%'rspaceGFT-F46%Q\"yF'F7F
:FA-F46%Q\"nF'F7F:/%1superscriptshiftGQ\"0F'" }{TEXT 371 15 ".  The co
mmand " }{TEXT 0 13 "binomial(n,j)" }{TEXT 371 45 " returns the coeffi
cient of the j'th term of " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesett
ing:-msup(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\"
, italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"+\",
 mathvariant = \"normal\", fence = \"false\", separator = \"false\", s
tretchy = \"false\", symmetric = \"false\", largeop = \"false\", movab
lelimits = \"false\", accent = \"false\", lspace = \"0.2222222em\", rs
pace = \"0.2222222em\"), Typesetting:-mi(\"y\", italic = \"true\", mat
hvariant = \"italic\")), mathvariant = \"normal\"), Typesetting:-mi(\"
n\", italic = \"true\", mathvariant = \"italic\"), superscriptshift = \+
\"0\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I%m
supGF$6%-I(mfencedGF$6$-F#6%-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathv
ariantGQ'italicF'-I#moGF$6-Q\"+F'/F;Q'normalF'/%&fenceGQ&falseF'/%*sep
aratorGFE/%)stretchyGFE/%*symmetricGFE/%(largeopGFE/%.movablelimitsGFE
/%'accentGFE/%'lspaceGQ,0.2222222emF'/%'rspaceGFT-F46%Q\"yF'F7F:FA-F46
%Q\"nF'F7F:/%1superscriptshiftGQ\"0F'" }{TEXT 371 1 "." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "seq( binomial(8,j), j=0..8 );" }}}
{PARA 0 "" 0 "" {TEXT 371 60 "So we can get Pascal's triangle with the
 following for-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "for \+
i from 0 to 8 do\n" }{MPLTEXT 1 0 32 "  seq( binomial(i,j), j=0..i );
\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 87 "Notice ho
w this loop uses two index variables, one for the loop itself and one \+
for the " }{TEXT 0 3 "seq" }{TEXT 371 14 " command. The " }{TEXT 0 1 "
i" }{TEXT 371 59 " index variable is counting the rows of our output a
nd the " }{TEXT 0 1 "j" }{TEXT 371 51 " index variable is counting the
 \"columns\". And the " }{TEXT 0 1 "i" }{TEXT 371 65 " index variable \+
from the \"outer loop\" is the final value for the " }{TEXT 0 1 "j" }
{TEXT 371 27 " index in the \"inner loop\"." }}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "
" {TEXT 371 182 "Here is a procedure that allows us to conveniently pr
int out as many lines of Pascal's triangle as we want.  (Notice the mu
ltiple levels of indentation to make this easier to read.) " }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "pascal := proc(m, n)\n" }{MPLTEXT 
1 0 20 "  local i, j, x, y;\n" }{MPLTEXT 1 0 23 "  for i from m to n d
o\n" }{MPLTEXT 1 0 24 "     expand( (x+y)^i );\n" }{MPLTEXT 1 0 44 "  \+
   seq( coeffs(op(j, %)), j=1..nops(%) );\n" }{MPLTEXT 1 0 17 "     pr
int( % );\n" }{MPLTEXT 1 0 6 "  od;\n" }{MPLTEXT 1 0 5 "end;\n" }}}
{PARA 0 "" 0 "" {TEXT 371 89 "Let us try it out. (On my computer scree
n I can fit up to 18 lines of Pascal's triangle.)" }}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 12 "pascal(0,8);" }}}{PARA 0 "" 0 "" {TEXT 371 
35 "Notice how this procedure uses the " }{TEXT 0 5 "print" }{TEXT 
371 241 " command to print out one line of Pascal's triangle for each \+
loop through the for-loop. Normally a procedure only has one output, w
hich is the last line executed by the procedure (the \"return value\" \+
of the procedure). But this procedure has " }{TEXT 0 1 "n" }{TEXT 371 
308 " lines of output. These extra lines of output have a name, they a
re called side effects.  Anything else that a procedure does besides r
eturning its \"return value\" is called a side effect. (You may wonder
 just what the return value of this procedure is. We will look at that
 question later in this worksheet.)" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 298 8 "Exercise" }{TEXT 371 43 ": Modify the procedure so that i
t uses the " }{TEXT 0 8 "binomial" }{TEXT 371 24 " command instead of \+
the " }{TEXT 0 6 "expand" }{TEXT 371 5 " and " }{TEXT 0 5 "coeff" }
{TEXT 371 10 " commands." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}}}{SECT 1 {PARA 5 "" 0 "" {TEXT 372 38 "17.3.3. Example 3:
 Periodic extensions" }}{PARA 0 "" 0 "" {TEXT 371 128 "Our third examp
le will use a while-loop. We show how to take an arbitrary function g \+
defined on an interval between two numbers " }{XPPEDIT 18 0 "Typesetti
ng:-mrow(Typesetting:-mi(\"a\", italic = \"true\", mathvariant = \"ita
lic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#m
iGF$6%Q\"aF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 5 
" and " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"b\", itali
c = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italicGQ%trueF'/%,mat
hvariantGQ'italicF'" }{TEXT 371 2 ", " }{XPPEDIT 18 0 "Typesetting:-mr
ow(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", fon
t_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-m
row(Typesetting:-mi(\"a\", italic = \"true\", mathvariant = \"italic\"
), Typesetting:-mo(\"<\", mathvariant = \"normal\", fence = \"false\",
 separator = \"false\", stretchy = \"false\", symmetric = \"false\", l
argeop = \"false\", movablelimits = \"false\", accent = \"false\", lsp
ace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mi(\"b
\", italic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"
\", italic = \"true\", executable = \"true\", font_style_name = \"2D I
nput\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typ
esettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF
1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"
aF'F/F7-I#moGF$6-Q\"<F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/
%)stretchyGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentG
FG/%'lspaceGQ,0.2777778emF'/%'rspaceGFV-F,6%Q\"bF'F/F7F+" }{TEXT 371 
80 ", and produce a function f that is periodic on the whole real line
, with period " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\"
, italic = \"true\", executable = \"true\", font_style_name = \"2D Inp
ut\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"p
\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"=
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.2777778em\",
 rspace = \"0.2777778em\"), Typesetting:-mrow(Typesetting:-mi(\"b\", i
talic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&minus;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em\",
 rspace = \"0.2222222em\"), Typesetting:-mi(\"a\", italic = \"true\", \+
mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", e
xecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"
italic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"tr
ue\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'
italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathv
ariantGQ'italicF'-F#6&-F,6%Q\"pF'F/F7-I#moGF$6-Q\"=F'/F8Q'normalF'/%&f
enceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGF
G/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.2777778emF'/%'rspaceGFV-
F#6%-F,6%Q\"bF'F/F7-F@6-Q(&minus;F'FCFEFHFJFLFNFPFR/FUQ,0.2222222emF'/
FXF\\o-F,6%Q\"aF'F/F7F+F+" }{TEXT 371 40 ", and is equal to the origin
al function " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"g\",
 italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"gF'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'" }{TEXT 371 9 " between " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mi(\"a\", italic = \"true\", mathvariant =
 \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'
6#-I#miGF$6%Q\"aF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 
371 5 " and " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"b\",
 italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'" }{TEXT 371 34 ". This new function is called
 the " }{TEXT 299 18 "periodic extension" }{TEXT 371 26 " of the origi
nal function." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0
 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 190 "Before showin
g how to use Maple to define the periodic extension, let us try to des
cribe it in words. We start with what we might think of as a segment o
f a function g, defined just between " }{XPPEDIT 18 0 "Typesetting:-mr
ow(Typesetting:-mi(\"a\", italic = \"true\", mathvariant = \"italic\")
);" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%
Q\"aF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 5 " and 
" }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"
true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typ
esettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italicGQ%trueF'/%,mathvarian
tGQ'italicF'" }{TEXT 371 138 ". The periodic extension f will have cop
ies of this segment repeated over and over again on the real line. The
re will be one copy between " }{XPPEDIT 18 0 "Typesetting:-mrow(Typese
tting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\"));" "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'
italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 5 " and " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"tr
ue\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222
222em\"), Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"it
alic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'it
alicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvar
iantGQ'italicF'-F#6%-F,6%Q\"bF'F/F7-I#moGF$6-Q\"+F'/F8Q'normalF'/%&fen
ceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGFG/
%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.2222222emF'/%'rspaceGFV-F,
6%Q\"pF'F/F7F+" }{TEXT 371 8 " (where " }{XPPEDIT 18 0 "Typesetting:-m
row(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", fo
nt_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-
mrow(Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"italic
\"), Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"false
\", separator = \"false\", stretchy = \"false\", symmetric = \"false\"
, largeop = \"false\", movablelimits = \"false\", accent = \"false\", \+
lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mrow
(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\"), \+
Typesetting:-mo(\"&minus;\", mathvariant = \"normal\", fence = \"false
\", separator = \"false\", stretchy = \"false\", symmetric = \"false\"
, largeop = \"false\", movablelimits = \"false\", accent = \"false\", \+
lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mi(
\"a\", italic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_s
yslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_styl
e_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6&-F,6%Q\"pF'F/F7-I#moG
F$6-Q\"=F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG
/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ
,0.2777778emF'/%'rspaceGFV-F#6%-F,6%Q\"bF'F/F7-F@6-Q(&minus;F'FCFEFHFJ
FLFNFPFR/FUQ,0.2222222emF'/FXF\\o-F,6%Q\"aF'F/F7F+F+" }{TEXT 371 89 " \+
is the length of the interval that g is originally defined on) and ano
ther copy between " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"b\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"+\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em
\", rspace = \"0.2222222em\"), Typesetting:-mi(\"p\", italic = \"true
\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibG
F'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_name
GQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"bF'F/F7-I#moGF$6-Q
\"+F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*sy
mmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.22
22222emF'/%'rspaceGFV-F,6%Q\"pF'F/F7F+" }{TEXT 371 5 " and " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"tr
ue\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222
222em\"), Typesetting:-mrow(Typesetting:-mn(\"2\", mathvariant = \"nor
mal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\"
, fence = \"false\", separator = \"false\", stretchy = \"false\", symm
etric = \"false\", largeop = \"false\", movablelimits = \"false\", acc
ent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:
-mi(\"p\", italic = \"true\", mathvariant = \"italic\")), Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic
 = \"true\", executable = \"true\", font_style_name = \"2D Input\", ma
thvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI
(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_s
tyle_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6&-F,6%Q\"bF'F/F7-I#
moGF$6-Q\"+F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchy
GFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspac
eGQ,0.2222222emF'/%'rspaceGFV-F#6%-I#mnGF$6$Q\"2F'FC-F@6-Q1&InvisibleT
imes;F'FCFEFHFJFLFNFPFR/FUQ&0.0emF'/FXF]o-F,6%Q\"pF'F/F7F+F+" }{TEXT 
371 73 ", etc. How should we define the extension f on the \"first\" i
nterval from " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"b\"
, italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+module
nameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italicGQ%trueF'
/%,mathvariantGQ'italicF'" }{TEXT 371 4 " to " }{XPPEDIT 18 0 "Typeset
ting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"tru
e\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Typese
tting:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"
italic\"), Typesetting:-mo(\"+\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:
-mi(\"p\", italic = \"true\", mathvariant = \"italic\")), Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+execu
tableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-
F,6%Q\"bF'F/F7-I#moGF$6-Q\"+F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separa
torGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'
accentGFG/%'lspaceGQ,0.2222222emF'/%'rspaceGFV-F,6%Q\"pF'F/F7F+" }
{TEXT 371 75 "? Visually, we would just imagine sliding the graph of g
 from the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mf
enced(Typesetting:-mrow(Typesetting:-mi(\"a\", italic = \"true\", math
variant = \"italic\"), Typesetting:-mo(\",\", mathvariant = \"normal\"
, fence = \"false\", separator = \"true\", stretchy = \"false\", symme
tric = \"false\", largeop = \"false\", movablelimits = \"false\", acce
nt = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Typeset
ting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\")), mathvar
iant = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modul
enameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#miGF$6%Q\"
aF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'-I#moGF$6-Q\",F'/F8Q'nor
malF'/%&fenceGQ&falseF'/%*separatorGF6/%)stretchyGFB/%*symmetricGFB/%(
largeopGFB/%.movablelimitsGFB/%'accentGFB/%'lspaceGQ&0.0emF'/%'rspaceG
Q,0.3333333emF'-F16%Q\"bF'F4F7F>/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 
371 24 " over onto the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Ty
pesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \+
\"true\", mathvariant = \"italic\"), Typesetting:-mo(\",\", mathvarian
t = \"normal\", fence = \"false\", separator = \"true\", stretchy = \"
false\", symmetric = \"false\", largeop = \"false\", movablelimits = \+
\"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.333333
3em\"), Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"true\", ma
thvariant = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\")
, Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"italic\"))
, Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\")), mathvariant = \+
\"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6&-I#miGF$6%Q\"bF'/%'i
talicGQ%trueF'/%,mathvariantGQ'italicF'-I#moGF$6-Q\",F'/F8Q'normalF'/%
&fenceGQ&falseF'/%*separatorGF6/%)stretchyGFB/%*symmetricGFB/%(largeop
GFB/%.movablelimitsGFB/%'accentGFB/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.333
3333emF'-F#6%F0-F;6-Q\"+F'F>F@/FDFBFEFGFIFKFM/FPQ,0.2222222emF'/FSFfn-
F16%Q\"pF'F4F7-F16'Q!F'F4/%+executableGF6/%0font_style_nameGQ)2D~Input
F'F7F>/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 58 ". We would express
 this mathematically by saying that, if " }{XPPEDIT 18 0 "Typesetting:
-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic
\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF
$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 7 " i
s in " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfenced(Typesett
ing:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"it
alic\"), Typesetting:-mo(\",\", mathvariant = \"normal\", fence = \"fa
lse\", separator = \"true\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-mrow(Typ
esetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\"), Type
setting:-mo(\"+\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mi(\"p\", ita
lic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", ital
ic = \"true\", executable = \"true\", font_style_name = \"2D Input\", \+
mathvariant = \"italic\")), mathvariant = \"normal\", open = \"[\", cl
ose = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'
6#-I(mfencedGF$6&-F#6&-I#miGF$6%Q\"bF'/%'italicGQ%trueF'/%,mathvariant
GQ'italicF'-I#moGF$6-Q\",F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separator
GF6/%)stretchyGFB/%*symmetricGFB/%(largeopGFB/%.movablelimitsGFB/%'acc
entGFB/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-F#6%F0-F;6-Q\"+F'F>
F@/FDFBFEFGFIFKFM/FPQ,0.2222222emF'/FSFfn-F16%Q\"pF'F4F7-F16'Q!F'F4/%+
executableGF6/%0font_style_nameGQ)2D~InputF'F7F>/%%openGQ\"[F'/%&close
GQ\"]F'" }{TEXT 371 7 ", then " }{XPPEDIT 18 0 "Typesetting:-mrow(Type
setting:-mi(\"\", italic = \"true\", executable = \"true\", font_style
_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typ
esetting:-mi(\"\", italic = \"true\", executable = \"true\", font_styl
e_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Ty
pesetting:-mi(\"f\", italic = \"true\", mathvariant = \"italic\"), Typ
esetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typ
esetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant =
 \"italic\")), mathvariant = \"normal\")), Typesetting:-mo(\"=\", math
variant = \"normal\", fence = \"false\", separator = \"false\", stretc
hy = \"false\", symmetric = \"false\", largeop = \"false\", movablelim
its = \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace \+
= \"0.2777778em\"), Typesetting:-mrow(Typesetting:-mi(\"g\", italic = \+
\"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&ApplyFunction;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspac
e = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi
(\"\", italic = \"true\", executable = \"true\", font_style_name = \"2
D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-m
i(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo
(\"&minus;\", mathvariant = \"normal\", fence = \"false\", separator =
 \"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"f
alse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.22
22222em\", rspace = \"0.2222222em\"), Typesetting:-mi(\"p\", italic = \+
\"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\")), mathvariant = \"normal\")), Typesetting:-mi(\"
\", italic = \"true\", executable = \"true\", font_style_name = \"2D I
nput\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"t
rue\", executable = \"true\", font_style_name = \"2D Input\", mathvari
ant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_sysl
ibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_n
ameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6'F+-F#6%-F,6%Q\"fF'F/F7-I
#moGF$6-Q0&ApplyFunction;F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separator
GFI/%)stretchyGFI/%*symmetricGFI/%(largeopGFI/%.movablelimitsGFI/%'acc
entGFI/%'lspaceGQ&0.0emF'/%'rspaceGFX-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/
F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRFT/FWQ,0.2777778emF'/FZFao-F#6%-F,6%Q\"gF
'F/F7FA-Ffn6$-F#6%F+-F#6%Fjn-FB6-Q(&minus;F'FEFGFJFLFNFPFRFT/FWQ,0.222
2222emF'/FZFbp-F,6%Q\"pF'F/F7F+FEF+F+" }{TEXT 371 61 " (make sure you \+
understand this step). For the interval from " }{XPPEDIT 18 0 "Typeset
ting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"tru
e\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Typese
tting:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"
italic\"), Typesetting:-mo(\"+\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:
-mi(\"p\", italic = \"true\", mathvariant = \"italic\")), Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+execu
tableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-
F,6%Q\"bF'F/F7-I#moGF$6-Q\"+F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separa
torGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'
accentGFG/%'lspaceGQ,0.2222222emF'/%'rspaceGFV-F,6%Q\"pF'F/F7F+" }
{TEXT 371 4 " to " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"b\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"+\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em
\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typesetting:-mn(\"2\"
, mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mat
hvariant = \"normal\", fence = \"false\", separator = \"false\", stret
chy = \"false\", symmetric = \"false\", largeop = \"false\", movableli
mits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0
.0em\"), Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"ita
lic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\")), Typese
tting:-mi(\"\", italic = \"true\", executable = \"true\", font_style_n
ame = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+
executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-
F#6&-F,6%Q\"bF'F/F7-I#moGF$6-Q\"+F'/F8Q'normalF'/%&fenceGQ&falseF'/%*s
eparatorGFG/%)stretchyGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsG
FG/%'accentGFG/%'lspaceGQ,0.2222222emF'/%'rspaceGFV-F#6%-I#mnGF$6$Q\"2
F'FC-F@6-Q1&InvisibleTimes;F'FCFEFHFJFLFNFPFR/FUQ&0.0emF'/FXF]o-F,6%Q
\"pF'F/F7F+F+" }{TEXT 371 58 ", we would again just imagine sliding th
e graph of g from " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfe
nced(Typesetting:-mrow(Typesetting:-mi(\"a\", italic = \"true\", mathv
ariant = \"italic\"), Typesetting:-mo(\",\", mathvariant = \"normal\",
 fence = \"false\", separator = \"true\", stretchy = \"false\", symmet
ric = \"false\", largeop = \"false\", movablelimits = \"false\", accen
t = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesett
ing:-mi(\"b\", italic = \"true\", mathvariant = \"italic\")), mathvari
ant = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+module
nameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#miGF$6%Q\"a
F'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'-I#moGF$6-Q\",F'/F8Q'norm
alF'/%&fenceGQ&falseF'/%*separatorGF6/%)stretchyGFB/%*symmetricGFB/%(l
argeopGFB/%.movablelimitsGFB/%'accentGFB/%'lspaceGQ&0.0emF'/%'rspaceGQ
,0.3333333emF'-F16%Q\"bF'F4F7F>/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 
371 9 " over to " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfenc
ed(Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executab
le = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic
\"), Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathv
ariant = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \"normal\",
 fence = \"false\", separator = \"false\", stretchy = \"false\", symme
tric = \"false\", largeop = \"false\", movablelimits = \"false\", acce
nt = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), T
ypesetting:-mi(\"p\", italic = \"true\", mathvariant = \"italic\")), T
ypesetting:-mo(\",\", mathvariant = \"normal\", fence = \"false\", sep
arator = \"true\", stretchy = \"false\", symmetric = \"false\", largeo
p = \"false\", movablelimits = \"false\", accent = \"false\", lspace =
 \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-mrow(Typesetting:-
mi(\"b\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-m
o(\"+\", mathvariant = \"normal\", fence = \"false\", separator = \"fa
lse\", stretchy = \"false\", symmetric = \"false\", largeop = \"false
\", movablelimits = \"false\", accent = \"false\", lspace = \"0.222222
2em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typesetting:-mn(\"
2\", mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", \+
mathvariant = \"normal\", fence = \"false\", separator = \"false\", st
retchy = \"false\", symmetric = \"false\", largeop = \"false\", movabl
elimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \+
\"0.0em\"), Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"
italic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"tr
ue\", font_style_name = \"2D Input\", mathvariant = \"italic\")), Type
setting:-mi(\"\", italic = \"true\", executable = \"true\", font_style
_name = \"2D Input\", mathvariant = \"italic\")), mathvariant = \"norm
al\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,Ty
pesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6'-I#miGF$6'Q!F'/%'italicGQ%
trueF'/%+executableGF6/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'
italicF'-F#6%-F16%Q\"bF'F4F<-I#moGF$6-Q\"+F'/F=Q'normalF'/%&fenceGQ&fa
lseF'/%*separatorGFL/%)stretchyGFL/%*symmetricGFL/%(largeopGFL/%.movab
lelimitsGFL/%'accentGFL/%'lspaceGQ,0.2222222emF'/%'rspaceGFen-F16%Q\"p
F'F4F<-FE6-Q\",F'FHFJ/FNF6FOFQFSFUFW/FZQ&0.0emF'/FgnQ,0.3333333emF'-F#
6&FAFD-F#6%-I#mnGF$6$Q\"2F'FH-FE6-Q1&InvisibleTimes;F'FHFJFMFOFQFSFUFW
F_o/FgnF`oFhnF0F0FH/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 9 ". And \+
if " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"x\", italic =
 \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,
TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathvar
iantGQ'italicF'" }{TEXT 371 7 " is in " }{XPPEDIT 18 0 "Typesetting:-m
row(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"\", itali
c = \"true\", executable = \"true\", font_style_name = \"2D Input\", m
athvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"b\", ita
lic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", math
variant = \"normal\", fence = \"false\", separator = \"false\", stretc
hy = \"false\", symmetric = \"false\", largeop = \"false\", movablelim
its = \"false\", accent = \"false\", lspace = \"0.2222222em\", rspace \+
= \"0.2222222em\"), Typesetting:-mi(\"p\", italic = \"true\", mathvari
ant = \"italic\")), Typesetting:-mo(\",\", mathvariant = \"normal\", f
ence = \"false\", separator = \"true\", stretchy = \"false\", symmetri
c = \"false\", largeop = \"false\", movablelimits = \"false\", accent \+
= \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesettin
g:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"ital
ic\"), Typesetting:-mo(\"+\", mathvariant = \"normal\", fence = \"fals
e\", separator = \"false\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mr
ow(Typesetting:-mn(\"2\", mathvariant = \"normal\"), Typesetting:-mo(
\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \"false\", sep
arator = \"false\", stretchy = \"false\", symmetric = \"false\", large
op = \"false\", movablelimits = \"false\", accent = \"false\", lspace \+
= \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"p\", italic = \"tr
ue\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"tru
e\", executable = \"true\", font_style_name = \"2D Input\", mathvarian
t = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable \+
= \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"))
, mathvariant = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6
#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6'-I#m
iGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF6/%0font_style_nameGQ)2D~In
putF'/%,mathvariantGQ'italicF'-F#6%-F16%Q\"bF'F4F<-I#moGF$6-Q\"+F'/F=Q
'normalF'/%&fenceGQ&falseF'/%*separatorGFL/%)stretchyGFL/%*symmetricGF
L/%(largeopGFL/%.movablelimitsGFL/%'accentGFL/%'lspaceGQ,0.2222222emF'
/%'rspaceGFen-F16%Q\"pF'F4F<-FE6-Q\",F'FHFJ/FNF6FOFQFSFUFW/FZQ&0.0emF'
/FgnQ,0.3333333emF'-F#6&FAFD-F#6%-I#mnGF$6$Q\"2F'FH-FE6-Q1&InvisibleTi
mes;F'FHFJFMFOFQFSFUFWF_o/FgnF`oFhnF0F0FH/%%openGQ\"[F'/%&closeGQ\"]F'
" }{TEXT 371 20 ", then we would let " }{XPPEDIT 18 0 "Typesetting:-mr
ow(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", fon
t_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-m
row(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", fo
nt_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-
mrow(Typesetting:-mi(\"f\", italic = \"true\", mathvariant = \"italic
\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fe
nce = \"false\", separator = \"false\", stretchy = \"false\", symmetri
c = \"false\", largeop = \"false\", movablelimits = \"false\", accent \+
= \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfe
nced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathv
ariant = \"italic\")), mathvariant = \"normal\")), Typesetting:-mo(\"=
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.2777778em\",
 rspace = \"0.2777778em\"), Typesetting:-mrow(Typesetting:-mi(\"g\", i
talic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&ApplyF
unction;\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.0em
\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typese
tting:-mi(\"\", italic = \"true\", executable = \"true\", font_style_n
ame = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Types
etting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typese
tting:-mo(\"&minus;\", mathvariant = \"normal\", fence = \"false\", se
parator = \"false\", stretchy = \"false\", symmetric = \"false\", larg
eop = \"false\", movablelimits = \"false\", accent = \"false\", lspace
 = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Types
etting:-mn(\"2\", mathvariant = \"normal\"), Typesetting:-mo(\"&Invisi
bleTimes;\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.0em
\", rspace = \"0.0em\"), Typesetting:-mi(\"p\", italic = \"true\", mat
hvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", exec
utable = \"true\", font_style_name = \"2D Input\", mathvariant = \"ita
lic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\")), mathva
riant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", executa
ble = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG
6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italic
GQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariant
GQ'italicF'-F#6'F+-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8
Q'normalF'/%&fenceGQ&falseF'/%*separatorGFI/%)stretchyGFI/%*symmetricG
FI/%(largeopGFI/%.movablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'/%'rs
paceGFX-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRF
T/FWQ,0.2777778emF'/FZFao-F#6%-F,6%Q\"gF'F/F7FA-Ffn6$-F#6%F+-F#6&Fjn-F
B6-Q(&minus;F'FEFGFJFLFNFPFRFT/FWQ,0.2222222emF'/FZFbp-F#6%-I#mnGF$6$Q
\"2F'FE-FB6-Q1&InvisibleTimes;F'FEFGFJFLFNFPFRFTFVFY-F,6%Q\"pF'F/F7F+F
+FEF+F+" }{TEXT 371 39 ". In general, for any positive integer " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"k\", italic = \"tru
e\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typese
ttingGI(_syslibGF'6#-I#miGF$6%Q\"kF'/%'italicGQ%trueF'/%,mathvariantGQ
'italicF'" }{TEXT 371 5 ", if " }{XPPEDIT 18 0 "Typesetting:-mrow(Type
setting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"xF'/
%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 7 " is in " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mr
ow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\")
, Typesetting:-mo(\"+\", mathvariant = \"normal\", fence = \"false\", \+
separator = \"false\", stretchy = \"false\", symmetric = \"false\", la
rgeop = \"false\", movablelimits = \"false\", accent = \"false\", lspa
ce = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typ
esetting:-mi(\"k\", italic = \"true\", mathvariant = \"italic\"), Type
setting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"p\", i
talic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", it
alic = \"true\", executable = \"true\", font_style_name = \"2D Input\"
, mathvariant = \"italic\")), Typesetting:-mo(\",\", mathvariant = \"n
ormal\", fence = \"false\", separator = \"true\", stretchy = \"false\"
, symmetric = \"false\", largeop = \"false\", movablelimits = \"false
\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"),
 Typesetting:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvaria
nt = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \"normal\", fen
ce = \"false\", separator = \"false\", stretchy = \"false\", symmetric
 = \"false\", largeop = \"false\", movablelimits = \"false\", accent =
 \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Types
etting:-mrow(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"
k\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"+
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em\",
 rspace = \"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant = \"nor
mal\")), mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspac
e = \"0.0em\"), Typesetting:-mi(\"p\", italic = \"true\", mathvariant \+
= \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")), \+
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\")), mathvariant = \"
normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"
I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6'-I#miGF$6'Q!F'/%'itali
cGQ%trueF'/%+executableGF6/%0font_style_nameGQ)2D~InputF'/%,mathvarian
tGQ'italicF'-F#6&-F16%Q\"bF'F4F<-I#moGF$6-Q\"+F'/F=Q'normalF'/%&fenceG
Q&falseF'/%*separatorGFL/%)stretchyGFL/%*symmetricGFL/%(largeopGFL/%.m
ovablelimitsGFL/%'accentGFL/%'lspaceGQ,0.2222222emF'/%'rspaceGFen-F#6%
-F16%Q\"kF'F4F<-FE6-Q1&InvisibleTimes;F'FHFJFMFOFQFSFUFW/FZQ&0.0emF'/F
gnFao-F16%Q\"pF'F4F<F0-FE6-Q\",F'FHFJ/FNF6FOFQFSFUFWF`o/FgnQ,0.3333333
emF'-F#6&FAFD-F#6%-F,6$-F#6%FjnFD-I#mnGF$6$Q\"1F'FHFHF]oFcoF0F0FH/%%op
enGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 7 ", then " }{XPPEDIT 18 0 "Types
etting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"t
rue\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Type
setting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"
true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Typ
esetting:-mrow(Typesetting:-mi(\"f\", italic = \"true\", mathvariant =
 \"italic\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"nor
mal\", fence = \"false\", separator = \"false\", stretchy = \"false\",
 symmetric = \"false\", largeop = \"false\", movablelimits = \"false\"
, accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typeset
ting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true
\", mathvariant = \"italic\")), mathvariant = \"normal\")), Typesettin
g:-mo(\"=\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.277
7778em\", rspace = \"0.2777778em\"), Typesetting:-mrow(Typesetting:-mi
(\"g\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", sepa
rator = \"false\", stretchy = \"false\", symmetric = \"false\", largeo
p = \"false\", movablelimits = \"false\", accent = \"false\", lspace =
 \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mr
ow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")
, Typesetting:-mo(\"&minus;\", mathvariant = \"normal\", fence = \"fal
se\", separator = \"false\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mr
ow(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"k\", itali
c = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", mathva
riant = \"normal\", fence = \"false\", separator = \"false\", stretchy
 = \"false\", symmetric = \"false\", largeop = \"false\", movablelimit
s = \"false\", accent = \"false\", lspace = \"0.2222222em\", rspace = \+
\"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant = \"normal\")), m
athvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathva
riant = \"normal\", fence = \"false\", separator = \"false\", stretchy
 = \"false\", symmetric = \"false\", largeop = \"false\", movablelimit
s = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0e
m\"), Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"italic
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\")), Typesettin
g:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name \+
= \"2D Input\", mathvariant = \"italic\")), mathvariant = \"normal\"))
, Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\")), Typesetting:-m
i(\"\", italic = \"true\", executable = \"true\", font_style_name = \"
2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I
,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executab
leGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6'F+-F
#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8Q'normalF'/%&fenceGQ
&falseF'/%*separatorGFI/%)stretchyGFI/%*symmetricGFI/%(largeopGFI/%.mo
vablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'/%'rspaceGFX-I(mfencedGF$
6$-F#6#-F,6%Q\"xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRFT/FWQ,0.2777778emF'/
FZFao-F#6%-F,6%Q\"gF'F/F7FA-Ffn6$-F#6%F+-F#6&Fjn-FB6-Q(&minus;F'FEFGFJ
FLFNFPFRFT/FWQ,0.2222222emF'/FZFbp-F#6%-Ffn6$-F#6%-F,6%Q\"kF'F/F7-FB6-
Q\"+F'FEFGFJFLFNFPFRFTFapFcp-I#mnGF$6$Q\"1F'FEFE-FB6-Q1&InvisibleTimes
;F'FEFGFJFLFNFPFRFTFVFY-F,6%Q\"pF'F/F7F+F+FEF+F+" }{TEXT 371 22 ". In \+
short, to define " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"f\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", sepa
rator = \"false\", stretchy = \"false\", symmetric = \"false\", largeo
p = \"false\", movablelimits = \"false\", accent = \"false\", lspace =
 \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"))
, mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\",
 executable = \"true\", font_style_name = \"2D Input\", mathvariant = \+
\"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6
%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)
2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&Ap
plyFunction;F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretch
yGFG/%*symmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspa
ceGQ&0.0emF'/%'rspaceGFV-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FCF+" }
{TEXT 371 5 " for " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"b\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"<\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.2777778em
\", rspace = \"0.2777778em\"), Typesetting:-mi(\"x\", italic = \"true
\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibG
F'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_name
GQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q\"bF'F/F7-I#moGF$6-Q
\"<F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*sy
mmetricGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.27
77778emF'/%'rspaceGFV-F,6%Q\"xF'F/F7F+" }{TEXT 371 29 " we need to kee
p subtracting " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"p
\", italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modu
lenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"pF'/%'italicGQ%true
F'/%,mathvariantGQ'italicF'" }{TEXT 371 6 " from " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant =
 \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'
6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 
371 39 " until we get a number that is between " }{XPPEDIT 18 0 "Types
etting:-mrow(Typesetting:-mi(\"a\", italic = \"true\", mathvariant = \+
\"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6
#-I#miGF$6%Q\"aF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 
371 5 " and " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"b\",
 italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'" }{TEXT 371 70 ", and then use that number to
 evaluate g. This process of subtracting " }{XPPEDIT 18 0 "Typesetting
:-mrow(Typesetting:-mi(\"p\", italic = \"true\", mathvariant = \"itali
c\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miG
F$6%Q\"pF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 8 "'
s from " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"x\", ital
ic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mat
hvariantGQ'italicF'" }{TEXT 371 31 " until we get a number between " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"a\", italic = \"tru
e\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typese
ttingGI(_syslibGF'6#-I#miGF$6%Q\"aF'/%'italicGQ%trueF'/%,mathvariantGQ
'italicF'" }{TEXT 371 5 " and " }{XPPEDIT 18 0 "Typesetting:-mrow(Type
setting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/
%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 79 " is exactly
 what a while-loop can do for us. Since we do not know the value of " 
}{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"tr
ue\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Types
ettingGI(_syslibGF'6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantG
Q'italicF'" }{TEXT 371 40 " ahead of time, we do not know how many " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"p\", italic = \"tru
e\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typese
ttingGI(_syslibGF'6#-I#miGF$6%Q\"pF'/%'italicGQ%trueF'/%,mathvariantGQ
'italicF'" }{TEXT 371 132 "'s we need to subtract, but while-loops are
 exactly what we should use when we want to iterate something an unkno
wn number of times." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "
" {TEXT 300 8 "Exercise" }{TEXT 371 33 ": Figure out how we would defi
ne " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"f\", italic \+
= \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&ApplyFunctio
n;\", mathvariant = \"normal\", fence = \"false\", separator = \"false
\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\", \+
movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rsp
ace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-
mi(\"x\", italic = \"true\", mathvariant = \"italic\")), mathvariant =
 \"normal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"));"
 "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F
'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,m
athvariantGQ'italicF'-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;F'
/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetr
icGFG/%(largeopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ&0.0emF'/%
'rspaceGFV-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FCF+" }{TEXT 371 5 " for 
" }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"t
rue\", executable = \"true\", font_style_name = \"2D Input\", mathvari
ant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \+
\"true\", mathvariant = \"italic\"), Typesetting:-mo(\"<\", mathvarian
t = \"normal\", fence = \"false\", separator = \"false\", stretchy = \+
\"false\", symmetric = \"false\", largeop = \"false\", movablelimits =
 \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0
.2777778em\"), Typesetting:-mi(\"a\", italic = \"true\", mathvariant =
 \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"));"
 "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F
'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,m
athvariantGQ'italicF'-F#6%-F,6%Q\"xF'F/F7-I#moGF$6-Q\"<F'/F8Q'normalF'
/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGFG/%(large
opGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.2777778emF'/%'rspace
GFV-F,6%Q\"aF'F/F7F+" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 4 "Let " }{TEXT 0 1 "g" }{TEXT 371 29 " be a Maple function \+
and let " }{TEXT 0 1 "a" }{TEXT 371 5 " and " }{TEXT 0 1 "b" }{TEXT 
371 21 " be two numbers with " }{TEXT 0 3 "a<b" }{TEXT 371 47 ". Here \+
is how we define the periodic extension " }{TEXT 0 1 "f" }{TEXT 371 4 
" of " }{TEXT 0 1 "g" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "f := proc(x)\n" }{MPLTEXT 1 0 11 "  local y;\n" }
{MPLTEXT 1 0 10 "  y := x;\n" }{MPLTEXT 1 0 35 "  while y >= b do y :=
 y-(b-a) od;\n" }{MPLTEXT 1 0 35 "  while y < a  do y := y+(b-a) od;\n
" }{MPLTEXT 1 0 8 "  g(y);\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0
 "" {TEXT 371 19 "This definition of " }{TEXT 0 1 "f" }{TEXT 371 15 " \+
works for any " }{TEXT 0 1 "g" }{TEXT 371 2 ", " }{TEXT 0 1 "a" }{TEXT
 371 5 " and " }{TEXT 0 1 "b" }{TEXT 371 25 ". Let us define specific 
" }{TEXT 0 1 "g" }{TEXT 371 2 ", " }{TEXT 0 1 "a" }{TEXT 371 6 ", and 
" }{TEXT 0 1 "b" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 14 "g := x -> x^2;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "a
 := -2; b:= 3; " }}}{PARA 0 "" 0 "" {TEXT 371 36 "Now graph the period
ic extension of " }{TEXT 0 1 "g" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 64 "plot( f, -7..18, scaling=constrained, discont=
true, color=red );" }}}{PARA 0 "" 0 "" {TEXT 371 44 "We should note he
re that if we try to graph " }{TEXT 0 1 "f" }{TEXT 371 48 " as an expr
ession, then we get an error message." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 69 "plot( f(x), x=-7..18, scaling=constrained, discont=tr
ue, color=red );" }}}{PARA 0 "" 0 "" {TEXT 371 48 "Similarly, if we tr
y to look at the formula for " }{TEXT 0 1 "f" }{TEXT 371 49 " as an ex
pression, we get the same error message." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 5 "f(x);" }}}{PARA 0 "" 0 "" {TEXT 371 90 "We will find o
ut how to fix this later in this worksheet. For now, here is a way to \+
graph " }{TEXT 0 1 "f" }{TEXT 371 40 " as an expression if you really \+
want to." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "plot('f(x)', x=-
7..18, scaling=constrained, discont=true, color=red);" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 301 8 "Exercise" }{TEXT 371 16 ": With the sam
e " }{TEXT 0 1 "g" }{TEXT 371 52 " as in the last example, try changin
g the values of " }{TEXT 0 1 "a" }{TEXT 371 5 " and " }{TEXT 0 1 "b" }
{TEXT 371 46 ". How does this change the periodic extension?" }}{PARA 
0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 302 8 "Exercise" }
{TEXT 371 60 ": Try defining periodic extensions for some other functi
ons " }{TEXT 0 1 "g" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 303 8 "Exercise" }{TEXT 371 22 ": How are we defining " }{TEXT 
0 8 "f(a+k*p)" }{TEXT 371 17 " for any integer " }{TEXT 0 1 "k" }{TEXT
 371 59 "? What other reasonable choices are there for the value of " 
}{TEXT 0 8 "f(a+k*p)" }{TEXT 371 1 "?" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 44 "Recall that a function f is even if for all " }{XPPEDIT 
18 0 "Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", math
variant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_
syslibGF'6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'
" }{TEXT 371 17 " it is true that " }{XPPEDIT 18 0 "Typesetting:-mrow(
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow
(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_
style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mro
w(Typesetting:-mi(\"f\", italic = \"true\", mathvariant = \"italic\"),
 Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence \+
= \"false\", separator = \"false\", stretchy = \"false\", symmetric = \+
\"false\", largeop = \"false\", movablelimits = \"false\", accent = \"
false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced
(Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable
 = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")
, Typesetting:-mrow(Typesetting:-mo(\"&uminus0;\", mathvariant = \"nor
mal\", fence = \"false\", separator = \"false\", stretchy = \"false\",
 symmetric = \"false\", largeop = \"false\", movablelimits = \"false\"
, accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em
\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\")), mathvarian
t = \"normal\")), Typesetting:-mo(\"=\", mathvariant = \"normal\", fen
ce = \"false\", separator = \"false\", stretchy = \"false\", symmetric
 = \"false\", largeop = \"false\", movablelimits = \"false\", accent =
 \"false\", lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Types
etting:-mrow(Typesetting:-mi(\"f\", italic = \"true\", mathvariant = \+
\"italic\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"norm
al\", fence = \"false\", separator = \"false\", stretchy = \"false\", \+
symmetric = \"false\", largeop = \"false\", movablelimits = \"false\",
 accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesett
ing:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true
\", mathvariant = \"italic\")), mathvariant = \"normal\")), Typesettin
g:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name \+
= \"2D Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", ital
ic = \"true\", executable = \"true\", font_style_name = \"2D Input\", \+
mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesetting
GI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font
_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6'F+-F#6%-F,6%Q\"f
F'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8Q'normalF'/%&fenceGQ&falseF'/%*s
eparatorGFI/%)stretchyGFI/%*symmetricGFI/%(largeopGFI/%.movablelimitsG
FI/%'accentGFI/%'lspaceGQ&0.0emF'/%'rspaceGFX-I(mfencedGF$6$-F#6%F+-F#
6$-FB6-Q*&uminus0;F'FEFGFJFLFNFPFRFT/FWQ,0.2222222emF'/FZF`o-F,6%Q\"xF
'F/F7F+FE-FB6-Q\"=F'FEFGFJFLFNFPFRFT/FWQ,0.2777778emF'/FZFio-F#6%F>FA-
Ffn6$-F#6#FboFEF+F+" }{TEXT 371 67 ". A function is even if its graph \+
is symmetric with respect to the " }{XPPEDIT 18 0 "Typesetting:-mrow(T
ypesetting:-mi(\"y\", italic = \"true\", mathvariant = \"italic\"));" 
"-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"y
F'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 48 "-axis. R
ecall that a function is odd if for all " }{XPPEDIT 18 0 "Typesetting:
-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic
\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF
$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 17 " \+
it is true that " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"
\", italic = \"true\", executable = \"true\", font_style_name = \"2D I
nput\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"f\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", sepa
rator = \"false\", stretchy = \"false\", symmetric = \"false\", largeo
p = \"false\", movablelimits = \"false\", accent = \"false\", lspace =
 \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mr
ow(Typesetting:-mo(\"&uminus0;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:
-mi(\"x\", italic = \"true\", mathvariant = \"italic\")), Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\")), mathvariant = \"normal\")), \+
Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"false\", se
parator = \"false\", stretchy = \"false\", symmetric = \"false\", larg
eop = \"false\", movablelimits = \"false\", accent = \"false\", lspace
 = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mrow(Types
etting:-mo(\"&uminus0;\", mathvariant = \"normal\", fence = \"false\",
 separator = \"false\", stretchy = \"false\", symmetric = \"false\", l
argeop = \"false\", movablelimits = \"false\", accent = \"false\", lsp
ace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Ty
pesetting:-mi(\"f\", italic = \"true\", mathvariant = \"italic\"), Typ
esetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typ
esetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant =
 \"italic\")), mathvariant = \"normal\")), Typesetting:-mi(\"\", itali
c = \"true\", executable = \"true\", font_style_name = \"2D Input\", m
athvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", ex
ecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"i
talic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"tru
e\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%
mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'i
talicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathva
riantGQ'italicF'-F#6'F+-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;
F'/F8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFI/%)stretchyGFI/%*symme
tricGFI/%(largeopGFI/%.movablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'
/%'rspaceGFX-I(mfencedGF$6$-F#6%F+-F#6$-FB6-Q*&uminus0;F'FEFGFJFLFNFPF
RFT/FWQ,0.2222222emF'/FZF`o-F,6%Q\"xF'F/F7F+FE-FB6-Q\"=F'FEFGFJFLFNFPF
RFT/FWQ,0.2777778emF'/FZFio-F#6%F\\o-F#6%F>FA-Ffn6$-F#6#FboFEF+F+F+" }
{TEXT 371 165 ". A function is odd if its graph is symmetric with resp
ect to the origin, meaning that if we rotate the graph of f by 180 deg
rees, then the graph remains unchanged. " }}{PARA 0 "" 0 "" {TEXT 371 
0 "" }}{PARA 0 "" 0 "" {TEXT 371 3 "If " }{XPPEDIT 18 0 "Typesetting:-
mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic
\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF
$6%Q\"bF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 91 " \+
is a positive number and we define the periodic extension of a functio
n g on the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-m
fenced(Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant = \"normal
\"), Typesetting:-mo(\",\", mathvariant = \"normal\", fence = \"false
\", separator = \"true\", stretchy = \"false\", symmetric = \"false\",
 largeop = \"false\", movablelimits = \"false\", accent = \"false\", l
space = \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-mi(\"b\", i
talic = \"true\", mathvariant = \"italic\")), mathvariant = \"normal\"
, open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,Typese
ttingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%,mathvariant
GQ'normalF'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/%*separatorGQ%trueF'/%
)stretchyGF=/%*symmetricGF=/%(largeopGF=/%.movablelimitsGF=/%'accentGF
=/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-I#miGF$6%Q\"bF'/%'italic
GF@/F5Q'italicF'F4/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 177 ", the
n the periodic extension will be an odd function for some g, an even f
unction for some other g, and neither even nor odd for most g. For exa
mple, the periodic extension of " }{XPPEDIT 18 0 "Typesetting:-mrow(Ty
pesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_sty
le_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(T
ypesetting:-mi(\"sin\", italic = \"false\", mathvariant = \"normal\"),
 Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence \+
= \"false\", separator = \"false\", stretchy = \"false\", symmetric = \+
\"false\", largeop = \"false\", movablelimits = \"false\", accent = \"
false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced
(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvaria
nt = \"italic\")), mathvariant = \"normal\")), Typesetting:-mi(\"\", i
talic = \"true\", executable = \"true\", font_style_name = \"2D Input
\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typeset
tingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0
font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q$sinF'
/F0Q&falseF'/F8Q'normalF'-I#moGF$6-Q0&ApplyFunction;F'FA/%&fenceGF@/%*
separatorGF@/%)stretchyGF@/%*symmetricGF@/%(largeopGF@/%.movablelimits
GF@/%'accentGF@/%'lspaceGQ&0.0emF'/%'rspaceGFW-I(mfencedGF$6$-F#6#-F,6
%Q\"xF'F/F7FAF+" }{TEXT 371 17 " on the interval " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mn(
\"0\", mathvariant = \"normal\"), Typesetting:-mo(\",\", mathvariant =
 \"normal\", fence = \"false\", separator = \"true\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em
\"), Typesetting:-mi(\"Pi\", italic = \"false\", mathvariant = \"norma
l\")), mathvariant = \"normal\", open = \"[\", close = \"]\"));" "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6
%-I#mnGF$6$Q\"0F'/%,mathvariantGQ'normalF'-I#moGF$6-Q\",F'F4/%&fenceGQ
&falseF'/%*separatorGQ%trueF'/%)stretchyGF=/%*symmetricGF=/%(largeopGF
=/%.movablelimitsGF=/%'accentGF=/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.33333
33emF'-I#miGF$6%Q#PiF'/%'italicGF=F4F4/%%openGQ\"[F'/%&closeGQ\"]F'" }
{TEXT 371 21 " is an even function." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "g := x -> sin(x);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "a:=0; b:=Pi;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 23 "plot( f, -3*Pi..3*Pi );" }}}{PARA 0 "" 0 "" {TEXT 371 30 "And th
e periodic extension of " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesettin
g:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name \+
= \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetti
ng:-mi(\"cos\", italic = \"false\", mathvariant = \"normal\"), Typeset
ting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"fals
e\", separator = \"false\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typese
tting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"
italic\")), mathvariant = \"normal\")), Typesetting:-mi(\"\", italic =
 \"true\", executable = \"true\", font_style_name = \"2D Input\", math
variant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_
syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_sty
le_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q$cosF'/F0Q&fal
seF'/F8Q'normalF'-I#moGF$6-Q0&ApplyFunction;F'FA/%&fenceGF@/%*separato
rGF@/%)stretchyGF@/%*symmetricGF@/%(largeopGF@/%.movablelimitsGF@/%'ac
centGF@/%'lspaceGQ&0.0emF'/%'rspaceGFW-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F
/F7FAF+" }{TEXT 371 17 " on the interval " }{XPPEDIT 18 0 "Typesetting
:-mrow(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mn(\"0\", m
athvariant = \"normal\"), Typesetting:-mo(\",\", mathvariant = \"norma
l\", fence = \"false\", separator = \"true\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Type
setting:-mi(\"Pi\", italic = \"false\", mathvariant = \"normal\")), ma
thvariant = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+
modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$
6$Q\"0F'/%,mathvariantGQ'normalF'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/
%*separatorGQ%trueF'/%)stretchyGF=/%*symmetricGF=/%(largeopGF=/%.movab
lelimitsGF=/%'accentGF=/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-I#
miGF$6%Q#PiF'/%'italicGF=F4F4/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 
371 20 " is an odd function." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
17 "g := x -> cos(x);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "a:
=0; b:=Pi;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "plot( f, -2*P
i..2*Pi );" }}}{PARA 0 "" 0 "" {TEXT 371 133 "There is a way to define
 a periodic extension so that it is always even or always odd, no matt
er what the function g on the interval " }{XPPEDIT 18 0 "Typesetting:-
mrow(Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mn(\"0\", mat
hvariant = \"normal\"), Typesetting:-mo(\",\", mathvariant = \"normal
\", fence = \"false\", separator = \"true\", stretchy = \"false\", sym
metric = \"false\", largeop = \"false\", movablelimits = \"false\", ac
cent = \"false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Types
etting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\")), mathv
ariant = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+mod
ulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q
\"0F'/%,mathvariantGQ'normalF'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/%*s
eparatorGQ%trueF'/%)stretchyGF=/%*symmetricGF=/%(largeopGF=/%.movablel
imitsGF=/%'accentGF=/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-I#miG
F$6%Q\"bF'/%'italicGF@/F5Q'italicF'F4/%%openGQ\"[F'/%&closeGQ\"]F'" }
{TEXT 371 174 " looks like. The following procedure defines the even p
eriodic extension of a function g on the interval from 0 to b. The eve
n extension defined by this procedure has period " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), T
ypesetting:-mrow(Typesetting:-mn(\"2\", mathvariant = \"normal\"), Typ
esetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \+
\"false\", separator = \"false\", stretchy = \"false\", symmetric = \"
false\", largeop = \"false\", movablelimits = \"false\", accent = \"fa
lse\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"b\",
 italic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", \+
italic = \"true\", executable = \"true\", font_style_name = \"2D Input
\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typeset
tingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0
font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q
\"2F'/F8Q'normalF'-I#moGF$6-Q1&InvisibleTimes;F'F@/%&fenceGQ&falseF'/%
*separatorGFH/%)stretchyGFH/%*symmetricGFH/%(largeopGFH/%.movablelimit
sGFH/%'accentGFH/%'lspaceGQ&0.0emF'/%'rspaceGFW-F,6%Q\"bF'F/F7F+" }
{TEXT 371 78 ". (Notice the use of an anonymous function in the last l
ine of the procedure.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "f_
even := proc(x)\n" }{MPLTEXT 1 0 11 "  local y;\n" }{MPLTEXT 1 0 10 " \+
 y := x;\n" }{MPLTEXT 1 0 33 "  while y >= b do y := y-2*b od;\n" }
{MPLTEXT 1 0 33 "  while y < -b do y := y+2*b od;\n" }{MPLTEXT 1 0 43 
"  ( z -> piecewise(z<0, g(-z), g(z)) )(y);\n" }{MPLTEXT 1 0 5 "end;\n
" }}}{PARA 0 "" 0 "" {TEXT 371 36 "The next procedure defines the odd,
 " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"
true\", executable = \"true\", font_style_name = \"2D Input\", mathvar
iant = \"italic\"), Typesetting:-mrow(Typesetting:-mn(\"2\", mathvaria
nt = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Ty
pesetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic\")), Ty
pesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_sty
le_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+mod
ulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF
'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'itali
cF'-F#6%-I#mnGF$6$Q\"2F'/F8Q'normalF'-I#moGF$6-Q1&InvisibleTimes;F'F@/
%&fenceGQ&falseF'/%*separatorGFH/%)stretchyGFH/%*symmetricGFH/%(largeo
pGFH/%.movablelimitsGFH/%'accentGFH/%'lspaceGQ&0.0emF'/%'rspaceGFW-F,6
%Q\"bF'F/F7F+" }{TEXT 371 62 " periodic extension of a function g on t
he interval from 0 to " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:
-mi(\"b\", italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG6#
/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'italic
GQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 1 "." }}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 17 "f_odd := proc(x)\n" }{MPLTEXT 1 0 11 "  loc
al y;\n" }{MPLTEXT 1 0 10 "  y := x;\n" }{MPLTEXT 1 0 33 "  while y >=
 b do y := y-2*b od;\n" }{MPLTEXT 1 0 33 "  while y < -b do y := y+2*b
 od;\n" }{MPLTEXT 1 0 44 "  ( z -> piecewise(z<0, -g(-z), g(z)) )(y);
\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 79 "Let us t
ry some examples using these two procedures. Here are the even and odd
 " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"
true\", executable = \"true\", font_style_name = \"2D Input\", mathvar
iant = \"italic\"), Typesetting:-mrow(Typesetting:-mn(\"2\", mathvaria
nt = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Ty
pesetting:-mi(\"Pi\", italic = \"false\", mathvariant = \"normal\")), \+
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+m
odulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%tru
eF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'ita
licF'-F#6%-I#mnGF$6$Q\"2F'/F8Q'normalF'-I#moGF$6-Q1&InvisibleTimes;F'F
@/%&fenceGQ&falseF'/%*separatorGFH/%)stretchyGFH/%*symmetricGFH/%(larg
eopGFH/%.movablelimitsGFH/%'accentGFH/%'lspaceGQ&0.0emF'/%'rspaceGFW-F
,6%Q#PiF'/F0FHF@F+" }{TEXT 371 24 " periodic extensions of " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"sin\", italic = \"
false\", mathvariant = \"normal\"), Typesetting:-mo(\"&ApplyFunction;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspac
e = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi
(\"x\", italic = \"true\", mathvariant = \"italic\")), mathvariant = \+
\"normal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"
true\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "
-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/
%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mat
hvariantGQ'italicF'-F#6%-F,6%Q$sinF'/F0Q&falseF'/F8Q'normalF'-I#moGF$6
-Q0&ApplyFunction;F'FA/%&fenceGF@/%*separatorGF@/%)stretchyGF@/%*symme
tricGF@/%(largeopGF@/%.movablelimitsGF@/%'accentGF@/%'lspaceGQ&0.0emF'
/%'rspaceGFW-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FAF+" }{TEXT 371 17 " o
n the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfence
d(Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant = \"normal\"), \+
Typesetting:-mo(\",\", mathvariant = \"normal\", fence = \"false\", se
parator = \"true\", stretchy = \"false\", symmetric = \"false\", large
op = \"false\", movablelimits = \"false\", accent = \"false\", lspace \+
= \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-mi(\"Pi\", italic
 = \"false\", mathvariant = \"normal\")), mathvariant = \"normal\", op
en = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesettin
gGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%,mathvariantGQ'n
ormalF'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/%*separatorGQ%trueF'/%)str
etchyGF=/%*symmetricGF=/%(largeopGF=/%.movablelimitsGF=/%'accentGF=/%'
lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-I#miGF$6%Q#PiF'/%'italicGF=F
4F4/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 1 "." }}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 9 "g := sin;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "b := Pi;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 28 
"plot( f_even, -3*Pi..3*Pi );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 28 "plot( f_odd,  -3*Pi..3*Pi );" }}}{PARA 0 "" 0 "" {TEXT 371 26 "H
ere are the even and odd " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetti
ng:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name
 = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesett
ing:-mn(\"2\", mathvariant = \"normal\"), Typesetting:-mo(\"&Invisible
Times;\", mathvariant = \"normal\", fence = \"false\", separator = \"f
alse\", stretchy = \"false\", symmetric = \"false\", largeop = \"false
\", movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\",
 rspace = \"0.0em\"), Typesetting:-mi(\"Pi\", italic = \"false\", math
variant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", execu
table = \"true\", font_style_name = \"2D Input\", mathvariant = \"ital
ic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#mi
GF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~Inp
utF'/%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"2F'/F8Q'normalF'-I#moGF
$6-Q1&InvisibleTimes;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%)stretchyG
FH/%*symmetricGFH/%(largeopGFH/%.movablelimitsGFH/%'accentGFH/%'lspace
GQ&0.0emF'/%'rspaceGFW-F,6%Q#PiF'/F0FHF@F+" }{TEXT 371 24 " periodic e
xtensions of " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\",
 italic = \"true\", executable = \"true\", font_style_name = \"2D Inpu
t\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"co
s\", italic = \"false\", mathvariant = \"normal\"), Typesetting:-mo(\"
&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow
(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")),
 mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", \+
executable = \"true\", font_style_name = \"2D Input\", mathvariant = \+
\"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6
%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)
2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q$cosF'/F0Q&falseF'/F8Q'n
ormalF'-I#moGF$6-Q0&ApplyFunction;F'FA/%&fenceGF@/%*separatorGF@/%)str
etchyGF@/%*symmetricGF@/%(largeopGF@/%.movablelimitsGF@/%'accentGF@/%'
lspaceGQ&0.0emF'/%'rspaceGFW-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FAF+" }
{TEXT 371 17 " on the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typ
esetting:-mfenced(Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant
 = \"normal\"), Typesetting:-mo(\",\", mathvariant = \"normal\", fence
 = \"false\", separator = \"true\", stretchy = \"false\", symmetric = \+
\"false\", largeop = \"false\", movablelimits = \"false\", accent = \"
false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-m
i(\"Pi\", italic = \"false\", mathvariant = \"normal\")), mathvariant \+
= \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulename
G6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%
,mathvariantGQ'normalF'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/%*separato
rGQ%trueF'/%)stretchyGF=/%*symmetricGF=/%(largeopGF=/%.movablelimitsGF
=/%'accentGF=/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-I#miGF$6%Q#P
iF'/%'italicGF=F4F4/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "g := cos;" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 8 "b := Pi;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "plot( f_even, -3*Pi..3*Pi );" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 28 "plot( f_odd,  -3*Pi..3*Pi );" }}}{PARA 0 "" 0 ""
 {TEXT 371 34 "Let us try the identity function, " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), T
ypesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable =
 \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), \+
Typesetting:-mrow(Typesetting:-mi(\"g\", italic = \"true\", mathvarian
t = \"italic\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"
normal\", fence = \"false\", separator = \"false\", stretchy = \"false
\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fals
e\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Type
setting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"t
rue\", mathvariant = \"italic\")), mathvariant = \"normal\")), Typeset
ting:-mo(\"=\", mathvariant = \"normal\", fence = \"false\", separator
 = \"false\", stretchy = \"false\", symmetric = \"false\", largeop = \+
\"false\", movablelimits = \"false\", accent = \"false\", lspace = \"0
.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mi(\"x\", italic
 = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic \+
= \"true\", executable = \"true\", font_style_name = \"2D Input\", mat
hvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(
_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_st
yle_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6&F+-F#6%-F,6%Q\"gF'F
/F7-I#moGF$6-Q0&ApplyFunction;F'/F8Q'normalF'/%&fenceGQ&falseF'/%*sepa
ratorGFI/%)stretchyGFI/%*symmetricGFI/%(largeopGFI/%.movablelimitsGFI/
%'accentGFI/%'lspaceGQ&0.0emF'/%'rspaceGFX-I(mfencedGF$6$-F#6#-F,6%Q\"
xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRFT/FWQ,0.2777778emF'/FZFaoFjnF+" }
{TEXT 371 17 " on the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typ
esetting:-mfenced(Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant
 = \"normal\"), Typesetting:-mo(\",\", mathvariant = \"normal\", fence
 = \"false\", separator = \"true\", stretchy = \"false\", symmetric = \+
\"false\", largeop = \"false\", movablelimits = \"false\", accent = \"
false\", lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-m
n(\"1\", mathvariant = \"normal\")), mathvariant = \"normal\", open = \+
\"[\", close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_
syslibGF'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%,mathvariantGQ'normal
F'-I#moGF$6-Q\",F'F4/%&fenceGQ&falseF'/%*separatorGQ%trueF'/%)stretchy
GF=/%*symmetricGF=/%(largeopGF=/%.movablelimitsGF=/%'accentGF=/%'lspac
eGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-F16$Q\"1F'F4F4/%%openGQ\"[F'/%&cl
oseGQ\"]F'" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "g := x -> x;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "b := 1;"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "plot( f_even, -3..3 );" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "plot( f_odd,  -3..3 );" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "plot( f, -3..3 );" }}}
{PARA 0 "" 0 "" {TEXT 371 63 "Let us try a non symmetric piece of a pa
rabola on the interval " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting
:-mfenced(Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant = \"nor
mal\"), Typesetting:-mo(\",\", mathvariant = \"normal\", fence = \"fal
se\", separator = \"true\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.0em\", rspace = \"0.3333333em\"), Typesetting:-mn(\"1\"
, mathvariant = \"normal\")), mathvariant = \"normal\", open = \"[\", \+
close = \"]\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibG
F'6#-I(mfencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%,mathvariantGQ'normalF'-I#mo
GF$6-Q\",F'F4/%&fenceGQ&falseF'/%*separatorGQ%trueF'/%)stretchyGF=/%*s
ymmetricGF=/%(largeopGF=/%.movablelimitsGF=/%'accentGF=/%'lspaceGQ&0.0
emF'/%'rspaceGQ,0.3333333emF'-F16$Q\"1F'F4F4/%%openGQ\"[F'/%&closeGQ\"
]F'" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "g :=
 x -> (x-1/4)^2;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "b := 1;"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "plot( f_even, -3..3 );" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "plot( f_odd,  -3..3, disc
ont=true, color=red );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "p
lot( f, -3..3, discont=true, color=red );" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 ""
 {TEXT 304 8 "Exercise" }{TEXT 371 73 ": Try defining even and odd per
iodic extensions for some other functions " }{TEXT 0 1 "g" }{TEXT 371 
1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 305 8 "Exercise" }{TEXT 371 49 
": Part (a) Under what conditions on the function " }{TEXT 0 1 "g" }
{TEXT 371 19 " will the function " }{TEXT 0 5 "f_odd" }{TEXT 371 24 " \+
be continuous at 0 and " }{TEXT 0 1 "b" }{TEXT 371 40 "? Under what co
nditions on the function " }{TEXT 0 1 "g" }{TEXT 371 19 " will the fun
ction " }{TEXT 0 6 "f_even" }{TEXT 371 24 " be continuous at 0 and " }
{TEXT 0 1 "b" }{TEXT 371 1 "?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 47 "Part (b) Under what conditions
 on the function " }{TEXT 0 1 "g" }{TEXT 371 20 " will the functions "
 }{TEXT 0 5 "f_odd" }{TEXT 371 5 " and " }{TEXT 0 1 "f" }{TEXT 371 29 
" be the same function (where " }{TEXT 0 1 "f" }{TEXT 371 8 " is the "
 }{TEXT 0 1 "b" }{TEXT 371 23 " periodic extension of " }{TEXT 0 1 "g"
 }{TEXT 371 27 " on the interval from 0 to " }{TEXT 0 1 "b" }{TEXT 
371 41 "). Under what conditions on the function " }{TEXT 0 1 "g" }
{TEXT 371 20 " will the functions " }{TEXT 0 6 "f_even" }{TEXT 371 5 "
 and " }{TEXT 0 1 "f" }{TEXT 371 22 " be the same function." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 371 52 "Here is an interesting example that us
es a parabola." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "g := x -> \+
4*x*(1-x);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "b := 1;" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "plot( f_odd, -4..4 );" }}}
{PARA 0 "" 0 "" {TEXT 371 54 "Let us compare this periodic function to
 a sine curve." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "plot( [ f_
odd, x->sin(Pi*x) ], -2..2 );" }}}{PARA 0 "" 0 "" {TEXT 371 118 "Notic
e how amazingly similar the two functions are. The following parametri
c graph uses the odd periodic extension of " }{TEXT 0 1 "g" }{TEXT 
371 27 ". Which is the real circle?" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "plot( [ [f_odd, t->f_odd(t-1/2), 0..2],\n" }{MPLTEXT 
1 0 32 "        [cos, sin, 0..2*Pi] ], \n" }{MPLTEXT 1 0 29 "      sca
ling=constrained );\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 306 8 "Exerci
se" }{TEXT 371 44 ": Given a function g defined on an interval " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mn(\"0\", mathvariant = \"normal\"), Typesetting:-mo(\"
,\", mathvariant = \"normal\", fence = \"false\", separator = \"true\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspac
e = \"0.3333333em\"), Typesetting:-mi(\"b\", italic = \"true\", mathva
riant = \"italic\")), mathvariant = \"normal\", open = \"[\", close = \+
\"]\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(m
fencedGF$6&-F#6%-I#mnGF$6$Q\"0F'/%,mathvariantGQ'normalF'-I#moGF$6-Q\"
,F'F4/%&fenceGQ&falseF'/%*separatorGQ%trueF'/%)stretchyGF=/%*symmetric
GF=/%(largeopGF=/%.movablelimitsGF=/%'accentGF=/%'lspaceGQ&0.0emF'/%'r
spaceGQ,0.3333333emF'-I#miGF$6%Q\"bF'/%'italicGF@/F5Q'italicF'F4/%%ope
nGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 20 ", write a procedure " }{TEXT 
0 9 "f_oddeven" }{TEXT 371 16 " that defines a " }{XPPEDIT 18 0 "Types
etting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"t
rue\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Type
setting:-mrow(Typesetting:-mn(\"4\", mathvariant = \"normal\"), Typese
tting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \"fa
lse\", separator = \"false\", stretchy = \"false\", symmetric = \"fals
e\", largeop = \"false\", movablelimits = \"false\", accent = \"false
\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"b\", it
alic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", ita
lic = \"true\", executable = \"true\", font_style_name = \"2D Input\",
 mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,Typesettin
gGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0fon
t_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"4F
'/F8Q'normalF'-I#moGF$6-Q1&InvisibleTimes;F'F@/%&fenceGQ&falseF'/%*sep
aratorGFH/%)stretchyGFH/%*symmetricGFH/%(largeopGFH/%.movablelimitsGFH
/%'accentGFH/%'lspaceGQ&0.0emF'/%'rspaceGFW-F,6%Q\"bF'F/F7F+" }{TEXT 
371 103 " periodic extension of g that is odd and such that the horizo
ntal shift of the extension by the amount " }{XPPEDIT 18 0 "Typesettin
g:-mrow(Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"ital
ic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#mi
GF$6%Q\"bF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 39 
" is even. Similarly, write a procedure " }{TEXT 0 9 "f_evenodd" }
{TEXT 371 16 " that defines a " }{XPPEDIT 18 0 "Typesetting:-mrow(Type
setting:-mi(\"\", italic = \"true\", executable = \"true\", font_style
_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typ
esetting:-mn(\"4\", mathvariant = \"normal\"), Typesetting:-mo(\"&Invi
sibleTimes;\", mathvariant = \"normal\", fence = \"false\", separator \+
= \"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"
false\", movablelimits = \"false\", accent = \"false\", lspace = \"0.0
em\", rspace = \"0.0em\"), Typesetting:-mi(\"b\", italic = \"true\", m
athvariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", ex
ecutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"i
talic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I
#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~
InputF'/%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"4F'/F8Q'normalF'-I#m
oGF$6-Q1&InvisibleTimes;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%)stretc
hyGFH/%*symmetricGFH/%(largeopGFH/%.movablelimitsGFH/%'accentGFH/%'lsp
aceGQ&0.0emF'/%'rspaceGFW-F,6%Q\"bF'F/F7F+" }{TEXT 371 104 " periodic \+
extension of g that is even and such that the horizontal shift of the \+
extension by the amount " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesettin
g:-mi(\"b\", italic = \"true\", mathvariant = \"italic\"));" "-I%mrowG
6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I#miGF$6%Q\"bF'/%'ital
icGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT 371 29 " is odd. (Hint: T
hink of how " }{TEXT 0 3 "sin" }{TEXT 371 38 " is built up from just o
ne quarter of " }{TEXT 0 3 "sin" }{TEXT 371 24 "'s graph, the part fro
m " }{TEXT 0 1 "0" }{TEXT 371 4 " to " }{TEXT 0 4 "Pi/2" }{TEXT 371 
24 ", and then think of how " }{TEXT 0 3 "cos" }{TEXT 371 38 " is buil
t up from just one quarter of " }{TEXT 0 3 "cos" }{TEXT 371 10 "'s gra
ph.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 307 8 "Exercise" }{TEXT 371 64 
": Make up your own periodic function by extending some function " }
{TEXT 0 1 "g" }{TEXT 371 241 ", and then use your periodic function in
 place of the trig functions sin and cos in several parametric curves \+
and surfaces like cardiods, spirals, lemniscates, roses, sphere, torus
, etc. Try to come up with a really unusual curve or surface." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 1 
{PARA 5 "" 0 "" {TEXT 372 33 "17.3.4. Example 4: Drawing graphs" }}
{PARA 0 "" 0 "" {TEXT 371 218 "Our fourth example uses a for-loop and \+
a list data structure to draw a graph. Each iterate of the for-loop wi
ll compute the coordinates of a point and put the point in a list of p
oints that are to be plotted. Then the " }{TEXT 0 4 "plot" }{TEXT 371 
223 " command will be used to draw a graph of all the points in the li
st. This is a fairly common way to create a graph in Maple and, as we \+
showed in an earlier worksheet, this is fundamentally how all graphs a
re drawn in Maple." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 ""
 {TEXT 371 89 "The following for-loop computes 9 equally spaced sample
 points in the interval from 0 to " }{XPPEDIT 18 0 "Typesetting:-mrow(
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow
(Typesetting:-mn(\"2\", mathvariant = \"normal\"), Typesetting:-mo(\"&
InvisibleTimes;\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"Pi\", italic = \"fal
se\", mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \"tru
e\", executable = \"true\", font_style_name = \"2D Input\", mathvarian
t = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslib
GF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nam
eGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"2F'/F8Q'norma
lF'-I#moGF$6-Q1&InvisibleTimes;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%
)stretchyGFH/%*symmetricGFH/%(largeopGFH/%.movablelimitsGFH/%'accentGF
H/%'lspaceGQ&0.0emF'/%'rspaceGFW-F,6%Q#PiF'/F0FHF@F+" }{TEXT 371 68 ".
 Each iterate of the loop computes one sample point, evaluates the " }
{TEXT 0 3 "sin" }{TEXT 371 94 " function at the sample point, and puts
 the ordered pair of the sample point and the value of " }{TEXT 0 3 "s
in" }{TEXT 371 20 " into a list called " }{TEXT 0 4 "data" }{TEXT 371 
11 ". Then the " }{TEXT 0 4 "plot" }{TEXT 371 35 " command is used to \+
graph the list " }{TEXT 0 4 "data" }{TEXT 371 28 ", and we get a graph
 of the " }{TEXT 0 3 "sin" }{TEXT 371 23 " function. Notice that " }
{TEXT 0 4 "data" }{TEXT 371 31 " starts off as the empty list, " }
{TEXT 0 2 "[]" }{TEXT 371 24 ", and as each new point " }{TEXT 0 10 "[
x,sin(x)]" }{TEXT 371 66 " is computed, it is put into the list using \+
a command of the form " }{TEXT 0 27 "data:=[op(data),[x,sin(x)]]" }
{TEXT 371 60 ". Notice how this is very much like computing a running \+
sum " }{TEXT 0 1 "s" }{TEXT 371 26 ", where we start off with " }{TEXT
 0 1 "s" }{TEXT 371 123 " equal to the \"empty\" sum, 0, and then as e
ach new term in the sum is computed it is added to the sum using a com
mand like " }{TEXT 0 14 "s:=s+something" }{TEXT 371 1 "." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "N := 8;" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 10 "b := 2*Pi;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 11 "data := [];" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "for n \+
from 0 to N do \n" }{MPLTEXT 1 0 45 "  data := [ op(data), [n*b/N, sin
(n*b/N)] ];\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 
362 "Notice that the output from the for-loop is in symbolic form. Sin
ce we are going to just plot the contents of the list, we do not need \+
exact symbolic results. So let us modify the for-loop so that it compu
tes with decimal numbers. When working with loops that might create th
ousands of points, this could help speed things up. (If we want, we co
uld even use the " }{TEXT 0 6 "evalhf" }{TEXT 371 91 " command and har
dware floating points for even more speed.) First, we need to reinitia
lize " }{TEXT 0 4 "list" }{TEXT 371 28 " to be the empty list again." 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "data := [];\n" }{MPLTEXT 
1 0 21 "for n from 0 to N do\n" }{MPLTEXT 1 0 59 "  data := [ op(data)
, [evalf(n*b/N), sin(evalf(n*b/N))] ];\n" }{MPLTEXT 1 0 4 "od;\n" }}}
{PARA 0 "" 0 "" {TEXT 371 8 "Now use " }{TEXT 0 4 "plot" }{TEXT 371 
19 " to graph the list " }{TEXT 0 4 "data" }{TEXT 371 1 "." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "plot( data );" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 
"" 0 "" {TEXT 308 8 "Exercise" }{TEXT 371 63 ": Modify the above examp
le so that it can be used to graph the " }{TEXT 0 3 "sin" }{TEXT 371 
33 " function over any interval from " }{TEXT 0 1 "a" }{TEXT 371 4 " t
o " }{TEXT 0 1 "b" }{TEXT 371 145 ". (You should suppress the output f
rom the for-loop in your example, so that you do not fill up the works
heet with an unwieldy amount of output.)" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 309 8 "Exercise" }{TEXT 371 118 ": Modify the above example so t
hat it is easy to change the function that is being graphed. Try graph
ing the function " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"\", italic = \"true\", executable = \"true\", font_style_name = \"2
D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-m
i(\"f\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo
(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", sep
arator = \"false\", stretchy = \"false\", symmetric = \"false\", large
op = \"false\", movablelimits = \"false\", accent = \"false\", lspace \+
= \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mr
ow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")
), mathvariant = \"normal\")), Typesetting:-mo(\"=\", mathvariant = \"
normal\", fence = \"false\", separator = \"false\", stretchy = \"false
\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fals
e\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.277777
8em\"), Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", exe
cutable = \"true\", font_style_name = \"2D Input\", mathvariant = \"it
alic\"), Typesetting:-mrow(Typesetting:-mn(\"3\", mathvariant = \"norm
al\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\",
 fence = \"false\", separator = \"false\", stretchy = \"false\", symme
tric = \"false\", largeop = \"false\", movablelimits = \"false\", acce
nt = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-
mrow(Typesetting:-msup(Typesetting:-mi(\"x\", italic = \"true\", mathv
ariant = \"italic\"), Typesetting:-mn(\"2\", mathvariant = \"normal\")
, superscriptshift = \"0\")), Typesetting:-mi(\"\", italic = \"true\",
 executable = \"true\", font_style_name = \"2D Input\", mathvariant = \+
\"italic\")), Typesetting:-mo(\"&minus;\", mathvariant = \"normal\", f
ence = \"false\", separator = \"false\", stretchy = \"false\", symmetr
ic = \"false\", largeop = \"false\", movablelimits = \"false\", accent
 = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typ
esetting:-mrow(Typesetting:-mn(\"2\", mathvariant = \"normal\"), Types
etting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \"f
alse\", separator = \"false\", stretchy = \"false\", symmetric = \"fal
se\", largeop = \"false\", movablelimits = \"false\", accent = \"false
\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"x\", it
alic = \"true\", mathvariant = \"italic\")), Typesetting:-mo(\"&minus;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em\",
 rspace = \"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant = \"nor
mal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\")), Typese
tting:-mi(\"\", italic = \"true\", executable = \"true\", font_style_n
ame = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+
executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-
F#6'F+-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8Q'normalF'/%
&fenceGQ&falseF'/%*separatorGFI/%)stretchyGFI/%*symmetricGFI/%(largeop
GFI/%.movablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'/%'rspaceGFX-I(mf
encedGF$6$-F#6#-F,6%Q\"xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRFT/FWQ,0.2777
778emF'/FZFao-F#6(F+-F#6&-I#mnGF$6$Q\"3F'FE-FB6-Q1&InvisibleTimes;F'FE
FGFJFLFNFPFRFTFVFY-F#6#-I%msupGF$6%Fjn-Fho6$Q\"2F'FE/%1superscriptshif
tGQ\"0F'F+-FB6-Q(&minus;F'FEFGFJFLFNFPFRFT/FWQ,0.2222222emF'/FZF]q-F#6
%FcpF[pFjnFip-Fho6$Q\"1F'FEF+F+" }{TEXT 371 19 " over the interval " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font
_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mr
ow(Typesetting:-mo(\"&uminus0;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:
-mn(\"2\", mathvariant = \"normal\")), Typesetting:-mo(\",\", mathvari
ant = \"normal\", fence = \"false\", separator = \"true\", stretchy = \+
\"false\", symmetric = \"false\", largeop = \"false\", movablelimits =
 \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.33333
33em\"), Typesetting:-mn(\"3\", mathvariant = \"normal\")), mathvarian
t = \"normal\", open = \"[\", close = \"]\"));" "-I%mrowG6#/I+modulena
meG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6&-I#miGF$6'Q!F'/%
'italicGQ%trueF'/%+executableGF6/%0font_style_nameGQ)2D~InputF'/%,math
variantGQ'italicF'-F#6$-I#moGF$6-Q*&uminus0;F'/F=Q'normalF'/%&fenceGQ&
falseF'/%*separatorGFI/%)stretchyGFI/%*symmetricGFI/%(largeopGFI/%.mov
ablelimitsGFI/%'accentGFI/%'lspaceGQ,0.2222222emF'/%'rspaceGFX-I#mnGF$
6$Q\"2F'FE-FB6-Q\",F'FEFG/FKF6FLFNFPFRFT/FWQ&0.0emF'/FZQ,0.3333333emF'
-Ffn6$Q\"3F'FEFE/%%openGQ\"[F'/%&closeGQ\"]F'" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 310 8 "Exercise" }{TEXT 371 69 ": Con
sider the following three execution groups. Each one graphs the " }
{TEXT 0 3 "sin" }{TEXT 371 77 " function and each one uses a slight va
riation on the last for-loop. Suppose " }{TEXT 0 1 "N" }{TEXT 371 148 
" is a very large number. How do you think these three execution group
s would compare, in terms of speed, with the last for-loop and with ea
ch other?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "N := 8;\n" }
{MPLTEXT 1 0 11 "b := 2*Pi;\n" }{MPLTEXT 1 0 12 "data := []:\n" }
{MPLTEXT 1 0 22 "for n from 0 to N do \n" }{MPLTEXT 1 0 59 "  data := \+
[ op(data), [evalf(n*b/N), evalf(sin(n*b/N))] ];\n" }{MPLTEXT 1 0 4 "o
d:\n" }{MPLTEXT 1 0 14 "plot( data );\n" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "N := 8;
\n" }{MPLTEXT 1 0 11 "b := 2*Pi;\n" }{MPLTEXT 1 0 12 "data := []:\n" }
{MPLTEXT 1 0 10 "n := 'n':\n" }{MPLTEXT 1 0 21 "x := evalf( n*b/N );\n
" }{MPLTEXT 1 0 22 "for n from 0 to N do \n" }{MPLTEXT 1 0 37 "  data \+
:= [ op(data), [x, sin(x)] ];\n" }{MPLTEXT 1 0 4 "od:\n" }{MPLTEXT 1 
0 14 "plot( data );\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "N := 8;\n" }{MPLTEXT 1 0 
11 "b := 2*Pi;\n" }{MPLTEXT 1 0 12 "data := []:\n" }{MPLTEXT 1 0 10 "n
 := 'n':\n" }{MPLTEXT 1 0 19 "x := evalf( b/N );\n" }{MPLTEXT 1 0 22 "
for n from 0 to N do \n" }{MPLTEXT 1 0 12 "  p := n*x;\n" }{MPLTEXT 1 
0 37 "  data := [ op(data), [p, sin(p)] ];\n" }{MPLTEXT 1 0 4 "od:\n" 
}{MPLTEXT 1 0 14 "plot( data );\n" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 136 "The following for-loop computes five equally space poin
ts on the circumference of the unit circle and puts these point in a l
ist called " }{TEXT 0 4 "data" }{TEXT 371 25 ". Notice that once again
 " }{TEXT 0 4 "data" }{TEXT 371 31 " starts off as the empty list, " }
{TEXT 0 2 "[]" }{TEXT 371 24 ", and as each new point " }{TEXT 0 5 "[x
,y]" }{TEXT 371 65 " is computed it is put into the list using a comma
nd of the form " }{TEXT 0 22 "data:=[op(data),[x,y]]" }{TEXT 371 1 "."
 }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "N := 5;\n" }{MPLTEXT 1 0 
12 "data := [];\n" }{MPLTEXT 1 0 21 "for n from 0 to N do\n" }{MPLTEXT
 1 0 70 "  data := [ op(data), [cos(evalf(n*2*Pi/N)), sin(evalf(n*2*Pi
/N))] ];\n" }{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 93 "N
otice how the list of points grew by one point with each iteration of \+
the loop. Now use the " }{TEXT 0 4 "plot" }{TEXT 371 26 " command to p
lot the list." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "plot( data,
 style=point, scaling=constrained );" }}}{PARA 0 "" 0 "" {TEXT 371 43 
"Now plot it with lines connecting the dots." }}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 46 "plot( data, style=line, scaling=constrained );" }}
}{PARA 0 "" 0 "" {TEXT 371 38 "In the next for-loop we use the names "
 }{TEXT 0 1 "x" }{TEXT 371 5 " and " }{TEXT 0 1 "y" }{TEXT 371 344 " t
o represent the calculation of the coordinates of each of the points. \+
Convince yourself that the next execution group does exactly the same \+
calculation as the previous execution group. The reason for rewriting \+
it like this is to try and make the execution group easier to read. (A
nd this time we are suppressing the output from the for-loop.)" }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "N := 5;\n" }{MPLTEXT 1 0 12 "
data := [];\n" }{MPLTEXT 1 0 42 "n := 'n';  # be sure that n is unassi
gned\n" }{MPLTEXT 1 0 28 "theta := evalf( n*2*Pi/N );\n" }{MPLTEXT 1 
0 17 "x := cos(theta);\n" }{MPLTEXT 1 0 17 "y := sin(theta);\n" }
{MPLTEXT 1 0 21 "for n from 0 to N do\n" }{MPLTEXT 1 0 33 "   data := \+
[ op(data), [x, y] ];\n" }{MPLTEXT 1 0 4 "od:\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 66 "Plot the points again, to verify that it was the same ca
lculation." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "plot( data, st
yle=line, scaling=constrained );" }}}{PARA 0 "" 0 "" {TEXT 371 64 "Now
 go back to the last execution group and change the value of " }{TEXT 
0 1 "N" }{TEXT 371 148 " from 5 to 7 or 9. The execution group will pl
ot 7 or 9 equally spaced points on the circumference of the unit circl
e. Try any positive integer for " }{TEXT 0 1 "N" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 270 "Here is a variation on this \+
example. The next execution group plots 5 equally spaced points on the
 circumference of the unit circle, but they are not computed in sequen
tial order around the circle. Try to figure out exactly what this vers
ion computes and how it does it." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 8 "N := 5;\n" }{MPLTEXT 1 0 8 "J := 2;\n" }{MPLTEXT 1 0 12 "data :
= []:\n" }{MPLTEXT 1 0 10 "n := 'n':\n" }{MPLTEXT 1 0 19 "theta := J*2
*Pi/N;\n" }{MPLTEXT 1 0 19 "x := cos(n*theta);\n" }{MPLTEXT 1 0 19 "y \+
:= sin(n*theta);\n" }{MPLTEXT 1 0 21 "for n from 0 to N do\n" }
{MPLTEXT 1 0 33 "   data := [ op(data), [x, y] ];\n" }{MPLTEXT 1 0 4 "
od:\n" }{MPLTEXT 1 0 47 "plot( data, style=line, scaling=constrained )
;\n" }}}{PARA 0 "" 0 "" {TEXT 371 13 "Try changing " }{TEXT 0 1 "N" }
{TEXT 371 10 " to 7 and " }{TEXT 0 1 "J" }{TEXT 371 40 " to 3. Try sev
eral different values for " }{TEXT 0 1 "N" }{TEXT 371 5 " and " }{TEXT
 0 1 "J" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 311 8 "Exer
cise" }{TEXT 371 100 ": Convert the last execution group into a proced
ure that takes two positive integer parameters, the " }{TEXT 0 1 "N" }
{TEXT 371 5 " and " }{TEXT 0 1 "J" }{TEXT 371 104 ", and draws the app
ropriate graph. This will make it a lot easier to try out different pa
rameter values." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 71 "One mor
e variation on this example. This version has three parameters, " }
{TEXT 0 1 "N" }{TEXT 371 2 ", " }{TEXT 0 1 "J" }{TEXT 371 6 ", and " }
{TEXT 0 1 "K" }{TEXT 371 177 ". Try to figure out exactly what this ex
ecution group is doing. (Hint: It does pretty much the same thing as t
he previous version, but it does it twice per iterate of the loop.)" }
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "N, J, K := 36, 21, 9;\n" }
{MPLTEXT 1 0 12 "data := []:\n" }{MPLTEXT 1 0 10 "n := 'n':\n" }
{MPLTEXT 1 0 20 "theta1 := J*2*Pi/N;\n" }{MPLTEXT 1 0 20 "theta2 := K*
2*Pi/N;\n" }{MPLTEXT 1 0 34 "x1, y1 := cos(n*(theta1+theta2)),\n" }
{MPLTEXT 1 0 34 "          sin(n*(theta1+theta2));\n" }{MPLTEXT 1 0 
41 "x2, y2 := cos(n*(theta1+theta2)+theta1),\n" }{MPLTEXT 1 0 41 "    \+
      sin(n*(theta1+theta2)+theta1);\n" }{MPLTEXT 1 0 21 "for n from 0
 to N do\n" }{MPLTEXT 1 0 45 "   data := [ op(data), [x1, y1], [x2, y2
] ];\n" }{MPLTEXT 1 0 4 "od:\n" }{MPLTEXT 1 0 58 "plot( data, style=li
ne, scaling=constrained, axes=none );\n" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 40 "Here are some value
s for the parameters " }{TEXT 0 1 "N" }{TEXT 371 2 ", " }{TEXT 0 1 "J"
 }{TEXT 371 5 " and " }{TEXT 0 1 "K" }{TEXT 371 26 " that produce nice
 graphs." }}{PARA 0 "" 0 "" {TEXT 371 9 "15, 8, 13" }}{PARA 0 "" 0 "" 
{TEXT 371 8 "28,19,15" }}{PARA 0 "" 0 "" {TEXT 371 8 "39,33,27" }}
{PARA 0 "" 0 "" {TEXT 371 8 "19,13,11" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 312 9 "Exercise:" }{TEXT 371 194 " Part (a) Convert the last exe
cution group into a procedure that has three positive integer paramete
rs and draws the appropriate graph. Call your procedure with a number \+
of different parameters." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{PARA 0 "" 0 "" {TEXT 371 191 "Part (b): Convert your procedure fr
om Part(a) into a procedure that takes no input parameters and generat
es the three integers it needs randomly. Your procedure should use the
 Maple function " }{TEXT 0 4 "rand" }{TEXT 371 49 " to generate the ra
ndom integers (the expression " }{TEXT 0 12 "rand(a..b)()" }{TEXT 371 
7 " (with " }{TEXT 313 4 "both" }{TEXT 371 58 " sets of parentheses)  \+
generates a random integer between " }{TEXT 0 1 "a" }{TEXT 371 5 " and
 " }{TEXT 0 1 "b" }{TEXT 371 180 "). The procedure should print out th
e values of the randomly chosen integers and draw the appropriate grap
h. Run this procedure many times. You should get some very elegant gra
phs." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 
1 {PARA 5 "" 0 "" {TEXT 372 34 "17.3.5. Example 5: Butterfly curve" }}
{PARA 0 "" 0 "" {TEXT 371 128 "Our fifth example uses a for-loop and a
 data structure (a list) to draw a fairly complex graph, a version of \+
a butterfly curve. " }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "
" {TEXT 371 275 "The curve we will draw is not in fact a curve. Instea
d we will be plotting points, thousands of points, and not connecting \+
them together with line segments. The points we will be plotting will \+
be computed by a for-loop and placed in a list (as in the last example
). Then the " }{TEXT 0 4 "plot" }{TEXT 371 233 " command will be used \+
to draw a graph of all the points in the list (without connecting them
 together with line segments). Almost all of the work in this example \+
is in computing the coordinates of all the points that we want to plot
." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 291 "T
he loop in this example is fairly computationally intensive. You shoul
d save all of your work before executing it, in case it takes too long
 for it to compute on your computer (do not try this on a Pentium, use
 at least a Pentium II).  If your computer is really fast, you can try
 changing " }{TEXT 0 1 "N" }{TEXT 371 5 ". Try" }{TEXT 0 9 " N:=21000"
 }{TEXT 371 5 ", or " }{TEXT 0 8 "N:=41900" }{TEXT 371 64 " (which sho
uld run for a pretty long time). Different values of " }{TEXT 0 1 "N" 
}{TEXT 371 33 " give different butterfly curves." }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 64 "r := phi -> ( exp(cos(phi))-2*cos(4*phi) )*sin
(99999999*phi)^4;\n" }{MPLTEXT 1 0 61 "N := 11500;                   #
 Number of points to compute.\n" }{MPLTEXT 1 0 58 "h := evalf(2*Pi/N);
           # Step size between points.\n" }{MPLTEXT 1 0 49 "n := 'n'; \+
                    # Just to be safe.\n" }{MPLTEXT 1 0 64 "x := r(n*h
)*sin(n*h);         # x-coord of a point on the curve\n" }{MPLTEXT 1 
0 64 "y := r(n*h)*cos(n*h);         # y-coord of a point on the curve
\n" }{MPLTEXT 1 0 58 "data := [];                   # Start with an em
pty list.\n" }{MPLTEXT 1 0 69 "for n from 1 to N do          # This do
-loop computes the butterfly.\n" }{MPLTEXT 1 0 52 "   data := [ op(dat
a), [evalhf( x ), evalhf( y )] ]\n" }{MPLTEXT 1 0 4 "od:\n" }}}{PARA 0
 "" 0 "" {TEXT 371 62 "Now that we have computed our list of points, l
et us graph it." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "plot( dat
a, style=point, symbol=point, color=black );" }}}{PARA 0 "" 0 "" {TEXT
 371 47 "The original reference for butterfly curves is " }{TEXT 314 
19 "The Butterfly Curve" }{TEXT 371 164 ", by Temple H. Fay, in The Am
erican Mathematical Monthly, Volume 96, Issue 5 (May, 1989), pages 442
-443. The version of the butterfly curve in this example is from " }
{TEXT 315 20 "A Study in Step Size" }{TEXT 371 89 ", by Temple H. Fay,
 in Mathematics Magazine, Volume 70, No. 2, April 1997, pages 116-117.
" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 
1 {PARA 5 "" 0 "" {TEXT 372 29 "17.3.6. Example 6: Animations" }}
{PARA 0 "" 0 "" {TEXT 371 121 "Our last example is the use of a for-lo
op to compute the frames of an animation. Earlier we created animation
s using the " }{TEXT 0 7 "animate" }{TEXT 371 18 " command. But the " 
}{TEXT 0 7 "animate" }{TEXT 371 276 " command is limited in the kind o
f animations it can draw. For example, it cannot animate the graphs of
 equations. There is another way to create animations in which we use \+
a for-loop to create and label a sequence of graphs (the frames) and t
hen we use a special form of the " }{TEXT 0 7 "display" }{TEXT 371 96 
" command to turn the sequence of graphs into an animation. Here is an
 example of this technique." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 
0 "" 0 "" {TEXT 371 142 "First, a for-loop is used to create and name,
 using dotted names, 51 two-dimensional graphs, each with a parameter \+
slightly changed. Then the " }{TEXT 0 7 "display" }{TEXT 371 291 " com
mand is used to \"sequence\" the 51 graphs into a short movie. To view
 the movie, after the first graph is visible, place the cursor on the \+
graph. Some VCR type buttons will appear at the top of the Maple windo
w. Click on the \"play\" button. (The for-loop takes a little while to
 complete.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "x := 'x': y :
= 'y':\n" }{MPLTEXT 1 0 24 "for i from -20 to 30 do\n" }{MPLTEXT 1 0 
54 "  p||i := plots[implicitplot]( x^3+y^3-5*x*y = 1-i/8,\n" }{MPLTEXT
 1 0 66 "               x=-3..3, y=-3..3, numpoints=800, tickmarks=[2,
2] )\n" }{MPLTEXT 1 0 4 "od:\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 48 "plots[display]( p||(-20..30), insequence=true );" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}}{SECT 1 {PARA 3 "" 0
 "" {TEXT 370 28 "17.4. Conditional statements" }}{PARA 0 "" 0 "" 
{TEXT 371 169 "In the previous two sections we learned how to make Map
le repeat a block of statements. In this section we learn how to make \+
Maple skip over certain blocks of statement." }}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 111 "Here is a simple procedure. \+
It takes in two numbers as parameters and it returns the larger of the
 two numbers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "bigger := p
roc( a, b )\n" }{MPLTEXT 1 0 30 "  if a >= b then a else b fi;\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 11 "Try it out." 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "bigger(3, 5);" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "bigger(-3, -5);" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 
0 "" 0 "" {TEXT 371 14 "The procedure " }{TEXT 0 6 "bigger" }{TEXT 
371 58 " introduces another important element of programming, the " }
{TEXT 316 21 "conditional statement" }{TEXT 371 16 " (also called a " 
}{TEXT 317 25 "if-then-else-fi statement" }{TEXT 371 289 ") . The cond
itional statement allows Maple to make a choice when it is computing. \+
A conditional statement is also sometimes called a branching statement
 since it gives Maple a choice between two possible branches of calcul
ations to make. Here is Maple's syntax for a conditional statement." }
}{PARA 0 "" 0 "" {TEXT 371 24 "                        " }{TEXT 0 2 "i
f" }{TEXT 371 2 "  " }{TEXT 318 18 "boolean_expression" }{TEXT 371 1 "
 " }{TEXT 0 4 "then" }{TEXT 371 1 " " }}{PARA 0 "" 0 "" {TEXT 371 30 "
                              " }{TEXT 319 26 "sequence_of_Maple_comma
nds" }}{PARA 0 "" 0 "" {TEXT 371 24 "                        " }{TEXT 
0 4 "else" }}{PARA 0 "" 0 "" {TEXT 371 30 "                           \+
   " }{TEXT 320 26 "sequence_of_Maple_commands" }}{PARA 0 "" 0 "" 
{TEXT 371 24 "                        " }{TEXT 0 2 "fi" }}{PARA 0 "" 0
 "" {TEXT 371 54 "The part of the if-then-else-fi statement between th
e " }{TEXT 0 2 "if" }{TEXT 371 9 " and the " }{TEXT 0 4 "then" }{TEXT 
371 15 " is called the " }{TEXT 321 16 "conditional-part" }{TEXT 371 
113 " and it is either true or false. If the conditional-part is true,
 then Maple executes the statements between the " }{TEXT 0 4 "then" }
{TEXT 371 9 " and the " }{TEXT 0 4 "else" }{TEXT 371 34 ". These state
ments are called the " }{TEXT 322 21 "body of the then-part" }{TEXT 
371 87 ". If the conditional-part is false, then the Maple executes th
e statements between the " }{TEXT 0 4 "else" }{TEXT 371 9 " and the " 
}{TEXT 0 2 "fi" }{TEXT 371 34 ". These statements are called the " }
{TEXT 323 21 "body of the else-part" }{TEXT 371 239 ". The bodies of e
ither the then or else part can contain any number of Maple commands. \+
 The body of the else-part is optional and if it is left off, then the
 conditional statement has the following simpler form, which is referr
ed to as an " }{TEXT 324 12 "if-statement" }{TEXT 371 1 "." }}{PARA 0 
"" 0 "" {TEXT 371 24 "                        " }{TEXT 0 2 "if" }{TEXT
 371 2 "  " }{TEXT 325 18 "boolean_expression" }{TEXT 371 1 " " }{TEXT
 0 4 "then" }{TEXT 371 1 " " }}{PARA 0 "" 0 "" {TEXT 371 29 "         \+
                    " }{TEXT 326 28 "sequence_of_Maple_statements" }}
{PARA 0 "" 0 "" {TEXT 371 5 "     " }{TEXT 327 19 "                   
" }{TEXT 0 2 "fi" }}{PARA 0 "" 0 "" {TEXT 371 246 "If the conditional-
part of an if-statement is true, then Maple executes the body of the t
hen-part. If the conditional-part of an if-statement is false, then Ma
ple does not execute any statements, and it appears as if the if-state
ment did nothing." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 120 "The formatting of the conditional statement, with the b
odies of the then and else parts indented slightly and the words " }
{TEXT 0 4 "else" }{TEXT 371 5 " and " }{TEXT 0 2 "fi" }{TEXT 371 157 "
 on their own lines, is not part of the syntax. But the formatting mak
es it a lot easier to read a conditional statement and should be used \+
most of the time." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 164 "Here are a few examples of simple conditional statement
s. The next command randomly generates a zero or one and if the random
 number is zero, the statement outputs " }{TEXT 0 5 "heads" }{TEXT 
371 23 ", otherwise it outputs " }{TEXT 0 5 "tails" }{TEXT 371 45 ". T
ry executing this statement several times." }}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 25 "if rand(0..1)() = 0 then\n" }{MPLTEXT 1 0 8 "   head
\n" }{MPLTEXT 1 0 5 "else\n" }{MPLTEXT 1 0 8 "   tail\n" }{MPLTEXT 1 
0 4 "fi;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "
" 0 "" {TEXT 371 203 "If we remove the else-part of the if-then-else s
tatement, so that it becomes an if-statement, then the statement will \+
produce no output about half of the time. Try executing this statement
 several times." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "if rand(0
..1)() = 0 then head fi;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}}{PARA 0 "" 0 "" {TEXT 371 241 "The following execution group gene
rates a long list of random integers between 1 and 10 and then it uses
 an if-statement inside of a for-in-loop to determine what percentage \+
of the random integers were 10's. What answer do you expect to get?" }
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "N := 1000:\n" }{MPLTEXT 1 
0 14 "counter := 0:\n" }{MPLTEXT 1 0 30 "seq( rand(1..10)(), i=1..N ):
\n" }{MPLTEXT 1 0 33 "for i in % do  # Check for 10's.\n" }{MPLTEXT 1 
0 41 "  if i = 10 then counter := counter+1 fi\n" }{MPLTEXT 1 0 4 "od;
\n" }{MPLTEXT 1 0 11 "counter/N;\n" }{MPLTEXT 1 0 12 "evalf( % );\n" }
}}{PARA 0 "" 0 "" {TEXT 371 75 "Try executing the execution group seve
ral times. Try changing the value of " }{TEXT 0 1 "N" }{TEXT 371 23 " \+
to 100 or 10 or 10000." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 388 "In t
he last section of this worksheet we saw that loop statements can be v
ery useful commands to use at the Maple command prompt. The conditiona
l statement however is of pretty limited use at the Maple prompt. Inst
ead it is almost always used in the body of a procedure definition or \+
in the body of a loop. Almost all of our examples of conditional state
ments will be in procedure bodies." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }
}{PARA 0 "" 0 "" {TEXT 371 225 "One common use of conditional statemen
ts in mathematics textbooks is in the definition of piecewise defined \+
functions, that is functions defined by different formulas on differen
t parts of the domain. Here are a few examples." }}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 77 "Suppose we wanted to re
present in Maple the mathematical function defined by " }{XPPEDIT 18 0
 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executabl
e = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"
), Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executab
le = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic
\"), Typesetting:-mrow(Typesetting:-msup(Typesetting:-mi(\"x\", italic
 = \"true\", mathvariant = \"italic\"), Typesetting:-mn(\"2\", mathvar
iant = \"normal\"), superscriptshift = \"0\")), Typesetting:-mo(\"+\",
 mathvariant = \"normal\", fence = \"false\", separator = \"false\", s
tretchy = \"false\", symmetric = \"false\", largeop = \"false\", movab
lelimits = \"false\", accent = \"false\", lspace = \"0.2222222em\", rs
pace = \"0.2222222em\"), Typesetting:-mn(\"1\", mathvariant = \"normal
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG
6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italic
GQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariant
GQ'italicF'-F#6&F+-F#6#-I%msupGF$6%-F,6%Q\"xF'F/F7-I#mnGF$6$Q\"2F'/F8Q
'normalF'/%1superscriptshiftGQ\"0F'-I#moGF$6-Q\"+F'FH/%&fenceGQ&falseF
'/%*separatorGFS/%)stretchyGFS/%*symmetricGFS/%(largeopGFS/%.movableli
mitsGFS/%'accentGFS/%'lspaceGQ,0.2222222emF'/%'rspaceGF\\o-FE6$Q\"1F'F
HF+" }{TEXT 371 5 " for " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesettin
g:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name \+
= \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetti
ng:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesettin
g:-mo(\"<\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.277
7778em\", rspace = \"0.2777778em\"), Typesetting:-mn(\"0\", mathvarian
t = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", executable \+
= \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"))
;" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q
!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%
,mathvariantGQ'italicF'-F#6%-F,6%Q\"xF'F/F7-I#moGF$6-Q\"<F'/F8Q'normal
F'/%&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGFG/%(lar
geopGFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.2777778emF'/%'rspa
ceGFV-I#mnGF$6$Q\"0F'FCF+" }{TEXT 371 8 " and by " }{XPPEDIT 18 0 "Typ
esetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), T
ypesetting:-mrow(Typesetting:-mi(\"sin\", italic = \"false\", mathvari
ant = \"normal\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Ty
pesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"
true\", executable = \"true\", font_style_name = \"2D Input\", mathvar
iant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"Pi\", italic =
 \"false\", mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTim
es;\", mathvariant = \"normal\", fence = \"false\", separator = \"fals
e\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\",
 movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rs
pace = \"0.0em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvaria
nt = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable
 = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")
), mathvariant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\"
, executable = \"true\", font_style_name = \"2D Input\", mathvariant =
 \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'
6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ
)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-F,6%Q$sinF'/F0Q&falseF'/F8Q'
normalF'-I#moGF$6-Q0&ApplyFunction;F'FA/%&fenceGF@/%*separatorGF@/%)st
retchyGF@/%*symmetricGF@/%(largeopGF@/%.movablelimitsGF@/%'accentGF@/%
'lspaceGQ&0.0emF'/%'rspaceGFW-I(mfencedGF$6$-F#6%F+-F#6%-F,6%Q#PiF'F?F
A-FD6-Q1&InvisibleTimes;F'FAFGFIFKFMFOFQFSFUFX-F,6%Q\"xF'F/F7F+FAF+" }
{TEXT 371 5 " for " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mn
(\"0\", mathvariant = \"normal\"), Typesetting:-mo(\"&le;\", mathvaria
nt = \"normal\", fence = \"false\", separator = \"false\", stretchy = \+
\"false\", symmetric = \"false\", largeop = \"false\", movablelimits =
 \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0
.2777778em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant =
 \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"));"
 "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F
'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,m
athvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"0F'/F8Q'normalF'-I#moGF$6-Q%&le
;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%)stretchyGFH/%*symmetricGFH/%(
largeopGFH/%.movablelimitsGFH/%'accentGFH/%'lspaceGQ,0.2777778emF'/%'r
spaceGFW-F,6%Q\"xF'F/F7F+" }{TEXT 371 80 ". Here is how we can do it u
sing a procedure containing a conditional statement." }}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 15 "f := proc( x )\n" }{MPLTEXT 1 0 40 "  if x
 < 0 then x^2+1 else sin(Pi*x) fi\n" }{MPLTEXT 1 0 5 "end;\n" }}}
{PARA 0 "" 0 "" {TEXT 371 137 "Notice how there is only one boolean ex
pression, even though there are two pieces to the function. The second
 piece of the function, the " }{XPPEDIT 18 0 "Typesetting:-mrow(Typese
tting:-mi(\"\", italic = \"true\", executable = \"true\", font_style_n
ame = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Types
etting:-mi(\"sin\", italic = \"false\", mathvariant = \"normal\"), Typ
esetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"
false\", separator = \"false\", stretchy = \"false\", symmetric = \"fa
lse\", largeop = \"false\", movablelimits = \"false\", accent = \"fals
e\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typ
esetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \+
\"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"), T
ypesetting:-mrow(Typesetting:-mi(\"Pi\", italic = \"false\", mathvaria
nt = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \+
\"normal\", fence = \"false\", separator = \"false\", stretchy = \"fal
se\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fa
lse\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Ty
pesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")), Ty
pesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_sty
le_name = \"2D Input\", mathvariant = \"italic\")), mathvariant = \"no
rmal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'it
alicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvar
iantGQ'italicF'-F#6%-F,6%Q$sinF'/F0Q&falseF'/F8Q'normalF'-I#moGF$6-Q0&
ApplyFunction;F'FA/%&fenceGF@/%*separatorGF@/%)stretchyGF@/%*symmetric
GF@/%(largeopGF@/%.movablelimitsGF@/%'accentGF@/%'lspaceGQ&0.0emF'/%'r
spaceGFW-I(mfencedGF$6$-F#6%F+-F#6%-F,6%Q#PiF'F?FA-FD6-Q1&InvisibleTim
es;F'FAFGFIFKFMFOFQFSFUFX-F,6%Q\"xF'F/F7F+FAF+" }{TEXT 371 29 " part, \+
should apply whenever " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting
:-mn(\"0\", mathvariant = \"normal\"), Typesetting:-mo(\"&le;\", mathv
ariant = \"normal\", fence = \"false\", separator = \"false\", stretch
y = \"false\", symmetric = \"false\", largeop = \"false\", movablelimi
ts = \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace =
 \"0.2777778em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvaria
nt = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executable
 = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")
);" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'
Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/
%,mathvariantGQ'italicF'-F#6%-I#mnGF$6$Q\"0F'/F8Q'normalF'-I#moGF$6-Q%
&le;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%)stretchyGFH/%*symmetricGFH
/%(largeopGFH/%.movablelimitsGFH/%'accentGFH/%'lspaceGQ,0.2777778emF'/
%'rspaceGFW-F,6%Q\"xF'F/F7F+" }{TEXT 371 19 ". But we only have " }
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mrow(Typesetting:-mn(\"0\", mathvariant =
 \"normal\"), Typesetting:-mo(\"&le;\", mathvariant = \"normal\", fenc
e = \"false\", separator = \"false\", stretchy = \"false\", symmetric \+
= \"false\", largeop = \"false\", movablelimits = \"false\", accent = \+
\"false\", lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typese
tting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")), Typese
tting:-mi(\"\", italic = \"true\", executable = \"true\", font_style_n
ame = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulen
ameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+
executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-
F#6%-I#mnGF$6$Q\"0F'/F8Q'normalF'-I#moGF$6-Q%&le;F'F@/%&fenceGQ&falseF
'/%*separatorGFH/%)stretchyGFH/%*symmetricGFH/%(largeopGFH/%.movableli
mitsGFH/%'accentGFH/%'lspaceGQ,0.2777778emF'/%'rspaceGFW-F,6%Q\"xF'F/F
7F+" }{TEXT 371 33 " whenever the boolean expression " }{TEXT 0 3 "x<0
" }{TEXT 371 380 " is false, which automatically puts us in the else-p
art of the conditional statement. So only one boolean expression is ne
eded for a piecewise defined function with two pieces. But this is not
 how traditional mathematics books would typeset the definition of thi
s function. Mathematics books almost always write out a boolean expres
sion for each piece of the function, like this. " }}{PARA 208 "" 0 "" 
{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"tru
e\", executable = \"true\", font_style_name = \"2D Input\", mathvarian
t = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"f\", italic = \"t
rue\", mathvariant = \"italic\"), Typesetting:-mo(\"&ApplyFunction;\",
 mathvariant = \"normal\", fence = \"false\", separator = \"false\", s
tretchy = \"false\", symmetric = \"false\", largeop = \"false\", movab
lelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace =
 \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"
x\", italic = \"true\", mathvariant = \"italic\")), mathvariant = \"no
rmal\")), Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"f
alse\", separator = \"false\", stretchy = \"false\", symmetric = \"fal
se\", largeop = \"false\", movablelimits = \"false\", accent = \"false
\", lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-
mrow(Typesetting:-mo(\"\{\", mathvariant = \"normal\", fence = \"true
\", separator = \"false\", stretchy = \"true\", symmetric = \"false\",
 largeop = \"false\", movablelimits = \"false\", accent = \"false\", l
space = \"0.1666667em\", rspace = \"0.1666667em\"), Typesetting:-mtabl
e(Typesetting:-mtr(Typesetting:-mtd(Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-ms
up(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\")
, Typesetting:-mn(\"2\", mathvariant = \"normal\"), superscriptshift =
 \"0\")), Typesetting:-mo(\"+\", mathvariant = \"normal\", fence = \"f
alse\", separator = \"false\", stretchy = \"false\", symmetric = \"fal
se\", largeop = \"false\", movablelimits = \"false\", accent = \"false
\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-
mn(\"1\", mathvariant = \"normal\")), rowalign = \"\", columnalign = \+
\"\", groupalign = \"\", rowspan = \"1\", columnspan = \"1\"), Typeset
ting:-mtd(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", \+
mathvariant = \"italic\"), Typesetting:-mo(\"<\", mathvariant = \"norm
al\", fence = \"false\", separator = \"false\", stretchy = \"false\", \+
symmetric = \"false\", largeop = \"false\", movablelimits = \"false\",
 accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.2777778em
\"), Typesetting:-mn(\"0\", mathvariant = \"normal\")), rowalign = \"
\", columnalign = \"\", groupalign = \"\", rowspan = \"1\", columnspan
 = \"1\"), rowalign = \"\", columnalign = \"\", groupalign = \"\"), Ty
pesetting:-mtr(Typesetting:-mtd(Typesetting:-mrow(Typesetting:-mi(\"si
n\", italic = \"false\", mathvariant = \"normal\"), Typesetting:-mo(\"
&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mrow
(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_
style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mro
w(Typesetting:-mi(\"Pi\", italic = \"false\", mathvariant = \"normal\"
), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fen
ce = \"false\", separator = \"false\", stretchy = \"false\", symmetric
 = \"false\", largeop = \"false\", movablelimits = \"false\", accent =
 \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(
\"x\", italic = \"true\", mathvariant = \"italic\")), Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\")), mathvariant = \"normal\")), rowa
lign = \"\", columnalign = \"\", groupalign = \"\", rowspan = \"1\", c
olumnspan = \"1\"), Typesetting:-mtd(Typesetting:-mrow(Typesetting:-mn
(\"0\", mathvariant = \"normal\"), Typesetting:-mo(\"&le;\", mathvaria
nt = \"normal\", fence = \"false\", separator = \"false\", stretchy = \+
\"false\", symmetric = \"false\", largeop = \"false\", movablelimits =
 \"false\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0
.2777778em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant =
 \"italic\")), rowalign = \"\", columnalign = \"\", groupalign = \"\",
 rowspan = \"1\", columnspan = \"1\"), rowalign = \"\", columnalign = \+
\"\", groupalign = \"\"), align = \"axis\", rowalign = \"baseline\", c
olumnalign = \"center\", groupalign = \"\{left\}\", alignmentscope = \+
\"true\", columnwidth = \"auto\", width = \"auto\", rowspacing = \"1.0
ex\", columnspacing = \"2em\", rowlines = \"none\", columnlines = \"no
ne\", frame = \"none\", framespacing = \"0.4em 0.5ex\", equalrows = \"
false\", equalcolumns = \"false\", displaystyle = \"false\", side = \"
right\", minlabelspacing = \"0.8em\"), Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", execut
able = \"true\", font_style_name = \"2D Input\", mathvariant = \"itali
c\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\",
 font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrow
G6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'itali
cGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvarian
tGQ'italicF'-F#6'F+-F#6%-F,6%Q\"fF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F
8Q'normalF'/%&fenceGQ&falseF'/%*separatorGFI/%)stretchyGFI/%*symmetric
GFI/%(largeopGFI/%.movablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'/%'r
spaceGFX-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFR
FT/FWQ,0.2777778emF'/FZFao-F#6%-FB6-Q\"|frF'FE/FHF1FJ/FMF1FNFPFRFT/FWQ
,0.1666667emF'/FZF[p-I'mtableGF$66-I$mtrGF$6'-I$mtdGF$6(-F#6&F+-F#6#-I
%msupGF$6%Fjn-I#mnGF$6$Q\"2F'FE/%1superscriptshiftGQ\"0F'-FB6-Q\"+F'FE
FGFJFLFNFPFRFT/FWQ,0.2222222emF'/FZFhq-F^q6$Q\"1F'FE/%)rowalignGF./%,c
olumnalignGF./%+groupalignGF./%(rowspanGF\\r/%+columnspanGF\\r-Fdp6(-F
#6%Fjn-FB6-Q\"<F'FEFGFJFLFNFPFRFTF`oFbo-F^q6$FcqFEF]rF_rFarFcrFerF]rF_
rFar-Fap6'-Fdp6(-F#6%-F,6%Q$sinF'/F0FIFEFA-Ffn6$-F#6%F+-F#6%-F,6%Q#PiF
'FisFE-FB6-Q1&InvisibleTimes;F'FEFGFJFLFNFPFRFTFVFYFjnF+FEF]rF_rFarFcr
Fer-Fdp6(-F#6%F^s-FB6-Q%&le;F'FEFGFJFLFNFPFRFTF`oFboFjnF]rF_rFarFcrFer
F]rF_rFar/%&alignGQ%axisF'/F^rQ)baselineF'/F`rQ'centerF'/FbrQ'|frleft|
hrF'/%/alignmentscopeGF1/%,columnwidthGQ%autoF'/%&widthGFju/%+rowspaci
ngGQ&1.0exF'/%.columnspacingGQ$2emF'/%)rowlinesGQ%noneF'/%,columnlines
GFev/%&frameGFev/%-framespacingGQ,0.4em~0.5exF'/%*equalrowsGFI/%-equal
columnsGFI/%-displaystyleGFI/%%sideGQ&rightF'/%0minlabelspacingGQ&0.8e
mF'F+F+F+" }{TEXT 375 0 "" }}{PARA 0 "" 0 "" {TEXT 371 78 "What appear
s in a mathematics book is more like the following Maple procedure." }
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "f := proc(x)\n" }{MPLTEXT 
1 0 27 "  if x < 0 then x^2+1 else\n" }{MPLTEXT 1 0 33 "    if x >= 0 \+
then sin(Pi*x) fi;\n" }{MPLTEXT 1 0 5 "  fi\n" }{MPLTEXT 1 0 5 "end;\n
" }}}{PARA 0 "" 0 "" {TEXT 371 953 "This version has two boolean expre
ssions because it has two if-statements. This is not the preferred way
 of defining our function in Maple for several reasons. First of all, \+
it is not as easy to read as the previous version. With only one condi
tional statement we know that the else-part is mutually exclusive of t
he then-part. With two conditional statements it is not obvious that t
he two statements are mutually exclusive. A reader must carefully exam
ine the boolean expressions to determine if they are meant to be mutua
lly exclusive or not. Secondly, the version with one conditional is co
mputationally more efficient than the version with two conditional sta
tements. Every call to the second version must evaluate two boolean ex
pressions while every call to the first version only needs to evaluate
 one boolean expression. This can make a difference if the function is
 going to be called thousands (or millions or even billions of times) \+
of times." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 
328 8 "Exercise" }{TEXT 371 20 ": Define a function " }{TEXT 0 1 "g" }
{TEXT 371 35 " similar to the last definition of " }{TEXT 0 1 "f" }
{TEXT 371 92 " in such a way that the two boolean expressions are not \+
mutually exclusive. Draw a graph of " }{TEXT 0 1 "g" }{TEXT 371 91 ". \+
If the boolean expressions are not mutually exclusive, how does that a
ffect the graph of " }{TEXT 0 1 "g" }{TEXT 371 1 "?" }}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 
0 "" 0 "" {TEXT 371 26 "Let us graph our function " }{TEXT 0 1 "f" }
{TEXT 371 27 " to see what it looks like." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "plot( f, -1..1, discont=true, color=red );" }}}{PARA 
0 "" 0 "" {TEXT 371 51 "It is worth noting that the following command \+
does " }{TEXT 329 3 "not" }{TEXT 371 55 " work, even though it looks p
erfectly OK. The function " }{TEXT 0 1 "f" }{TEXT 371 51 " is converte
d to an expression by evaluating it at " }{TEXT 0 1 "x" }{TEXT 371 27 
", and then the form of the " }{TEXT 0 4 "plot" }{TEXT 371 33 " comman
d for expressions is used." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "plot( f(x), x=-1..1 );" }}}{PARA 0 "" 0 "" {TEXT 371 122 "What wen
t wrong is that Maple is using its rule of full evaluation, so Maple t
ries to evaluate all of the operands in the " }{TEXT 0 4 "plot" }{TEXT
 371 9 " command " }{TEXT 330 6 "before" }{TEXT 371 22 " actually call
ing the " }{TEXT 0 4 "plot" }{TEXT 371 41 " procedure. When Maple trie
s to evaluate " }{TEXT 0 4 "f(x)" }{TEXT 371 47 " there is an error, s
ince the actual parameter " }{TEXT 0 1 "x" }{TEXT 371 60 " is an unass
igned variable and the conditional statement in " }{TEXT 0 1 "f" }
{TEXT 371 51 " has no way to determine if the boolean expression " }
{TEXT 0 3 "x<0" }{TEXT 371 16 " is true or not." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 5 "f(x);" }}}{PARA 0 "" 0 "" {TEXT 371 69 "The foll
owing command does work, since it prevents the evaluation of " }{TEXT 
0 4 "f(x)" }{TEXT 371 11 " until the " }{TEXT 0 4 "plot" }{TEXT 371 
91 " procedure actually starts sticking numbers as actual parameters i
nto the formal parameter " }{TEXT 0 1 "x" }{TEXT 371 4 " in " }{TEXT 
0 4 "f(x)" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "plot( 'f(x)', x=-1..1 );" }}}{PARA 0 "" 0 "" {TEXT 371 90 "In an o
ptional section later in this worksheet we will say more about this si
tuation with " }{TEXT 0 4 "f(x)" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "
" 0 "" {TEXT 331 8 "Exercise" }{TEXT 371 68 ": Here is what seems to b
e a reasonable definition for the function " }{TEXT 0 1 "f" }{TEXT 
371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "f := proc(x)\n" 
}{MPLTEXT 1 0 26 "  if x < 0 then x^2+1 fi;\n" }{MPLTEXT 1 0 31 "  if \+
x >= 0 then sin(Pi*x) fi;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 
"" {TEXT 371 60 "But it is not correct. Look at the graph of this vers
ion of " }{TEXT 0 1 "f" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "plot( f, -1..1 );" }}}{PARA 0 "" 0 "" {TEXT 371 34 "W
hat happened to the left half of " }{TEXT 0 1 "f" }{TEXT 371 15 ", the
 part for " }{TEXT 0 3 "x<0" }{TEXT 371 66 "? Here is a hint. What is \+
the return value for the procedure call " }{TEXT 0 5 "f(-2)" }{TEXT 
371 1 "?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "f(-2);" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 332 8 "Exercise" }{TEXT 371 39 ": Con
sider the following two functions." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "f := proc(x) if x>=0 then x^2 else 0 fi end;" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "g := proc(x) if x>=0 then x^
2 fi end;" }}}{PARA 0 "" 0 "" {TEXT 371 26 "Their graphs look similar.
" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "plot( f, -10..10 );" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "plot( g, -10..10 );" }}}
{PARA 0 "" 0 "" {TEXT 371 61 "But they are not the same function. Expl
ain how they differ. " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 210 "Here \+
is an interesting variation on the idea of a piecewise defined functio
n. We will create a randomly defined piecewise function. The following
 procedure, like the piecewise defined function above, evaluates " }
{TEXT 0 1 "f" }{TEXT 371 39 " by choosing between two expressions,  " 
}{TEXT 0 5 "x^2+1" }{TEXT 371 5 " and " }{TEXT 0 9 "sin(Pi*x)" }{TEXT 
371 79 ". But instead of basing the choice of the expression on the va
lue of the input " }{TEXT 0 1 "x" }{TEXT 371 82 ", this version bases \+
the choice on a random number generated within the procedure." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "f := proc( x )\n" }{MPLTEXT 
1 0 49 "  if rand(0..1)()=0 then x^2+1 else sin(Pi*x) fi\n" }{MPLTEXT 
1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 29 "So the value of the fu
nction " }{TEXT 0 1 "f" }{TEXT 371 108 " at any point will be one of t
wo randomly chosen numbers. Try executing the following command severa
l times." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "f(5), f(5), f(5)
, f(5), f(5);" }}}{PARA 0 "" 0 "" {TEXT 371 134 "Here is what a graph \+
of this function might look like. Notice that each time the function i
s graphed, we get a different graph (why?)." }}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 17 "plot( f, -1..1 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "plot( f, -1..1 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 333 8 "Exercise" }{TEXT 371 69 ": What causes the vertical bands
 of red in the graph? Here is a hint." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 75 "plot( f, -1..1, style=point, symbol=circle, numpoints
=50, adaptive=false );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 158 "Sup
pose that we want to represent in Maple a piecewise defined function w
ith three pieces. For example, suppose we want to represent the functi
on g defined by" }}{PARA 206 "" 0 "" {XPPEDIT 18 0 "Typesetting:-mrow(
Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_s
tyle_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow
(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", font_
style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mro
w(Typesetting:-msup(Typesetting:-mi(\"x\", italic = \"true\", mathvari
ant = \"italic\"), Typesetting:-mn(\"2\", mathvariant = \"normal\"), s
uperscriptshift = \"0\")), Typesetting:-mo(\"+\", mathvariant = \"norm
al\", fence = \"false\", separator = \"false\", stretchy = \"false\", \+
symmetric = \"false\", largeop = \"false\", movablelimits = \"false\",
 accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em
\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG
6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italic
GQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariant
GQ'italicF'-F#6&F+-F#6#-I%msupGF$6%-F,6%Q\"xF'F/F7-I#mnGF$6$Q\"2F'/F8Q
'normalF'/%1superscriptshiftGQ\"0F'-I#moGF$6-Q\"+F'FH/%&fenceGQ&falseF
'/%*separatorGFS/%)stretchyGFS/%*symmetricGFS/%(largeopGFS/%.movableli
mitsGFS/%'accentGFS/%'lspaceGQ,0.2222222emF'/%'rspaceGF\\oFAF+" }{TEXT
 376 5 " for " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\",
 italic = \"true\", executable = \"true\", font_style_name = \"2D Inpu
t\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(\"x
\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(\"&l
e;\", mathvariant = \"normal\", fence = \"false\", separator = \"false
\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\", \+
movablelimits = \"false\", accent = \"false\", lspace = \"0.2777778em
\", rspace = \"0.2777778em\"), Typesetting:-mn(\"0\", mathvariant = \"
normal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"tr
ue\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I
%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'
italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathv
ariantGQ'italicF'-F#6%-F,6%Q\"xF'F/F7-I#moGF$6-Q%&le;F'/F8Q'normalF'/%
&fenceGQ&falseF'/%*separatorGFG/%)stretchyGFG/%*symmetricGFG/%(largeop
GFG/%.movablelimitsGFG/%'accentGFG/%'lspaceGQ,0.2777778emF'/%'rspaceGF
V-I#mnGF$6$Q\"0F'FCF+" }{TEXT 376 5 ", by " }{XPPEDIT 18 0 "Typesettin
g:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\"
, font_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetti
ng:-mrow(Typesetting:-mi(\"sin\", italic = \"false\", mathvariant = \"
normal\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesettin
g:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\",
 mathvariant = \"italic\")), mathvariant = \"normal\")), Typesetting:-
mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6
\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+execu
tableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6%-
F,6%Q$sinF'/F0Q&falseF'/F8Q'normalF'-I#moGF$6-Q0&ApplyFunction;F'FA/%&
fenceGF@/%*separatorGF@/%)stretchyGF@/%*symmetricGF@/%(largeopGF@/%.mo
vablelimitsGF@/%'accentGF@/%'lspaceGQ&0.0emF'/%'rspaceGFW-I(mfencedGF$
6$-F#6#-F,6%Q\"xF'F/F7FAF+" }{TEXT 376 8 " for 0 <" }{XPPEDIT 18 0 "Ty
pesetting:-mrow(Typesetting:-mi(\"x\", italic = \"true\", mathvariant \+
= \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF
'6#-I#miGF$6%Q\"xF'/%'italicGQ%trueF'/%,mathvariantGQ'italicF'" }{TEXT
 376 2 "< " }{XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"\", it
alic = \"true\", executable = \"true\", font_style_name = \"2D Input\"
, mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mn(\"3\", \+
mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mathv
ariant = \"normal\", fence = \"false\", separator = \"false\", stretch
y = \"false\", symmetric = \"false\", largeop = \"false\", movablelimi
ts = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0
em\"), Typesetting:-mi(\"Pi\", italic = \"false\", mathvariant = \"nor
mal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'it
alicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvar
iantGQ'italicF'-F#6%-I#mnGF$6$Q\"3F'/F8Q'normalF'-I#moGF$6-Q1&Invisibl
eTimes;F'F@/%&fenceGQ&falseF'/%*separatorGFH/%)stretchyGFH/%*symmetric
GFH/%(largeopGFH/%.movablelimitsGFH/%'accentGFH/%'lspaceGQ&0.0emF'/%'r
spaceGFW-F,6%Q#PiF'/F0FHF@F+" }{TEXT 376 9 ", and by " }{XPPEDIT 18 0 
"Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable
 = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\")
, Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executabl
e = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic\"
), Typesetting:-mrow(Typesetting:-msup(Typesetting:-mi(\"x\", italic =
 \"true\", mathvariant = \"italic\"), Typesetting:-mn(\"2\", mathvaria
nt = \"normal\"), superscriptshift = \"0\")), Typesetting:-mo(\"&minus
;\", mathvariant = \"normal\", fence = \"false\", separator = \"false
\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\", \+
movablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em
\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typesetting:-mn(\"6\"
, mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", mat
hvariant = \"normal\", fence = \"false\", separator = \"false\", stret
chy = \"false\", symmetric = \"false\", largeop = \"false\", movableli
mits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0
.0em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"ita
lic\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\"
, fence = \"false\", separator = \"false\", stretchy = \"false\", symm
etric = \"false\", largeop = \"false\", movablelimits = \"false\", acc
ent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:
-mi(\"Pi\", italic = \"false\", mathvariant = \"normal\")), Typesettin
g:-mo(\"+\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.222
2222em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typesetting:-mn
(\"9\", mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;
\", mathvariant = \"normal\", fence = \"false\", separator = \"false\"
, stretchy = \"false\", symmetric = \"false\", largeop = \"false\", mo
vablelimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspac
e = \"0.0em\"), Typesetting:-mrow(Typesetting:-msup(Typesetting:-mi(\"
Pi\", italic = \"false\", mathvariant = \"normal\"), Typesetting:-mn(
\"2\", mathvariant = \"normal\"), superscriptshift = \"0\")), Typesett
ing:-mi(\"\", italic = \"true\", executable = \"true\", font_style_nam
e = \"2D Input\", mathvariant = \"italic\")), Typesetting:-mo(\"&minus
;\", mathvariant = \"normal\", fence = \"false\", separator = \"false
\", stretchy = \"false\", symmetric = \"false\", largeop = \"false\", \+
movablelimits = \"false\", accent = \"false\", lspace = \"0.2222222em
\", rspace = \"0.2222222em\"), Typesetting:-mi(\"x\", italic = \"true
\", mathvariant = \"italic\"), Typesetting:-mo(\"+\", mathvariant = \"
normal\", fence = \"false\", separator = \"false\", stretchy = \"false
\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fals
e\", accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.222222
2em\"), Typesetting:-mrow(Typesetting:-mn(\"3\", mathvariant = \"norma
l\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", \+
fence = \"false\", separator = \"false\", stretchy = \"false\", symmet
ric = \"false\", largeop = \"false\", movablelimits = \"false\", accen
t = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-m
i(\"Pi\", italic = \"false\", mathvariant = \"normal\")), Typesetting:
-mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic
 = \"true\", executable = \"true\", font_style_name = \"2D Input\", ma
thvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI
(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_s
tyle_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6-F+-F#6#-I%msupGF$6
%-F,6%Q\"xF'F/F7-I#mnGF$6$Q\"2F'/F8Q'normalF'/%1superscriptshiftGQ\"0F
'-I#moGF$6-Q(&minus;F'FH/%&fenceGQ&falseF'/%*separatorGFS/%)stretchyGF
S/%*symmetricGFS/%(largeopGFS/%.movablelimitsGFS/%'accentGFS/%'lspaceG
Q,0.2222222emF'/%'rspaceGF\\o-F#6'-FE6$Q\"6F'FH-FN6-Q1&InvisibleTimes;
F'FHFQFTFVFXFZFfnFhn/F[oQ&0.0emF'/F^oFhoFAFdo-F,6%Q#PiF'/F0FSFH-FN6-Q
\"+F'FHFQFTFVFXFZFfnFhnFjnF]o-F#6&-FE6$Q\"9F'FHFdo-F#6#-F?6%FjoFDFJF+F
MFAF^p-F#6%-FE6$Q\"3F'FHFdoFjoF+F+" }{TEXT 376 5 " for " }{XPPEDIT 18 
0 "Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", executab
le = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic
\"), Typesetting:-mrow(Typesetting:-mi(\"\", italic = \"true\", execut
able = \"true\", font_style_name = \"2D Input\", mathvariant = \"itali
c\"), Typesetting:-mrow(Typesetting:-mn(\"3\", mathvariant = \"normal
\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", f
ence = \"false\", separator = \"false\", stretchy = \"false\", symmetr
ic = \"false\", largeop = \"false\", movablelimits = \"false\", accent
 = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi
(\"Pi\", italic = \"false\", mathvariant = \"normal\")), Typesetting:-
mo(\"&le;\", mathvariant = \"normal\", fence = \"false\", separator = \+
\"false\", stretchy = \"false\", symmetric = \"false\", largeop = \"fa
lse\", movablelimits = \"false\", accent = \"false\", lspace = \"0.277
7778em\", rspace = \"0.2777778em\"), Typesetting:-mi(\"x\", italic = \+
\"true\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic = \+
\"true\", executable = \"true\", font_style_name = \"2D Input\", mathv
ariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_s
yslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_styl
e_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6&F+-F#6%-I#mnGF$6$Q\"3
F'/F8Q'normalF'-I#moGF$6-Q1&InvisibleTimes;F'FB/%&fenceGQ&falseF'/%*se
paratorGFJ/%)stretchyGFJ/%*symmetricGFJ/%(largeopGFJ/%.movablelimitsGF
J/%'accentGFJ/%'lspaceGQ&0.0emF'/%'rspaceGFY-F,6%Q#PiF'/F0FJFB-FE6-Q%&
le;F'FBFHFKFMFOFQFSFU/FXQ,0.2777778emF'/FenF^o-F,6%Q\"xF'F/F7F+" }
{TEXT 376 1 "," }}{PARA 0 "" 0 "" {TEXT 371 87 "or, to use a notation \+
similar to (but not exactly like) standard mathematical notation," }}
{PARA 201 "" 0 "" {XPPEDIT 18 0 "Typesetting:-mrow(Typesetting:-mi(\"
\", italic = \"true\", executable = \"true\", font_style_name = \"2D I
nput\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi(
\"\", italic = \"true\", executable = \"true\", font_style_name = \"2D
 Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesetting:-mi
(\"g\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-mo(
\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"false\", sepa
rator = \"false\", stretchy = \"false\", symmetric = \"false\", largeo
p = \"false\", movablelimits = \"false\", accent = \"false\", lspace =
 \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typesetting:-mro
w(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"))
, mathvariant = \"normal\")), Typesetting:-mo(\"=\", mathvariant = \"n
ormal\", fence = \"false\", separator = \"false\", stretchy = \"false
\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fals
e\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.277777
8em\"), Typesetting:-mrow(Typesetting:-mo(\"\{\", mathvariant = \"norm
al\", fence = \"true\", separator = \"false\", stretchy = \"true\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.1666667em\", rspace = \"0.1666667em\")
, Typesetting:-mtable(Typesetting:-mtr(Typesetting:-mtd(Typesetting:-m
row(Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", fo
nt_style_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-
mrow(Typesetting:-msup(Typesetting:-mi(\"x\", italic = \"true\", mathv
ariant = \"italic\"), Typesetting:-mn(\"2\", mathvariant = \"normal\")
, superscriptshift = \"0\")), Typesetting:-mo(\"+\", mathvariant = \"n
ormal\", fence = \"false\", separator = \"false\", stretchy = \"false
\", symmetric = \"false\", largeop = \"false\", movablelimits = \"fals
e\", accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.222222
2em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"ital
ic\")), rowalign = \"\", columnalign = \"\", groupalign = \"\", rowspa
n = \"1\", columnspan = \"1\"), Typesetting:-mtd(Typesetting:-mrow(Typ
esetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Type
setting:-mo(\"&le;\", mathvariant = \"normal\", fence = \"false\", sep
arator = \"false\", stretchy = \"false\", symmetric = \"false\", large
op = \"false\", movablelimits = \"false\", accent = \"false\", lspace \+
= \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-mn(\"0\", m
athvariant = \"normal\")), rowalign = \"\", columnalign = \"\", groupa
lign = \"\", rowspan = \"1\", columnspan = \"1\"), rowalign = \"\", co
lumnalign = \"\", groupalign = \"\"), Typesetting:-mtr(Typesetting:-mt
d(Typesetting:-mrow(Typesetting:-mi(\"sin\", italic = \"false\", mathv
ariant = \"normal\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant
 = \"normal\", fence = \"false\", separator = \"false\", stretchy = \"
false\", symmetric = \"false\", largeop = \"false\", movablelimits = \+
\"false\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\")
, Typesetting:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"x\", italic
 = \"true\", mathvariant = \"italic\")), mathvariant = \"normal\")), r
owalign = \"\", columnalign = \"\", groupalign = \"\", rowspan = \"1\"
, columnspan = \"1\"), Typesetting:-mtd(Typesetting:-mrow(Typesetting:
-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Typesetting:-
mo(\"<\", mathvariant = \"normal\", fence = \"false\", separator = \"f
alse\", stretchy = \"false\", symmetric = \"false\", largeop = \"false
\", movablelimits = \"false\", accent = \"false\", lspace = \"0.277777
8em\", rspace = \"0.2777778em\"), Typesetting:-mrow(Typesetting:-mn(\"
3\", mathvariant = \"normal\"), Typesetting:-mo(\"&InvisibleTimes;\", \+
mathvariant = \"normal\", fence = \"false\", separator = \"false\", st
retchy = \"false\", symmetric = \"false\", largeop = \"false\", movabl
elimits = \"false\", accent = \"false\", lspace = \"0.0em\", rspace = \+
\"0.0em\"), Typesetting:-mi(\"Pi\", italic = \"false\", mathvariant = \+
\"normal\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"
true\", font_style_name = \"2D Input\", mathvariant = \"italic\")), ro
walign = \"\", columnalign = \"\", groupalign = \"\", rowspan = \"1\",
 columnspan = \"1\"), rowalign = \"\", columnalign = \"\", groupalign \+
= \"\"), Typesetting:-mtr(Typesetting:-mtd(Typesetting:-mrow(Typesetti
ng:-mi(\"\", italic = \"true\", executable = \"true\", font_style_name
 = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Typesett
ing:-msup(Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"it
alic\"), Typesetting:-mn(\"2\", mathvariant = \"normal\"), superscript
shift = \"0\")), Typesetting:-mo(\"&minus;\", mathvariant = \"normal\"
, fence = \"false\", separator = \"false\", stretchy = \"false\", symm
etric = \"false\", largeop = \"false\", movablelimits = \"false\", acc
ent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), \+
Typesetting:-mrow(Typesetting:-mn(\"6\", mathvariant = \"normal\"), Ty
pesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", fence = \+
\"false\", separator = \"false\", stretchy = \"false\", symmetric = \"
false\", largeop = \"false\", movablelimits = \"false\", accent = \"fa
lse\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"Pi\"
, italic = \"false\", mathvariant = \"normal\"), Typesetting:-mo(\"&In
visibleTimes;\", mathvariant = \"normal\", fence = \"false\", separato
r = \"false\", stretchy = \"false\", symmetric = \"false\", largeop = \+
\"false\", movablelimits = \"false\", accent = \"false\", lspace = \"0
.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"x\", italic = \"true\",
 mathvariant = \"italic\")), Typesetting:-mo(\"+\", mathvariant = \"no
rmal\", fence = \"false\", separator = \"false\", stretchy = \"false\"
, symmetric = \"false\", largeop = \"false\", movablelimits = \"false
\", accent = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222
em\"), Typesetting:-mrow(Typesetting:-mn(\"9\", mathvariant = \"normal
\"), Typesetting:-mo(\"&InvisibleTimes;\", mathvariant = \"normal\", f
ence = \"false\", separator = \"false\", stretchy = \"false\", symmetr
ic = \"false\", largeop = \"false\", movablelimits = \"false\", accent
 = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mr
ow(Typesetting:-msup(Typesetting:-mi(\"Pi\", italic = \"false\", mathv
ariant = \"normal\"), Typesetting:-mn(\"2\", mathvariant = \"normal\")
, superscriptshift = \"0\")), Typesetting:-mi(\"\", italic = \"true\",
 executable = \"true\", font_style_name = \"2D Input\", mathvariant = \+
\"italic\")), Typesetting:-mo(\"&minus;\", mathvariant = \"normal\", f
ence = \"false\", separator = \"false\", stretchy = \"false\", symmetr
ic = \"false\", largeop = \"false\", movablelimits = \"false\", accent
 = \"false\", lspace = \"0.2222222em\", rspace = \"0.2222222em\"), Typ
esetting:-mi(\"x\", italic = \"true\", mathvariant = \"italic\"), Type
setting:-mo(\"+\", mathvariant = \"normal\", fence = \"false\", separa
tor = \"false\", stretchy = \"false\", symmetric = \"false\", largeop \+
= \"false\", movablelimits = \"false\", accent = \"false\", lspace = \+
\"0.2222222em\", rspace = \"0.2222222em\"), Typesetting:-mrow(Typesett
ing:-mn(\"3\", mathvariant = \"normal\"), Typesetting:-mo(\"&Invisible
Times;\", mathvariant = \"normal\", fence = \"false\", separator = \"f
alse\", stretchy = \"false\", symmetric = \"false\", largeop = \"false
\", movablelimits = \"false\", accent = \"false\", lspace = \"0.0em\",
 rspace = \"0.0em\"), Typesetting:-mi(\"Pi\", italic = \"false\", math
variant = \"normal\")), Typesetting:-mi(\"\", italic = \"true\", execu
table = \"true\", font_style_name = \"2D Input\", mathvariant = \"ital
ic\")), rowalign = \"\", columnalign = \"\", groupalign = \"\", rowspa
n = \"1\", columnspan = \"1\"), Typesetting:-mtd(Typesetting:-mrow(Typ
esetting:-mi(\"\", italic = \"true\", executable = \"true\", font_styl
e_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Ty
pesetting:-mn(\"3\", mathvariant = \"normal\"), Typesetting:-mo(\"&Inv
isibleTimes;\", mathvariant = \"normal\", fence = \"false\", separator
 = \"false\", stretchy = \"false\", symmetric = \"false\", largeop = \+
\"false\", movablelimits = \"false\", accent = \"false\", lspace = \"0
.0em\", rspace = \"0.0em\"), Typesetting:-mi(\"Pi\", italic = \"false
\", mathvariant = \"normal\")), Typesetting:-mo(\"&le;\", mathvariant \+
= \"normal\", fence = \"false\", separator = \"false\", stretchy = \"f
alse\", symmetric = \"false\", largeop = \"false\", movablelimits = \"
false\", accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.27
77778em\"), Typesetting:-mi(\"x\", italic = \"true\", mathvariant = \"
italic\")), rowalign = \"\", columnalign = \"\", groupalign = \"\", ro
wspan = \"1\", columnspan = \"1\"), rowalign = \"\", columnalign = \"
\", groupalign = \"\"), align = \"axis\", rowalign = \"baseline\", col
umnalign = \"center\", groupalign = \"\{left\}\", alignmentscope = \"t
rue\", columnwidth = \"auto\", width = \"auto\", rowspacing = \"1.0ex
\", columnspacing = \"2em\", rowlines = \"none\", columnlines = \"none
\", frame = \"none\", framespacing = \"0.4em 0.5ex\", equalrows = \"fa
lse\", equalcolumns = \"false\", displaystyle = \"false\", side = \"ri
ght\", minlabelspacing = \"0.8em\"), Typesetting:-mi(\"\", italic = \"
true\", executable = \"true\", font_style_name = \"2D Input\", mathvar
iant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", executab
le = \"true\", font_style_name = \"2D Input\", mathvariant = \"italic
\")), Typesetting:-mi(\"\", italic = \"true\", executable = \"true\", \+
font_style_name = \"2D Input\", mathvariant = \"italic\"));" "-I%mrowG
6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#miGF$6'Q!F'/%'italic
GQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~InputF'/%,mathvariant
GQ'italicF'-F#6'F+-F#6%-F,6%Q\"gF'F/F7-I#moGF$6-Q0&ApplyFunction;F'/F8
Q'normalF'/%&fenceGQ&falseF'/%*separatorGFI/%)stretchyGFI/%*symmetricG
FI/%(largeopGFI/%.movablelimitsGFI/%'accentGFI/%'lspaceGQ&0.0emF'/%'rs
paceGFX-I(mfencedGF$6$-F#6#-F,6%Q\"xF'F/F7FE-FB6-Q\"=F'FEFGFJFLFNFPFRF
T/FWQ,0.2777778emF'/FZFao-F#6%-FB6-Q\"|frF'FE/FHF1FJ/FMF1FNFPFRFT/FWQ,
0.1666667emF'/FZF[p-I'mtableGF$67-I$mtrGF$6'-I$mtdGF$6(-F#6&F+-F#6#-I%
msupGF$6%Fjn-I#mnGF$6$Q\"2F'FE/%1superscriptshiftGQ\"0F'-FB6-Q\"+F'FEF
GFJFLFNFPFRFT/FWQ,0.2222222emF'/FZFhqFjn/%)rowalignGF./%,columnalignGF
./%+groupalignGF./%(rowspanGQ\"1F'/%+columnspanGFbr-Fdp6(-F#6%Fjn-FB6-
Q%&le;F'FEFGFJFLFNFPFRFTF`oFbo-F^q6$FcqFEFjqF\\rF^rF`rFcrFjqF\\rF^r-Fa
p6'-Fdp6(-F#6%-F,6%Q$sinF'/F0FIFEFAFenFjqF\\rF^rF`rFcr-Fdp6(-F#6&Fjn-F
B6-Q\"<F'FEFGFJFLFNFPFRFTF`oFbo-F#6%-F^q6$Q\"3F'FE-FB6-Q1&InvisibleTim
es;F'FEFGFJFLFNFPFRFTFVFY-F,6%Q#PiF'FgsFEF+FjqF\\rF^rF`rFcrFjqF\\rF^r-
Fap6'-Fdp6(-F#6-F+Fhp-FB6-Q(&minus;F'FEFGFJFLFNFPFRFTFgqFiq-F#6'-F^q6$
Q\"6F'FEFdtFgtFdtFjnFdq-F#6&-F^q6$Q\"9F'FEFdt-F#6#-F[q6%FgtF]qFaqF+F`u
FjnFdqF_tF+FjqF\\rF^rF`rFcr-Fdp6(-F#6&F+F_tFirFjnFjqF\\rF^rF`rFcrFjqF
\\rF^r/%&alignGQ%axisF'/F[rQ)baselineF'/F]rQ'centerF'/F_rQ'|frleft|hrF
'/%/alignmentscopeGF1/%,columnwidthGQ%autoF'/%&widthGFbw/%+rowspacingG
Q&1.0exF'/%.columnspacingGQ$2emF'/%)rowlinesGQ%noneF'/%,columnlinesGF]
x/%&frameGF]x/%-framespacingGQ,0.4em~0.5exF'/%*equalrowsGFI/%-equalcol
umnsGFI/%-displaystyleGFI/%%sideGQ&rightF'/%0minlabelspacingGQ&0.8emF'
F+F+F+" }{TEXT 377 0 "" }}{PARA 0 "" 0 "" {TEXT 371 48 "Here is a proc
edure that computes this function." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "g := proc(x)\n" }{MPLTEXT 1 0 17 "  if x <= 0 then\n"
 }{MPLTEXT 1 0 12 "    x^2 + x\n" }{MPLTEXT 1 0 7 "  else\n" }{MPLTEXT
 1 0 21 "    if x < 3*Pi then\n" }{MPLTEXT 1 0 13 "      sin(x)\n" }
{MPLTEXT 1 0 9 "    else\n" }{MPLTEXT 1 0 31 "      x^2-6*x*Pi+9*Pi^2-
x+3*Pi\n" }{MPLTEXT 1 0 7 "    fi\n" }{MPLTEXT 1 0 5 "  fi\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{PARA 0 "" 0 "" {TEXT 371 121 "This procedure uses a conditional st
atement as the body of the else-part of another conditional statement.
 We call these " }{TEXT 334 29 "nested conditional statements" }{TEXT 
371 510 ". Notice three things. First, notice how three levels of inde
ntation are used to help show the structure of the procedure body, in \+
particular, the way the second conditional statement is the else-part \+
of the first conditional statement. Second, there are only two boolean
 expressions even though there are three pieces of the function. The t
hird piece of the function acts as the \"default\" piece and it applie
s whenever the first two pieces do not. Third, notice how the second b
oolean expression does not say " }{TEXT 0 8 "0<x<3*Pi" }{TEXT 371 406 
" (as it would probably be written in a mathematics book). There are t
wo reasons for not writing the boolean expression this way. First, it \+
is syntactically incorrect in Maple (see the next section for more abo
ut the syntax of boolean expressions). Secondly, it is partially redun
dant with the first boolean expression. Since we are in the else-part \+
of the first (outer) conditional statement, we know that " }{TEXT 0 4 
"x<=0" }{TEXT 371 30 " is false, so it must be that " }{TEXT 0 1 "x" }
{TEXT 371 80 " is positive, so there is no need to have the boolean ex
pression check again if " }{TEXT 0 3 "0<x" }{TEXT 371 1 "." }}{PARA 0 
"" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 27 " Let us plot th
is function." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "plot( g, -3.
.3*Pi+3 );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "
" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 335 8 "Exercise" }{TEXT 
371 54 ": Why was the right hand endpoint of this plot set to " }{TEXT
 0 6 "3*Pi+3" }{TEXT 371 36 "? If we make the left hand endpoint " }
{TEXT 0 2 "-4" }{TEXT 371 83 ", what would be a good choice for the ri
ght hand endpoint? What would the graph of " }{TEXT 0 1 "g" }{TEXT 
371 75 " look like if we graphed it over a large domain, say from -100
 to 100? Why?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0
 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 121 "Nested condit
ional statements are fairly common, so Maple has a special abbreviatio
n for them. Here is the definition of " }{TEXT 0 1 "g" }{TEXT 371 25 "
 using this abbreviation." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 
"g := proc( x )\n" }{MPLTEXT 1 0 17 "  if x <= 0 then\n" }{MPLTEXT 1 
0 12 "    x^2 + x\n" }{MPLTEXT 1 0 21 "  elif x < 3*Pi then\n" }
{MPLTEXT 1 0 11 "    sin(x)\n" }{MPLTEXT 1 0 7 "  else\n" }{MPLTEXT 1 
0 29 "    x^2-6*x*Pi+9*Pi^2-x+3*Pi\n" }{MPLTEXT 1 0 5 "  fi\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{PARA 0 "" 0 "" {TEXT 371 16 "This version of " }{TEXT 0 1 "g" }
{TEXT 371 10 " has only " }{TEXT 336 3 "one" }{TEXT 371 48 " condition
al statement in it (notice the single " }{TEXT 0 2 "fi" }{TEXT 371 
144 " at the end of the procedure body and the use of fewer levels of \+
indentation). There is no nesting of conditional statements in this ve
rsion of " }{TEXT 0 1 "g" }{TEXT 371 32 ". Where the previous version \+
of " }{TEXT 0 1 "g" }{TEXT 371 128 " had a conditional statement in th
e else-part of the outer if-then-else-fi statement, the abbreviated ve
rsion has an elif-part (" }{TEXT 0 4 "elif" }{TEXT 371 25 " is an abbr
eviation for \"" }{TEXT 0 2 "el" }{TEXT 371 3 "se " }{TEXT 0 2 "if" }
{TEXT 371 81 "\") followed by an else-part. This form of the condition
al statement is called an " }{TEXT 337 25 "if-then-elif-then-else-fi" 
}{TEXT 371 33 " statement. There can be as many " }{TEXT 338 9 "elif-t
hen" }{TEXT 371 251 " clauses as you want in an if-then-elif-then-else
-fi statement. For example, if we want to represent a piecewise define
d function with four pieces in its definition, then we can use two eli
f-then clauses (in a single if-then-elif-then-else statement)." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "h := proc( x )\n" }{MPLTEXT 
1 0 17 "  if x <= 1 then\n" }{MPLTEXT 1 0 6 "    x\n" }{MPLTEXT 1 0 
19 "  elif x <= 2 then\n" }{MPLTEXT 1 0 8 "    x^2\n" }{MPLTEXT 1 0 
19 "  elif x <= 3 then\n" }{MPLTEXT 1 0 8 "    6-x\n" }{MPLTEXT 1 0 7 
"  else\n" }{MPLTEXT 1 0 15 "    x^2-6*x+12\n" }{MPLTEXT 1 0 5 "  fi\n
" }{MPLTEXT 1 0 5 "end;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{PARA 0 "" 0 "" {TEXT 371 144 "When you read a conditional state
ment like this, it is important to remember that the boolean expressio
ns are \"cumulative\". So for example, the " }{TEXT 0 3 "x^2" }{TEXT 
371 28 " part is not used just when " }{TEXT 0 4 "x<=2" }{TEXT 371 16 
" is true as the " }{TEXT 0 4 "elif" }{TEXT 371 48 " clause just befor
e it might seem to imply. The " }{TEXT 0 3 "x^2" }{TEXT 371 24 " part \+
is only used when " }{TEXT 0 4 "x<=2" }{TEXT 371 9 " is true " }{TEXT 
339 3 "and" }{TEXT 371 1 " " }{TEXT 0 4 "x<=1" }{TEXT 371 24 " is fals
e. The test for " }{TEXT 0 4 "x<=2" }{TEXT 371 31 " only comes after t
he test for " }{TEXT 0 4 "x<=1" }{TEXT 371 32 " fails. Similarly, the \+
test for " }{TEXT 0 4 "x<=3" }{TEXT 371 23 " only comes after both " }
{TEXT 0 4 "x<=1" }{TEXT 371 11 " fails and " }{TEXT 0 4 "x<=2" }{TEXT 
371 16 " fails. And the " }{TEXT 0 10 "x^2-6*x+12" }{TEXT 371 46 " par
t is used only if each of the three tests " }{TEXT 0 4 "x<=1" }{TEXT 
371 2 ", " }{TEXT 0 4 "x<=2" }{TEXT 371 6 ", and " }{TEXT 0 4 "x<=3" }
{TEXT 371 10 " all fail." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 50 "Let
 us look at graphs of these last two functions." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 22 "plot( g, -3..3*Pi+3 );" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 17 "plot( h, -1..5 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 17 "The syntax for a " }{TEXT 340 25 "if-then-elif-then-else
-fi" }{TEXT 371 41 " statement should be pretty clear by now." }}
{PARA 0 "" 0 "" {TEXT 371 25 "                         " }{TEXT 0 2 "i
f" }{TEXT 371 21 "  boolean_expression " }{TEXT 0 4 "then" }}{PARA 0 "
" 0 "" {TEXT 371 56 "                              sequence_of_Maple_c
ommands" }}{PARA 0 "" 0 "" {TEXT 371 25 "                         " }
{TEXT 0 4 "elif" }{TEXT 371 1 " " }{TEXT 341 18 "boolean expression" }
{TEXT 371 1 " " }{TEXT 0 4 "then" }}{PARA 0 "" 0 "" {TEXT 371 30 "    \+
                          " }{TEXT 342 26 "sequence_of_Maple_commands"
 }}{PARA 0 "" 0 "" {TEXT 371 25 "                         " }{TEXT 0 
4 "else" }}{PARA 0 "" 0 "" {TEXT 371 30 "                             \+
 " }{TEXT 343 26 "sequence_of_Maple_commands" }}{PARA 0 "" 0 "" {TEXT 
371 25 "                         " }{TEXT 0 2 "fi" }}{PARA 0 "" 0 "" 
{TEXT 371 105 "Remember that there can be as many elif-then clauses as
 needed in this form of the conditional statement." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0
 "" 0 "" {TEXT 371 209 "The next example shows how we might need two i
f-then-else-fi statements nested inside of an if-then-else-fi statemen
t, one in each of the then and else parts. This procedure finds the la
rgest of three numbers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "b
igger3 := proc( a, b, c )\n" }{MPLTEXT 1 0 18 "  if a >= b then \n" }
{MPLTEXT 1 0 33 "    if a >= c then a else b fi; \n" }{MPLTEXT 1 0 9 "
  else  \n" }{MPLTEXT 1 0 33 "    if b >= c then b else c fi; \n" }
{MPLTEXT 1 0 6 "  fi;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 23 "Try this procedure out." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "bigger3( 1, 2, 3 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "bigger3( 3, 2, 1 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "bigger3( 1, 3, 2 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 29 "This procedure coul
d use the " }{TEXT 0 4 "elif" }{TEXT 371 132 " abbreviation for one of
 the nested conditional statements, but that probably would not make t
he procedure any easier to understand." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 344 8 "Exercise" }{TEXT 371 24 ": Rewrite the procedure " }{TEXT
 0 7 "bigger3" }{TEXT 371 57 " using an elif-clause in the outer condi
tional statement." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 34 "There i
s another way to implement " }{TEXT 0 7 "bigger3" }{TEXT 371 50 ". Thi
s version uses nested calls to our procedure " }{TEXT 0 6 "bigger" }
{TEXT 371 56 " instead of nested conditional statements. (Recall that 
" }{TEXT 0 6 "bigger" }{TEXT 371 52 " was defined at the very beginnin
g of this section.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "bigge
r3 := proc(a, b, c)\n" }{MPLTEXT 1 0 30 "   bigger( bigger(a, b), c );
\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 144 "This is
 a common technique in programming. Use one procedure as part of the d
efinition of another procedure.  If we compare the two versions of " }
{TEXT 0 7 "bigger3" }{TEXT 371 31 ", notice how the inner call to " }
{TEXT 0 6 "bigger" }{TEXT 371 79 " plays the same role as the outer co
nditional statement, and the outer call to " }{TEXT 0 6 "bigger" }
{TEXT 371 19 " plays the role of " }{TEXT 345 4 "both" }{TEXT 371 34 "
 the inner conditional statements." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "bigger3(-3, 4, 2);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 371 31 "We can also create a procedure " }{TEXT 0 7 "bigger4" }
{TEXT 371 158 " that finds the largest of four numbers. We can do this
 two ways, one way using nested conditional statements and another way
 using nested procedure calls to " }{TEXT 0 7 "bigger3" }{TEXT 371 8 "
 and/or " }{TEXT 0 6 "bigger" }{TEXT 371 46 ". The nested conditional \+
statement version of " }{TEXT 0 7 "bigger4" }{TEXT 371 85 " will be qu
ite messy but you should try writing it. Here are several ways of writ
ing " }{TEXT 0 7 "bigger4" }{TEXT 371 30 " using nested procedure call
s." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "bigger4 := proc(a, b, \+
c, d)\n" }{MPLTEXT 1 0 41 "   bigger( bigger(a, b), bigger(c, d) );\n"
 }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "bigger4 := proc(a, b, c, d)\n" }
{MPLTEXT 1 0 42 "   bigger( bigger( bigger(a, b), c ), d);\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "bigger4 := proc(a, b, c, d)\n" }
{MPLTEXT 1 0 34 "   bigger( bigger3(a, b, c), d );\n" }{MPLTEXT 1 0 5 
"end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 45 "There are still several othe
r ways of making " }{TEXT 0 7 "bigger4" }{TEXT 371 8 " out of " }{TEXT
 0 6 "bigger" }{TEXT 371 5 " and " }{TEXT 0 7 "bigger3" }{TEXT 371 16 
". What are they?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 346 8 "Exercise
" }{TEXT 371 21 ": Write a version of " }{TEXT 0 7 "bigger4" }{TEXT 
371 46 " that uses only nested conditional statements." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 347 8 "Exercise" }{TEXT 371 21 ": Write a vers
ion of " }{TEXT 0 7 "bigger4" }{TEXT 371 67 " that uses procedure call
s nested inside of conditional statements." }}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 ""
 {TEXT 371 267 "For the sake of completeness, what about finding the m
aximum of an arbitrary number of numbers. This is like our problem of \+
finding the average of an arbitrary number of numbers. We solve it by \+
using a list (which is a data structure) as the input to our procedure
.  " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "biggest := proc( list
::list(numeric) ) # Type check the input.\n" }{MPLTEXT 1 0 22 "  local
 candidate, i;\n" }{MPLTEXT 1 0 50 "  candidate := list[1];  # Make an
 initial guess.\n" }{MPLTEXT 1 0 32 "  for i from 2 to nops(list) do\n
" }{MPLTEXT 1 0 32 "    if list[i] > candidate then\n" }{MPLTEXT 1 0 
48 "      candidate := list[i]; # Update our guess.\n" }{MPLTEXT 1 0 
8 "    fi;\n" }{MPLTEXT 1 0 6 "  od;\n" }{MPLTEXT 1 0 41 "  candidate;
  # Return our final answer.\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 ""
 0 "" {TEXT 371 15 "Now try it out." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "biggest( [1,2,3,4,5,100,6] );" }}}{PARA 0 "" 0 "" 
{TEXT 371 67 "Let us test our procedure on a randomly generated list o
f integers." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "random_list_o
f_integers := [ seq( rand(), i=1..12 ) ];" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 35 "biggest( random_list_of_integers );" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 348 8 "Exercise" }{TEXT 371 27 ": Change the d
efinition of " }{TEXT 0 7 "biggest" }{TEXT 371 28 " to use a call to p
rocedure " }{TEXT 0 6 "bigger" }{TEXT 371 30 " in place of the if-stat
ement." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "
" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 349 8 "Exercise" }{TEXT 371 
66 ": If you read the optional section on the special local variables 
" }{TEXT 0 4 "args" }{TEXT 371 5 " and " }{TEXT 0 5 "nargs" }{TEXT 
371 26 ", then write a version of " }{TEXT 0 7 "biggest" }{TEXT 371 
55 " that does not need the brackets in its procedure call." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 1 {PARA 3 "" 0 
"" {TEXT 370 25 "17.5. Boolean expressions" }}{PARA 0 "" 0 "" {TEXT 
371 209 "Boolean expression are used mostly with while-loops and condi
tional statements. In this section we will look at more examples that \+
use boolean expressions and we will define the syntax for boolean expr
essions." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 
371 31 "Recall our first definition of " }{TEXT 0 7 "bigger3" }{TEXT 
371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "bigger3 := proc(
 a, b, c )\n" }{MPLTEXT 1 0 18 "  if a >= b then \n" }{MPLTEXT 1 0 33 
"    if a >= c then a else b fi; \n" }{MPLTEXT 1 0 9 "  else  \n" }
{MPLTEXT 1 0 33 "    if b >= c then b else c fi; \n" }{MPLTEXT 1 0 6 "
  fi;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 32 "Her
e is another way to write it." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "bigger3 := proc( a, b, c )\n" }{MPLTEXT 1 0 29 "  if a >= b and \+
a >= c then \n" }{MPLTEXT 1 0 8 "    a; \n" }{MPLTEXT 1 0 31 "  elif b
 >= a and b >= c then \n" }{MPLTEXT 1 0 7 "    b;\n" }{MPLTEXT 1 0 7 "
  else\n" }{MPLTEXT 1 0 7 "    c;\n" }{MPLTEXT 1 0 6 "  fi;\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 371 25 "Try this new \+
version out." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "bigger3(1, 2
, 3);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "bigger3(3, 2, 1);"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "bigger3(1, 3, 2);" }}}
{PARA 0 "" 0 "" {TEXT 371 190 "The new version uses a single condition
al statement (with an elif-part) and it uses a more sophisticated kind
 of boolean expression. Let us define several terms used with boolean \+
expression." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "
" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 63 "Boolean expressi
ons are expressions that evaluate to be either " }{TEXT 0 4 "true" }
{TEXT 371 4 " or " }{TEXT 0 5 "false" }{TEXT 371 19 ". We will say tha
t " }{TEXT 0 4 "true" }{TEXT 371 5 " and " }{TEXT 0 5 "false" }{TEXT 
371 22 " are the two possible " }{TEXT 350 14 "boolean values" }{TEXT 
371 212 ". Boolean expressions can be contrasted with arithmetic (or a
lgebraic) expressions which are expressions that evaluate to a number.
 Just as arithmetic expressions are made up of basic arithmetic operat
ors (e.g., " }{TEXT 0 1 "+" }{TEXT 371 2 ", " }{TEXT 0 1 "-" }{TEXT 
371 2 ", " }{TEXT 0 1 "*" }{TEXT 371 2 ", " }{TEXT 0 1 "/" }{TEXT 371 
2 ", " }{TEXT 0 1 "^" }{TEXT 371 68 ") and functions that return a num
ber (i.e., real valued functions), " }{TEXT 351 19 "boolean expression
s" }{TEXT 371 26 " are made up of the three " }{TEXT 352 17 "logical o
perators" }{TEXT 371 2 " (" }{TEXT 0 3 "and" }{TEXT 371 2 ", " }{TEXT 
0 2 "or" }{TEXT 371 2 ", " }{TEXT 0 3 "not" }{TEXT 371 7 "), the " }
{TEXT 353 20 "relational operators" }{TEXT 371 2 " (" }{TEXT 0 1 "<" }
{TEXT 371 2 ", " }{TEXT 0 2 "<=" }{TEXT 371 2 ", " }{TEXT 0 1 ">" }
{TEXT 371 2 ", " }{TEXT 0 2 ">=" }{TEXT 371 2 ", " }{TEXT 0 1 "=" }
{TEXT 371 2 ", " }{TEXT 0 2 "<>" }{TEXT 371 29 "), and functions that \+
return " }{TEXT 0 4 "true" }{TEXT 371 4 " or " }{TEXT 0 5 "false" }
{TEXT 371 8 " (i.e., " }{TEXT 354 17 "boolean functions" }{TEXT 371 
112 "). We have already mentioned the relational operators and we have
 seen examples of using boolean functions like " }{TEXT 0 7 "isprime" 
}{TEXT 371 56 ". But we have not mentioned the basic logical operators
 " }{TEXT 0 3 "and" }{TEXT 371 2 ", " }{TEXT 0 2 "or" }{TEXT 371 6 " ,
and " }{TEXT 0 3 "not" }{TEXT 371 30 ", so we will go over them now." 
}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 8 "We cal
l " }{TEXT 0 3 "and" }{TEXT 371 5 " and " }{TEXT 0 2 "or" }{TEXT 371 
1 " " }{TEXT 355 24 "binary boolean operators" }{TEXT 371 13 " and we \+
call " }{TEXT 0 3 "not" }{TEXT 371 3 " a " }{TEXT 356 22 "unary boolea
n operator" }{TEXT 371 67 ". A binary operator is an operator that act
s on two operands (like " }{TEXT 0 1 "+" }{TEXT 371 2 ", " }{TEXT 0 1 
"-" }{TEXT 371 2 ", " }{TEXT 0 1 "*" }{TEXT 371 2 ", " }{TEXT 0 1 "/" 
}{TEXT 371 6 ", and " }{TEXT 0 1 "^" }{TEXT 371 62 ") with one operand
 placed on either side of the operator. But " }{TEXT 0 1 "+" }{TEXT 
371 2 ", " }{TEXT 0 1 "-" }{TEXT 371 2 ", " }{TEXT 0 1 "*" }{TEXT 371 
2 ", " }{TEXT 0 1 "/" }{TEXT 371 6 ", and " }{TEXT 0 1 "^" }{TEXT 371 
110 " are arithmetic operators that operate on numbers, and the result
 that they return is a number. The operators " }{TEXT 0 3 "and" }{TEXT
 371 5 " and " }{TEXT 0 2 "or" }{TEXT 371 348 " operate on boolean val
ues and return a boolean value, so they are boolean operators. A unary
 operator acts on only one operand which is sometimes placed before th
e operator and sometimes placed after the operator (placing the operan
d after the unary operator symbol is more common). A common example of
 a unary operator is the arithmetic operator " }{TEXT 0 1 "-" }{TEXT 
371 59 " for negation (not to be confused with the binary operator " }
{TEXT 0 1 "-" }{TEXT 371 102 " for subtraction) which is place before \+
the operand. Another unary operator is the factorial operator " }{TEXT
 0 1 "!" }{TEXT 371 40 " which is placed after its operand. The " }
{TEXT 0 3 "not" }{TEXT 371 47 " operator is placed before its boolean \+
operand." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0
 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 191 "Since boolean oper
ators operate on boolean values, and there are only two boolean values
, it is possible to make a table of a boolean operator's value for eve
ry possible input. We call these " }{TEXT 357 12 "truth tables" }{TEXT
 371 30 ". Here is the truth table for " }{TEXT 0 2 "or" }{TEXT 371 1 
"." }}{PARA 0 "" 0 "" {TEXT 371 58 "                                  \+
                        " }{TEXT 0 1 "x" }{TEXT 371 13 "             "
 }{TEXT 0 1 "y" }{TEXT 371 7 "       " }{TEXT 0 2 " x" }{TEXT 371 1 " 
" }{TEXT 0 2 "or" }{TEXT 371 1 " " }{TEXT 0 1 "y" }{TEXT 371 0 "" }}
{PARA 0 "" 0 "" {TEXT 371 52 "                                        \+
            " }{TEXT 0 5 "false" }{TEXT 371 5 "  |  " }{TEXT 0 5 "fals
e" }{TEXT 371 5 "  |  " }{TEXT 0 5 "false" }}{PARA 0 "" 0 "" {TEXT 
371 52 "                                                    " }{TEXT 
0 5 "false" }{TEXT 371 5 "  |  " }{TEXT 0 4 "true" }{TEXT 371 8 "     \+
|  " }{TEXT 0 4 "true" }}{PARA 0 "" 0 "" {TEXT 371 52 "               \+
                                     " }{TEXT 0 5 " true" }{TEXT 371 
5 "  |  " }{TEXT 0 5 "false" }{TEXT 371 5 "  |  " }{TEXT 0 4 "true" }}
{PARA 0 "" 0 "" {TEXT 371 54 "                                        \+
              " }{TEXT 0 4 "true" }{TEXT 371 6 "   |  " }{TEXT 0 4 "tr
ue" }{TEXT 371 7 "    |  " }{TEXT 0 4 "true" }{TEXT 371 1 " " }}{PARA 
0 "" 0 "" {TEXT 371 28 "Here is the truth table for " }{TEXT 0 3 "and"
 }{TEXT 371 1 "." }}{PARA 0 "" 0 "" {TEXT 371 58 "                    \+
                                      " }{TEXT 0 1 "x" }{TEXT 371 13 "
             " }{TEXT 0 1 "y" }{TEXT 371 7 "       " }{TEXT 0 2 " x" }
{TEXT 371 1 " " }{TEXT 0 3 "and" }{TEXT 371 1 " " }{TEXT 0 1 "y" }}
{PARA 0 "" 0 "" {TEXT 371 52 "                                        \+
            " }{TEXT 0 5 "false" }{TEXT 371 5 "  |  " }{TEXT 0 5 "fals
e" }{TEXT 371 5 "  |  " }{TEXT 0 5 "false" }}{PARA 0 "" 0 "" {TEXT 
371 52 "                                                    " }{TEXT 
0 5 "false" }{TEXT 371 5 "  |  " }{TEXT 0 4 "true" }{TEXT 371 8 "     \+
|  " }{TEXT 0 5 "false" }}{PARA 0 "" 0 "" {TEXT 371 54 "              \+
                                        " }{TEXT 0 4 "true" }{TEXT 
371 5 "  |  " }{TEXT 0 5 "false" }{TEXT 371 6 "   |  " }{TEXT 0 5 "fal
se" }}{PARA 0 "" 0 "" {TEXT 371 54 "                                  \+
                    " }{TEXT 0 4 "true" }{TEXT 371 5 "  |  " }{TEXT 0 
4 "true" }{TEXT 371 9 "      |  " }{TEXT 0 4 "true" }{TEXT 371 1 " " }
}{PARA 0 "" 0 "" {TEXT 371 28 "Here is the truth table for " }{TEXT 0 
3 "not" }{TEXT 371 1 "." }}{PARA 0 "" 0 "" {TEXT 371 60 "             \+
                                               " }{TEXT 0 1 "x" }{TEXT
 371 10 "          " }{TEXT 0 3 "not" }{TEXT 371 1 " " }{TEXT 0 1 "x" 
}}{PARA 0 "" 0 "" {TEXT 371 55 "                                      \+
                 " }{TEXT 0 5 "false" }{TEXT 371 6 "  |   " }{TEXT 0 
4 "true" }}{PARA 0 "" 0 "" {TEXT 371 55 "                             \+
                          " }{TEXT 0 4 "true" }{TEXT 371 9 "    |    "
 }{TEXT 0 5 "false" }}{PARA 0 "" 0 "" {TEXT 371 63 "We can verify some
 of these entries with simple Maple commands." }}{EXCHG {PARA 0 "> " 0
 "" {MPLTEXT 1 0 15 "false and true;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "true or false;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "not false;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 358 8 "Exercise
" }{TEXT 371 73 ": Here are several examples of boolean expressions. E
xplain their values." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "ispr
ime(7) and not 7<5;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "memb
er(d, [a, b, [c,d]]) or a=b;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 30 "has([a, b, [c,d]], d) and 7<5;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "(1/3 + 1/3 = 2/3) and type(a+b, algebraic);" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "true <> false or 0!=1;" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "not(x=y) and 0>-infinity;" }
}}{PARA 0 "" 0 "" {TEXT 371 81 "Note: The parentheses in the last exam
ple are not part of a function call since  " }{TEXT 0 3 "not" }{TEXT 
371 58 " is not a function. The parentheses are for grouping, and " }
{TEXT 0 8 "not(x=y)" }{TEXT 371 53 " should be thought of like the ari
thmetic expression " }{TEXT 0 6 "-(x+y)" }{TEXT 371 19 " (recall that \+
both " }{TEXT 0 3 "not" }{TEXT 371 35 " and negation are unary operato
rs)." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 359 8 "Exercise" }{TEXT 371 17 
": The expression " }{TEXT 0 6 "-(x+y)" }{TEXT 371 16 " is the same as
 " }{TEXT 0 9 "(-x)+(-y)" }{TEXT 371 5 ". Is " }{TEXT 0 8 "not(x=y)" }
{TEXT 371 13 " the same as " }{TEXT 0 15 "(not x)=(not y)" }{TEXT 371 
1 "?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 360 8 "Exercise" }{TEXT 371 
196 ": Give examples of some other binary operators in Maple. Give exa
mples of some other unary operators. For your examples, specify the da
ta type of the operands and the return value of the operator." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 122 "Notice that the following is
 not a boolean expression in Maple, though it would be a true statemen
t in a mathematics book." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "
3 <= 4 <= 5;" }}}{PARA 0 "" 0 "" {TEXT 371 58 "Here is how the last ex
ample should be expressed in Maple." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "3 <= 4 and 4 <= 5;" }}}{PARA 0 "" 0 "" {TEXT 371 47 "
Similarly we cannot say the following in Maple." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 12 "1 = 0! = 1!;" }}}{PARA 0 "" 0 "" {TEXT 371 32 "
Instead we must put it this way." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "1 = 0! and 0! = 1!;" }}}{PARA 0 "" 0 "" {TEXT 371 63 "This las
t result may seem surprising. We were expecting to get " }{TEXT 0 4 "t
rue" }{TEXT 371 75 ". For example, if we modify the expression just a \+
bit, then it does return " }{TEXT 0 4 "true" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "1 = 0! and 2 = 2!;" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 58 "Let us analyze how Maple eval
uates the boolean expression " }{TEXT 0 14 "1=0! and 0!=1!" }{TEXT 
371 87 ", since it brings up an important fact about equations and boo
lean expressions.  Since " }{TEXT 0 2 "0!" }{TEXT 371 14 " evaluates t
o " }{TEXT 0 1 "1" }{TEXT 371 67 ", Maple evaluates (using the rule of
 full evaluation) the equation " }{TEXT 0 4 "1=0!" }{TEXT 371 20 " to \+
be the equation " }{TEXT 0 3 "1=1" }{TEXT 371 16 ". Similarly for " }
{TEXT 0 5 "0!=1!" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 5 "1=0!;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "0!=1!;" }}}
{PARA 0 "" 0 "" {TEXT 371 18 "So the expression " }{TEXT 0 14 "1=0! an
d 0!=1!" }{TEXT 371 14 " evaluates to " }{TEXT 0 11 "1=1 and 1=1" }
{TEXT 371 53 ". Then Maple automatically simplifies the expression " }
{TEXT 0 11 "1=1 and 1=1" }{TEXT 371 7 " to be " }{TEXT 0 3 "1=1" }
{TEXT 371 17 " (the expression " }{TEXT 0 7 "x and x" }{TEXT 371 29 " \+
automatically simplifies to " }{TEXT 0 1 "x" }{TEXT 371 20 " for any e
xpression " }{TEXT 0 1 "x" }{TEXT 371 9 " (why?))." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 8 "x and x;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "1=1 and 1=1;" }}}{PARA 0 "" 0 "" {TEXT 371 26 "But wh
y does the equation " }{TEXT 0 3 "1=1" }{TEXT 371 17 " not evaluate to
 " }{TEXT 0 4 "true" }{TEXT 371 191 ", since it certainly is true? The
 reason has to do with a dual role that equations (and inequalities) p
lay in Maple. Equations are used both as boolean expressions and as al
gebraic equations." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "type(1
=1, boolean);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "type(1=1, \+
equation);" }}}{PARA 0 "" 0 "" {TEXT 371 148 "For example, it would be
 very inconvenient if Maple would take an equation like the following \+
and automatically evaluate it as a boolean expression." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "a*x^2+b*x+c=0;" }}}{PARA 0 "" 0 "" 
{TEXT 371 180 "Of course, the above equation is a boolean expression, \+
but that is usually not what we have in mind when we type it in. Here \+
is how Maple would evaluate it as a boolean expression." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "evalb( % );" }}}{PARA 0 "" 0 "" 
{TEXT 371 217 "Since equations in their role as algebraic equations ar
e so common, Maple has a rule that it will not evaluate an isolated eq
uation (or inequality) as a boolean expression unless explicitly told \+
to do so by using the " }{TEXT 0 5 "evalb" }{TEXT 371 253 " command. B
ut if an equation (or inequality) is part of a larger boolean expressi
on, or contained in the boolean part of a while-loop or conditional st
atement, then Maple will automatically evaluate the equation (or inequ
ality) as a boolean expression. " }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}
{PARA 0 "" 0 "" {TEXT 371 50 "So now we know why Maple evaluates the e
xpression " }{TEXT 0 13 "1=0! and 2=2!" }{TEXT 371 4 " as " }{TEXT 0 
4 "true" }{TEXT 371 41 " but it evaluates the similar expression " }
{TEXT 0 14 "1=0! and 0!=1!" }{TEXT 371 4 " as " }{TEXT 0 3 "1=1" }
{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "1=0! and 2
=2!;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "1=0! and 0!=1!;" }}
}{PARA 0 "" 0 "" {TEXT 371 27 "Even though the expression " }{TEXT 0 
14 "1=0! and 0!=1!" }{TEXT 371 207 " starts out as a boolean expressio
n, it automatically simplifies to an equation, and Maple will not eval
uate this isolated equation as a boolean expression unless we explicit
ly tell it to do so by using the " }{TEXT 0 5 "evalb" }{TEXT 371 9 " c
ommand." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "'evalb'( 1=0! and
 0!=1! );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "%;" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 371 159 "Parentheses play an important role in
 boolean expressions just as they do in arithmetic expressions. For ex
ample, the following two expressions are equivalent." }}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 12 "x = y and z;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "(x = y) and z;" }}}{PARA 0 "" 0 "" {TEXT 371 51 "But \+
they are not equivalent to the next expression." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 14 "x = (y and z);" }}}{PARA 0 "" 0 "" {TEXT 371 
67 "(Why did Maple not evaluate this last expression as true or false?
)" }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 329 "T
here is a whole algebra to boolean expressions that specifies the orde
r of precedence for all of the boolean operations, associativity rules
 for each boolean operation, and algebraic identities for boolean expr
essions. For example, here are some automatic simplifications that Map
le knows for the algebra of boolean expressions." }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 11 "false or x;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 11 "true and x;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 7 "x or x;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "x and x;" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "not not x;" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "(not x) or (not y);" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "(not x) and (not y);" }}}{PARA 0 ""
 0 "" {TEXT 371 59 "The last two simplifications are known as DeMorgan
's Rules." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 
0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 128 "Most of the boole
an expressions that we need for conditional statements and while-loops
 are formed using simple combinations of " }{TEXT 0 3 "and" }{TEXT 
371 2 ", " }{TEXT 0 2 "or" }{TEXT 371 2 ", " }{TEXT 0 3 "not" }{TEXT 
371 61 ", the relational operators, and a few boolean functions like "
 }{TEXT 0 4 "type" }{TEXT 371 2 ", " }{TEXT 0 7 "isprime" }{TEXT 371 
2 ", " }{TEXT 0 3 "has" }{TEXT 371 6 ", and " }{TEXT 0 6 "member" }
{TEXT 371 83 ". So we will not got into any more detail about the alge
bra of boolean expressions." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}}{SECT 0 {PARA 0 "" 0 "" {TEXT 371 19 "The three \+
commands " }{TEXT 0 3 "seq" }{TEXT 371 2 ", " }{TEXT 0 3 "add" }{TEXT 
371 6 ", and " }{TEXT 0 4 "prod" }{TEXT 371 150 " act very much like f
or-loops. In a sense they are abbreviations of special purpose for-loo
ps. Let us look at a few examples of each of these commands" }}{PARA 0
 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 17 "We have seen t
he " }{TEXT 0 3 "seq" }{TEXT 371 79 " command before. It is used to cr
eate expression sequences. Here is an example." }}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 27 "seq( ifactor(n), n=1..10 );" }}}{PARA 0 "" 0 "" 
{TEXT 371 52 "Compare this last command to the following for-loop." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "for n from 1 to 10 do ifacto
r( n ) od;" }}}{PARA 0 "" 0 "" {TEXT 371 60 "Both commands did roughly
 the same thing. An index variable " }{TEXT 0 1 "n" }{TEXT 371 58 " wa
s incremented, in steps of 1, from an initial value of " }{TEXT 0 1 "1
" }{TEXT 371 21 " to a final value of " }{TEXT 0 2 "10" }{TEXT 371 56 
" and for each value of the index variable the procedure " }{TEXT 0 
10 "ifactor(n)" }{TEXT 371 73 " was evaluated. The main difference bet
ween the two commands is that the " }{TEXT 0 3 "seq" }{TEXT 371 182 " \+
command produced one result, an expression sequence, but the for-loop \+
produced 10 separate results. Here is a way to rewrite the for-loop so
 that it produces an expression sequence." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "result := NULL:  # Start with an empty exprseq.\n" }
{MPLTEXT 1 0 23 "for n from 1 to 10 do \n" }{MPLTEXT 1 0 67 "  result \+
:= result, ifactor(n) # Append an operand to the exprseq.\n" }{MPLTEXT
 1 0 4 "od:\n" }{MPLTEXT 1 0 35 "result;  # Show the final exprseq.\n"
 }}}{PARA 0 "" 0 "" {TEXT 371 137 "Except for the fact that this execu
tion group needed to use an extra variable, the execution group produc
es the same result as the above " }{TEXT 0 3 "seq" }{TEXT 371 10 " com
mand. " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "
" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 84 "Here is another examp
le. This produces, more or less, one line of Pascal's triangle." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "seq( op(1,n), n=expand((a+b)
^12) );" }}}{PARA 0 "" 0 "" {TEXT 371 231 "In this case, instead of th
e index variable counting from an initial value to a final value, the \+
index variable steps through the operands of a data structure. The fol
lowing for-in-loop produces the same expression sequence as the " }
{TEXT 0 3 "seq" }{TEXT 371 9 " command." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "result := NULL:\n" }{MPLTEXT 1 0 32 "for n in expand(
 (a+b)^12 ) do \n" }{MPLTEXT 1 0 28 "  result := result, op(1,n)\n" }
{MPLTEXT 1 0 4 "od:\n" }{MPLTEXT 1 0 8 "result;\n" }}}{PARA 0 "" 0 "" 
{TEXT 371 44 "Notice how much more clear it is to use the " }{TEXT 0 
3 "seq" }{TEXT 371 54 " command. Besides being easier to read and writ
e, the " }{TEXT 0 3 "seq" }{TEXT 371 171 " command is also more comput
ationally efficient than the equivalent for-loop. The for-loop produce
s a lot of intermediate results (which we hide by using a colon) but t
he " }{TEXT 0 3 "seq" }{TEXT 371 87 " command is implemented in a way \+
that avoids all the intermediate expression sequences." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" 
}}{PARA 0 "" 0 "" {TEXT 371 23 "Now let us turn to the " }{TEXT 0 3 "a
dd" }{TEXT 371 66 " command. The following command will add up the fir
st ten squares." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "add( n^2,
 n=1..10 );" }}}{PARA 0 "" 0 "" {TEXT 371 38 "This can also be done wi
th a for-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "result := \+
0:\n" }{MPLTEXT 1 0 22 "for n from 1 to 10 do\n" }{MPLTEXT 1 0 25 "  r
esult := result + n^2\n" }{MPLTEXT 1 0 4 "od:\n" }{MPLTEXT 1 0 8 "resu
lt;\n" }}}{PARA 0 "" 0 "" {TEXT 371 133 "The main difference between t
he two is that the for-loop needed an extra variable and it produced a
 lot of intermediate results. The " }{TEXT 0 3 "add" }{TEXT 371 85 " c
ommand is also faster. Try adding up the first one million squares usi
ng first the " }{TEXT 0 3 "add" }{TEXT 371 31 " command and then the f
or-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0
 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 112 "Recall that earlie
r we said that for-loops can be used to implement the sigma notation u
sed in mathematics. The " }{TEXT 0 3 "add" }{TEXT 371 61 " command is \+
a direct analogue in Maple to sigma notation. An " }{TEXT 0 3 "add" }
{TEXT 371 20 " command of the form" }}{PARA 220 "" 0 "" {TEXT 0 19 "ad
d( f(n), n=a..b )" }}{PARA 0 "" 0 "" {TEXT 371 31 "means exactly the s
ame thing as" }}{PARA 216 "" 0 "" {XPPEDIT 18 0 "Typesetting:-mrow(Typ
esetting:-mi(\"\", italic = \"true\", executable = \"true\", font_styl
e_name = \"2D Input\", mathvariant = \"italic\"), Typesetting:-mrow(Ty
pesetting:-munderover(Typesetting:-mo(\"&Sum;\", foreground = \"[144,1
44,144]\", mathvariant = \"normal\", Typesetting:-msemantics = \"inert
\", fence = \"false\", separator = \"false\", stretchy = \"true\", sym
metric = \"false\", largeop = \"true\", movablelimits = \"true\", acce
nt = \"false\", lspace = \"0.0em\", rspace = \"0.1666667em\"), Typeset
ting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"i
talic\"), Typesetting:-mo(\"=\", mathvariant = \"normal\", fence = \"f
alse\", separator = \"false\", stretchy = \"false\", symmetric = \"fal
se\", largeop = \"false\", movablelimits = \"false\", accent = \"false
\", lspace = \"0.2777778em\", rspace = \"0.2777778em\"), Typesetting:-
mi(\"a\", italic = \"true\", mathvariant = \"italic\")), Typesetting:-
mi(\"b\", italic = \"true\", mathvariant = \"italic\"), accent = \"fal
se\", accentunder = \"false\"), Typesetting:-mi(\"\", italic = \"true
\", executable = \"true\", font_style_name = \"2D Input\", mathvariant
 = \"italic\"), Typesetting:-mspace(height = \"0.0ex\", width = \"5.0
\", depth = \"0.0ex\", linebreak = \"auto\"), Typesetting:-mrow(Typese
tting:-mi(\"f\", italic = \"true\", mathvariant = \"italic\"), Typeset
ting:-mo(\"&ApplyFunction;\", mathvariant = \"normal\", fence = \"fals
e\", separator = \"false\", stretchy = \"false\", symmetric = \"false
\", largeop = \"false\", movablelimits = \"false\", accent = \"false\"
, lspace = \"0.0em\", rspace = \"0.0em\"), Typesetting:-mfenced(Typese
tting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", mathvariant = \"
italic\")), mathvariant = \"normal\")), Typesetting:-mi(\"\", italic =
 \"true\", executable = \"true\", font_style_name = \"2D Input\", math
variant = \"italic\")), Typesetting:-mi(\"\", italic = \"true\", execu
table = \"true\", font_style_name = \"2D Input\", mathvariant = \"ital
ic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6%-I#mi
GF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_style_nameGQ)2D~Inp
utF'/%,mathvariantGQ'italicF'-F#6'-I+munderoverGF$6'-I#moGF$6/Q&&Sum;F
'/%+foregroundGQ.[144,144,144]F'/F8Q'normalF'/I+msemanticsGF$Q&inertF'
/%&fenceGQ&falseF'/%*separatorGFM/%)stretchyGF1/%*symmetricGFM/%(large
opGF1/%.movablelimitsGF1/%'accentGFM/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.1
666667emF'-F#6%-F,6%Q\"nF'F/F7-F@6-Q\"=F'FFFKFN/FQFMFR/FUFM/FWFMFX/Fen
Q,0.2777778emF'/FhnFfo-F,6%Q\"aF'F/F7-F,6%Q\"bF'F/F7FX/%,accentunderGF
MF+-I'mspaceGF$6&/%'heightGQ&0.0exF'/%&widthGQ$5.0F'/%&depthGFep/%*lin
ebreakGQ%autoF'-F#6%-F,6%Q\"fF'F/F7-F@6-Q0&ApplyFunction;F'FFFKFNFboFR
FcoFdoFXFZ/FhnFfn-I(mfencedGF$6$-F#6#F\\oFFF+F+" }}{PARA 0 "" 0 "" 
{TEXT 371 32 "and their for-loop equivalent is" }}{PARA 0 "" 0 "" 
{TEXT 371 60 "                                                        \+
    " }{TEXT 0 12 "result := 0:" }}{PARA 0 "" 0 "" {TEXT 371 60 "     \+
                                                       " }{TEXT 0 20 "
for n from a to b do" }}{PARA 0 "" 0 "" {TEXT 371 65 "                \+
                                                 " }{TEXT 0 23 "result
 := result + f(n)" }}{PARA 0 "" 0 "" {TEXT 371 60 "                   \+
                                         " }{TEXT 0 3 "od:" }}{PARA 0 
"" 0 "" {TEXT 371 60 "                                                \+
            " }{TEXT 0 7 "result;" }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}
{PARA 0 "" 0 "" {TEXT 371 202 "By the way, look at the interesting out
put from these nested \"loop\" commands. They sum up the first 10 squa
res, then the first 100 squares, then the first 1000 squares, etc. Can
 you explain the pattern?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 
"for k from 1 to 6 do\n" }{MPLTEXT 1 0 24 "  add( n^2, n=1..10^k )\n" 
}{MPLTEXT 1 0 4 "od;\n" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 ""
 0 "" {TEXT 371 4 "The " }{TEXT 0 3 "mul" }{TEXT 371 26 " command is m
uch like the " }{TEXT 0 3 "add" }{TEXT 371 131 " command, it just uses
 multiplication instead of addition. So the following command will fin
d the product of the first ten squares." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "mul( n^2, n=1..10 );" }}}{PARA 0 "" 0 "" {TEXT 371 
32 "Here is the equivalent for-loop." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "result := 1:\n" }{MPLTEXT 1 0 22 "for n from 1 to 10 \+
do\n" }{MPLTEXT 1 0 25 "  result := result * n^2\n" }{MPLTEXT 1 0 4 "o
d:\n" }{MPLTEXT 1 0 8 "result;\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 4 "The " }{TEXT 0 3 "mul" }
{TEXT 371 75 " command is a direct analogue in Maple to mathematical p
roduct notation. A " }{TEXT 0 3 "mul" }{TEXT 371 20 " command of the f
orm" }}{PARA 221 "" 0 "" {TEXT 0 19 "mul( f(n), n=a..b )" }}{PARA 0 ""
 0 "" {TEXT 371 75 "means exactly the same thing as the standard mathe
matical product notation " }}{PARA 214 "" 0 "" {XPPEDIT 18 0 "Typesett
ing:-mrow(Typesetting:-mi(\"\", italic = \"true\", executable = \"true
\", font_style_name = \"2D Input\", mathvariant = \"italic\"), Typeset
ting:-mrow(Typesetting:-munderover(Typesetting:-mo(\"&Product;\", fore
ground = \"[144,144,144]\", mathvariant = \"normal\", Typesetting:-mse
mantics = \"inert\", fence = \"false\", separator = \"false\", stretch
y = \"true\", symmetric = \"false\", largeop = \"true\", movablelimits
 = \"true\", accent = \"false\", lspace = \"0.0em\", rspace = \"0.1666
667em\"), Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"true\", \+
mathvariant = \"italic\"), Typesetting:-mo(\"=\", mathvariant = \"norm
al\", fence = \"false\", separator = \"false\", stretchy = \"false\", \+
symmetric = \"false\", largeop = \"false\", movablelimits = \"false\",
 accent = \"false\", lspace = \"0.2777778em\", rspace = \"0.2777778em
\"), Typesetting:-mi(\"a\", italic = \"true\", mathvariant = \"italic
\")), Typesetting:-mi(\"b\", italic = \"true\", mathvariant = \"italic
\"), accent = \"false\", accentunder = \"false\"), Typesetting:-mi(\"
\", italic = \"true\", executable = \"true\", font_style_name = \"2D I
nput\", mathvariant = \"italic\"), Typesetting:-mspace(height = \"0.0e
x\", width = \"5.0\", depth = \"0.0ex\", linebreak = \"auto\"), Typese
tting:-mrow(Typesetting:-mi(\"f\", italic = \"true\", mathvariant = \"
italic\"), Typesetting:-mo(\"&ApplyFunction;\", mathvariant = \"normal
\", fence = \"false\", separator = \"false\", stretchy = \"false\", sy
mmetric = \"false\", largeop = \"false\", movablelimits = \"false\", a
ccent = \"false\", lspace = \"0.0em\", rspace = \"0.0em\"), Typesettin
g:-mfenced(Typesetting:-mrow(Typesetting:-mi(\"n\", italic = \"true\",
 mathvariant = \"italic\")), mathvariant = \"normal\")), Typesetting:-
mi(\"\", italic = \"true\", executable = \"true\", font_style_name = \+
\"2D Input\", mathvariant = \"italic\")), Typesetting:-mi(\"\", italic
 = \"true\", executable = \"true\", font_style_name = \"2D Input\", ma
thvariant = \"italic\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI
(_syslibGF'6%-I#miGF$6'Q!F'/%'italicGQ%trueF'/%+executableGF1/%0font_s
tyle_nameGQ)2D~InputF'/%,mathvariantGQ'italicF'-F#6'-I+munderoverGF$6'
-I#moGF$6/Q*&Product;F'/%+foregroundGQ.[144,144,144]F'/F8Q'normalF'/I+
msemanticsGF$Q&inertF'/%&fenceGQ&falseF'/%*separatorGFM/%)stretchyGF1/
%*symmetricGFM/%(largeopGF1/%.movablelimitsGF1/%'accentGFM/%'lspaceGQ&
0.0emF'/%'rspaceGQ,0.1666667emF'-F#6%-F,6%Q\"nF'F/F7-F@6-Q\"=F'FFFKFN/
FQFMFR/FUFM/FWFMFX/FenQ,0.2777778emF'/FhnFfo-F,6%Q\"aF'F/F7-F,6%Q\"bF'
F/F7FX/%,accentunderGFMF+-I'mspaceGF$6&/%'heightGQ&0.0exF'/%&widthGQ$5
.0F'/%&depthGFep/%*linebreakGQ%autoF'-F#6%-F,6%Q\"fF'F/F7-F@6-Q0&Apply
Function;F'FFFKFNFboFRFcoFdoFXFZ/FhnFfn-I(mfencedGF$6$-F#6#F\\oFFF+F+"
 }}{PARA 0 "" 0 "" {TEXT 371 32 "and their for-loop equivalent is" }}
{PARA 0 "" 0 "" {TEXT 371 60 "                                        \+
                    " }{TEXT 0 12 "result := 1:" }}{PARA 0 "" 0 "" 
{TEXT 371 60 "                                                        \+
    " }{TEXT 0 20 "for n from a to b do" }}{PARA 0 "" 0 "" {TEXT 371 
65 "                                                                 "
 }{TEXT 0 23 "result := result * f(n)" }}{PARA 0 "" 0 "" {TEXT 371 60 
"                                                            " }{TEXT 
0 3 "od:" }}{PARA 0 "" 0 "" {TEXT 371 60 "                            \+
                                " }{TEXT 0 7 "result;" }}{PARA 0 "" 0 
"" {TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 53 "There are two Maple \+
commands that are related to the " }{TEXT 0 3 "add" }{TEXT 371 5 " and
 " }{TEXT 0 3 "mul" }{TEXT 371 68 " command but they are not abbreviat
ions for for-loops. They are the " }{TEXT 0 3 "sum" }{TEXT 371 5 " and
 " }{TEXT 0 7 "product" }{TEXT 371 33 " commands. These two commands d
o " }{TEXT 361 18 "symbolic summation" }{TEXT 362 1 " " }{TEXT 371 3 "
and" }{TEXT 363 1 " " }{TEXT 364 23 "symbolic multiplication" }{TEXT 
371 70 ". For example, consider the next command, which will sum up th
e first " }{TEXT 0 1 "j" }{TEXT 371 9 " squares." }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 23 "sum( 'n^2', 'n'=1..j );" }}}{PARA 0 "" 0 "" 
{TEXT 371 64 "This command gave us a symbolic answer for the sum of th
e first " }{TEXT 0 1 "j" }{TEXT 371 13 " squares for " }{TEXT 365 3 "a
ny" }{TEXT 371 10 " value of " }{TEXT 0 1 "j" }{TEXT 371 22 ". The res
ult from the " }{TEXT 0 3 "sum" }{TEXT 371 39 " command can be simplif
ied quite a bit." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "simplify
( % );\n" }{MPLTEXT 1 0 13 "factor( % );\n" }}}{PARA 0 "" 0 "" {TEXT 
371 4 "The " }{TEXT 0 3 "sum" }{TEXT 371 69 " command can even sum up \+
infinite series. Here is a geometric series." }}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 30 "sum( 'r^n', 'n'=1..infinity );" }}}{PARA 0 "" 0 ""
 {TEXT 371 59 "The product command does much the same thing for produc
ts. " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "j:='j':\n" }{MPLTEXT 
1 0 28 "product( 'n^2', 'n'=1..j );\n" }}}{PARA 0 "" 0 "" {TEXT 371 
25 "The product of the first " }{TEXT 0 1 "j" }{TEXT 371 63 " squares \+
is given symbolically in terms of a special function, " }{XPPEDIT 18 0
 "Typesetting:-mrow(Typesetting:-mi(\"Gamma\", italic = \"false\", mat
hvariant = \"normal\"));" "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(
_syslibGF'6#-I#miGF$6%Q&GammaF'/%'italicGQ&falseF'/%,mathvariantGQ'nor
malF'" }{TEXT 371 58 ", called the gamma function. Let us test this re
sult with " }{TEXT 0 1 "j" }{TEXT 371 13 " equal to 99." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "mul( n^2, n=1..99 );" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "GAMMA(99+1)^2;" }}}{PARA 0 "" 0 "" 
{TEXT 371 4 "The " }{TEXT 0 7 "product" }{TEXT 371 91 " command can al
so do infinite products. The following command uses the \"inert\" form
 of the " }{TEXT 0 7 "product" }{TEXT 371 16 " command ( i.e. " }{TEXT
 0 7 "Product" }{TEXT 371 145 ") to display a typeset version of the p
roduct notation on the left hand side of an equal sign, and on the rig
ht of the equal sign is the regular " }{TEXT 0 7 "product" }{TEXT 371 
42 " command to evaluate the infinite product." }}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 42 "Product( 1-1/(4*'n'^2), 'n'=1..infinity )\n" }
{MPLTEXT 1 0 52 "       = product( 1-1/(4*'n'^2), 'n'=1..infinity );\n
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 371 0 "" }}{PARA 0 "" 0 "" {TEXT 371 38 "Here is one tricky diff
erence between " }{TEXT 0 3 "add" }{TEXT 371 2 ", " }{TEXT 0 3 "mul" }
{TEXT 371 21 " on the one hand and " }{TEXT 0 3 "sum" }{TEXT 371 2 ", 
" }{TEXT 0 7 "product" }{TEXT 371 45 " on the other hand. Let us give \+
the variable " }{TEXT 0 1 "i" }{TEXT 371 42 " a value (it does not mat
ter what value). " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "i := 0;"
 }}}{PARA 0 "" 0 "" {TEXT 371 8 "Now use " }{TEXT 0 1 "i" }{TEXT 371 
29 " as the index variable in an " }{TEXT 0 3 "add" }{TEXT 371 7 " and
 a " }{TEXT 0 3 "mul" }{TEXT 371 9 " command." }}{EXCHG {PARA 0 "> " 0
 "" {MPLTEXT 1 0 16 "add(i, i=1..10);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "mul(i, i=1..10);" }}}{PARA 0 "" 0 "" {TEXT 371 26 "Le
t us check the value of " }{TEXT 0 1 "i" }{TEXT 371 5 " now." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "i;" }}}{PARA 0 "" 0 "" {TEXT 
371 31 "It is still zero. The value of " }{TEXT 0 1 "i" }{TEXT 371 50 
" did not affect, and was not affect by, the index " }{TEXT 0 1 "i" }
{TEXT 371 8 " in the " }{TEXT 0 3 "add" }{TEXT 371 4 " or " }{TEXT 0 
3 "mul" }{TEXT 371 36 " commands. The index variable in an " }{TEXT 0 
3 "add" }{TEXT 371 6 " or a " }{TEXT 0 3 "mul" }{TEXT 371 166 " comman
d is local to that command and does not have anything to do with the g
lobal variable with the same name (just like local variables in proced
ures). Now try the " }{TEXT 0 3 "sum" }{TEXT 371 5 " and " }{TEXT 0 7 
"product" }{TEXT 371 10 " commands." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "sum( i, i=1..10 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "product( i, i=1..10 );" }}}{PARA 0 "" 0 "" {TEXT 371 
26 "The index variable in the " }{TEXT 0 3 "sum" }{TEXT 371 5 " and " 
}{TEXT 0 7 "product" }{TEXT 371 73 " commands are global variables. He
re is how to fix the last two commands." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "sum( 'i', 'i'=1..10 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "product( 'i', 'i'=1..10 );" }}}{PARA 0 "" 0 "" {TEXT 
371 23 "Now check the value of " }{TEXT 0 1 "i" }{TEXT 371 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "i;" }}}{PARA 0 "" 0 "" {TEXT 
371 56 "Strangely enough, even though the index variable in the " }
{TEXT 0 3 "add" }{TEXT 371 5 " and " }{TEXT 0 7 "product" }{TEXT 371 
33 " commands is the global variable " }{TEXT 0 1 "i" }{TEXT 371 2 ", 
" }{TEXT 0 1 "i" }{TEXT 371 64 " still retains its value from before t
he commands were executed." }}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0
 "" 0 "" {TEXT 371 65 "The moral of this is that you need to be more c
areful when using " }{TEXT 0 3 "sum" }{TEXT 371 5 " and " }{TEXT 0 7 "
product" }{TEXT 371 19 " than when you use " }{TEXT 0 3 "add" }{TEXT 
371 4 " or " }{TEXT 0 3 "mul" }{TEXT 371 13 ". Always use " }{TEXT 0 
3 "add" }{TEXT 371 5 " and " }{TEXT 0 3 "mul" }{TEXT 371 43 " if you d
o not need the extra abilities of " }{TEXT 0 3 "sum" }{TEXT 371 5 " an
d " }{TEXT 0 7 "product" }{TEXT 371 1 "." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{PARA 0 "" 0 "" 
{TEXT 366 8 "Exercise" }{TEXT 371 55 ": Compare the way Maple handle t
he \"index variable\" in " }{TEXT 0 3 "add" }{TEXT 371 2 ", " }{TEXT 
0 3 "mul" }{TEXT 371 2 ", " }{TEXT 0 3 "sum" }{TEXT 371 6 ", and " }
{TEXT 0 7 "product" }{TEXT 371 61 " with the way Maple handles the ind
ex variable in a for-loop." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{PARA 0 "" 0 "" {TEXT 371 0 "" }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}}}
{MARK "0 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 1 1 1 1 }{PAGENUMBERS 0 1 2
 33 1 1 }