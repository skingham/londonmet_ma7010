{VERSION 6 0 "Windows 10" "6.0" }
{USTYLETAB {PSTYLE "Heading 1" -1 3 1 {CSTYLE "" -1 -1 "Times" 1 18 0
 0 0 1 2 1 2 2 2 2 1 0 0 1 }1 1 0 0 6 6 2 0 2 0 2 2 -1 1 }{PSTYLE "War
ning" -1 7 1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0
 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple Outp
ut" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 
}1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Fixed Width" -1 17 1 {CSTYLE "
" -1 -1 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 
0 2 2 -1 1 }{PSTYLE "Help" -1 10 1 {CSTYLE "" -1 -1 "Courier" 1 9 0 0 
255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Head
ing 4" -1 20 1 {CSTYLE "" -1 -1 "Times" 1 10 0 0 0 1 1 1 2 2 2 2 1 0 0
 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Line Printed Output" -1 6 1
 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 
0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "No Name211" -1 200 1 {CSTYLE "" -1 -1
 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 
1 }{PSTYLE "Heading 2" -1 4 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 
1 2 2 2 2 1 0 0 1 }1 1 0 0 8 2 2 0 2 0 2 2 -1 1 }{PSTYLE "Maple Output
" -1 11 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3
 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 3" -1 5 1 {CSTYLE "" -1 
-1 "Times" 1 12 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 
-1 1 }{PSTYLE "Diagnostic" -1 9 1 {CSTYLE "" -1 -1 "Courier" 1 10 64 
128 64 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "O
rdered List 1" -1 201 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 
2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Text Output" -1 2 
1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0
 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Ordered List 2" -1 202 1 {CSTYLE "" 
-1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 36 2 0 2
 2 -1 1 }{PSTYLE "Ordered List 3" -1 203 1 {CSTYLE "" -1 -1 "Times" 1 
12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 72 2 0 2 2 -1 1 }{PSTYLE
 "Ordered List 4" -1 204 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2
 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 108 2 0 2 2 -1 1 }{PSTYLE "Ordered List \+
5" -1 205 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 
}1 1 0 0 3 3 2 144 2 0 2 2 -1 1 }{PSTYLE "Annotation Title" -1 206 1 
{CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 1 0 0 1 }3 1 0 0 12 
12 2 0 2 0 2 2 -1 1 }{PSTYLE "HyperlinkError" -1 207 1 {CSTYLE "" -1 
-1 "Courier New" 1 12 255 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0
 2 0 2 2 -1 1 }{PSTYLE "HyperlinkWarning" -1 208 1 {CSTYLE "" -1 -1 "C
ourier New" 1 12 0 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 
2 -1 1 }{PSTYLE "Bullet Item" -1 15 1 {CSTYLE "" -1 -1 "Times" 1 12 0 
0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Mapl
e Plot" -1 13 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 
0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "List Item" -1 14 1 {CSTYLE
 "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 
0 2 2 -1 1 }{PSTYLE "Dash Item" -1 16 1 {CSTYLE "" -1 -1 "Times" 1 12 
0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Er
ror" -1 8 1 {CSTYLE "" -1 -1 "Courier" 1 10 255 0 255 1 2 2 2 2 2 1 1 
0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Title" -1 18 1 {CSTYLE "
" -1 -1 "Times" 1 18 0 0 0 1 2 1 1 2 2 2 1 0 0 1 }3 1 0 0 12 12 2 0 2 
0 2 2 -1 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 
0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Author
" -1 19 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3
 1 0 0 8 8 2 0 2 0 2 2 -1 1 }{PSTYLE "No Name" -1 209 1 {CSTYLE "" -1 
-1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 
-1 1 }{CSTYLE "Help Variable" -1 25 "Courier" 1 12 0 0 0 1 2 2 2 2 2 2
 0 0 0 1 }{CSTYLE "Help Underlined Bold" -1 41 "Times" 1 12 0 0 0 1 1 
1 2 2 2 2 0 0 0 1 }{CSTYLE "Copyright" -1 34 "Times" 1 10 0 0 0 1 2 2 
2 2 2 2 0 0 0 1 }{CSTYLE "Maple Comment" -1 21 "Courier" 1 12 0 0 0 1 
2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Popup" -1 31 "Times" 1 12 0 128 128 1 1 
2 1 2 2 2 0 0 0 1 }{CSTYLE "Atomic Variable" -1 200 "Times" 1 12 175 0
 175 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Dictionary Hyperlink" -1 45 "Time
s" 1 12 147 0 15 1 2 2 1 2 2 2 0 0 0 1 }{CSTYLE "Plot Text" -1 28 "Tim
es" 1 8 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Input" -1 19 "Times" 
1 12 255 0 0 1 2 2 2 2 1 2 0 0 0 1 }{CSTYLE "Code" -1 201 "Courier New
" 1 12 255 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic" -1 3 "T
imes" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Small" -1 7 "
Times" 1 1 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Bold Small" 
-1 10 "Times" 1 1 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Bold" -1 
39 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Menus" -1 
36 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Heading" -1
 26 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D Output" -1 
20 "Times" 1 12 0 0 255 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Inert Outpu
t" -1 202 "Times" 1 12 144 144 144 1 2 2 2 2 1 2 0 0 0 1 }{CSTYLE "Hel
p Normal" -1 30 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Map
le Input" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "
Page Number" -1 33 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "
Header and Footer" -1 203 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "Help Fixed" -1 23 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 
}{CSTYLE "Output Labels" -1 29 "Times" 1 8 0 0 0 1 2 2 2 2 2 2 0 0 0 1
 }{CSTYLE "Help Notes" -1 37 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 
}{CSTYLE "Help Underlined" -1 44 "Times" 1 12 0 0 0 1 2 2 1 2 2 2 0 0 
0 1 }{CSTYLE "2D Math Italic Small" -1 204 "Times" 1 1 0 0 0 1 1 2 2 2
 2 2 0 0 0 1 }{CSTYLE "2D Math Symbol 2" -1 16 "Times" 1 12 0 0 0 1 2 
2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 1 12 0 0 0 1 2 2 2 2
 2 2 0 0 0 1 }{CSTYLE "Help Nonterminal" -1 24 "Courier" 1 12 0 0 0 1 
2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Annotation Text" -1 205 "Times" 1 12 0 0
 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Maple Name" -1 35 "Times" 1 12
 104 64 92 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Text" -1 206 "Times" 1 12 0
 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Plot Title" -1 27 "Times" 1 10 0 
0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underlined Italic" -1 43 "Tim
es" 1 12 0 0 0 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "Caption Reference" -1 
207 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Default" -1 38 
"Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Italic Bold" 
-1 40 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Maple Input P
laceholder" -1 208 "Courier New" 1 12 200 0 200 1 2 1 2 2 1 2 0 0 0 1 
}{CSTYLE "LaTeX" -1 32 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "Help Emphasized" -1 22 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0
 1 }{CSTYLE "Equation Label" -1 209 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0
 0 0 1 }{CSTYLE "2D Comment" -1 18 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 
0 0 1 }{CSTYLE "Help Italic" -1 42 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 
0 0 1 }{CSTYLE "Prompt" -1 1 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "2D Math Bold" -1 5 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "Hyperlink" -1 17 "Times" 1 12 0 128 128 1 2 2 1 2 2 2 0 0 
0 1 }{CSTYLE "Caption Text" -1 210 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 
0 0 1 }{CSTYLE "" -1 211 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "" -1 212 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE ""
 -1 213 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 214 "T
imes" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 215 "Times" 1 12
 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 216 "Times" 1 12 0 0 0 1 2
 1 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 217 "Times" 1 12 0 0 0 1 2 1 2 2 2 2
 0 0 0 1 }{CSTYLE "" -1 218 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "" -1 219 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE ""
 -1 220 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 221 "T
imes" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 222 "Times" 1 12
 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 223 "Times" 1 12 0 0 0 1 1
 2 2 2 2 2 0 0 0 1 }{CSTYLE "" -1 224 "Times" 1 12 0 0 0 1 1 2 2 2 2 2
 0 0 0 1 }{CSTYLE "" -1 225 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }
{CSTYLE "" -1 226 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE ""
 -1 227 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }}
{SECT 0 {SECT 0 {PARA 3 "" 0 "" {TEXT 228 54 "Week 17. More Examples \+
of Procedures. Some definitions" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 76 "Here is a simple example of a procedure \+
definition. This procedure is named " }{TEXT 0 4 "plus" }{TEXT 229 
335 ", it has two formal parameters, and it has three commands in its \+
procedure body. Notice that the results of the first two commands are \+
not used in any way. When this procedure is called, Maple will execute
 all three commands, but the results of the first two commands are jus
t \"thrown away\". (So this is really a pretty silly example.)" }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "plus := proc(x,y)\n" }
{MPLTEXT 1 0 15 "        x - y;\n" }{MPLTEXT 1 0 15 "        x * y;\n"
 }{MPLTEXT 1 0 44 "        x + y;  # This is the return value.\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 229 18 "Here is a cal
l to " }{TEXT 0 4 "plus" }{TEXT 229 24 " with actual parameters " }
{TEXT 0 1 "3" }{TEXT 229 5 " and " }{TEXT 0 1 "4" }{TEXT 229 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "plus( 3, 4 );" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "plus := proc(x,y)\n" }
{MPLTEXT 1 0 15 "        x - y;\n" }{MPLTEXT 1 0 15 "        x * y;\n"
 }{MPLTEXT 1 0 17 "        x + y;  \n" }{MPLTEXT 1 0 40 "   print(`x-y
`=x-y,`xy`=x*y,`x+y`=x+y);\n" }{MPLTEXT 1 0 5 "end:\n" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "plus( 3, 4 );" }}}}{SECT 0 {PARA 3 
"" 0 "" {TEXT 228 39 " Parameter, local, and global variables" }}
{PARA 0 "" 0 "" {TEXT 229 51 "In a procedure there are three kinds of \+
variables, " }{TEXT 211 19 "parameter variables" }{TEXT 229 2 ", " }
{TEXT 212 15 "local variables" }{TEXT 229 6 ", and " }{TEXT 213 16 "gl
obal variables" }{TEXT 229 95 ". Consider the following example, a sli
ght variation on the last example from the last section." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "plus := proc(x,y)\n" }{MPLTEXT 1 0 
26 "     local a, b;         \n" }{MPLTEXT 1 0 15 "     global c;\n" }
{MPLTEXT 1 0 17 "     a := x - y;\n" }{MPLTEXT 1 0 17 "     b := x * y
;\n" }{MPLTEXT 1 0 17 "     c := x ^ y;\n" }{MPLTEXT 1 0 37 "         \+
 x + y;  # the return value\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 
0 "" {TEXT 229 44 "This procedure has two parameter variables (" }
{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 24 "), tw
o local variables (" }{TEXT 0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b
" }{TEXT 229 28 "), and one global variable (" }{TEXT 0 1 "c" }{TEXT 
229 806 "). The parameter variables ( i.e.,  formal parameters) are pl
ace holders for the actual inputs passed to the procedure during a pro
cedure call. The local variables can be thought of as \"scratch pad va
riables\", or \"temporary variables\".  Local variables are used to ho
ld temporary results that might come up while we are trying to compute
 our main result in the procedure. As we will see, the local variables
 only \"live\" inside the procedure call. They do not exist outside th
e procedure, and they do not survive from one procedure call to the ne
xt (this is why they get their name \"local\"). The global variable is
 just that, it is global to the whole Maple worksheet. As we will see,
 global variables inside procedure bodies are really the same as the v
ariables we use in commands at our worksheet prompts." }}{PARA 0 "" 0 
"" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 49 "Let us see how all t
his works with the procedure " }{TEXT 0 4 "plus" }{TEXT 229 53 " (make
 sure that you have executed the definition of " }{TEXT 0 4 "plus" }
{TEXT 229 32 "). Here is a procedure call for " }{TEXT 0 4 "plus" }
{TEXT 229 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "plus( 2, 5
 );" }}}{PARA 0 "" 0 "" {TEXT 229 29 "Now what about the variables " }
{TEXT 0 1 "a" }{TEXT 229 2 ", " }{TEXT 0 1 "b" }{TEXT 229 6 ", and " }
{TEXT 0 1 "c" }{TEXT 229 1 "?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 8 "a; b; c;" }}}{PARA 0 "" 0 "" {TEXT 229 12 "Notice that " }{TEXT 
0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b" }{TEXT 229 26 " are still \+
unassigned but " }{TEXT 0 1 "c" }{TEXT 229 36 " has the value  = 32. T
he variables " }{TEXT 0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b" }
{TEXT 229 55 " in our worksheet are unassigned because the variables "
 }{TEXT 0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b" }{TEXT 229 22 " in
side the procedure " }{TEXT 0 4 "plus" }{TEXT 229 26 " are local varia
bles. The " }{TEXT 0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b" }{TEXT 
229 8 " inside " }{TEXT 0 4 "plus" }{TEXT 229 32 " have no affect on t
he \"global\" " }{TEXT 0 1 "a" }{TEXT 229 5 " and " }{TEXT 0 1 "b" }
{TEXT 229 70 ", the ones in our worksheet. On the other hand, the \"gl
obal\" variable " }{TEXT 0 1 "c" }{TEXT 229 46 " in our worksheet is t
he same variable as the " }{TEXT 0 1 "c" }{TEXT 229 8 " inside " }
{TEXT 0 4 "plus" }{TEXT 229 133 " since it is declared to be a global \+
variable there. Notice that a global variable can be used as a sneaky \+
way for a procedure to \"ou" }}{PARA 0 "" 0 "" {TEXT 229 94 "tput\" an
other result besides its official return value. Here is another call t
o the procedure " }{TEXT 0 4 "plus" }{TEXT 229 1 "." }}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 14 "plus( -2, 2 );" }}}{PARA 0 "" 0 "" {TEXT 
229 25 "Now look at the value of " }{TEXT 0 1 "c" }{TEXT 229 1 "." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "c;" }}}{PARA 0 "" 0 "" {TEXT 
229 13 "The value of " }{TEXT 0 1 "c" }{TEXT 229 27 " changes with eac
h call to " }{TEXT 0 4 "plus" }{TEXT 229 1 "." }}{PARA 0 "" 0 "" {TEXT
 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 174 "It is worth mentioning that
 parameter variables are a kind of local variable since they have no a
ffect except during a procedure call. For example, notice that the var
iables " }{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 
229 40 " are still unassigned in the worksheet. " }}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 5 "x; y;" }}}{PARA 0 "" 0 "" {TEXT 229 24 "The par
ameter variables " }{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" 
}{TEXT 229 28 " that were given the values " }{TEXT 0 2 "-2" }{TEXT 
229 5 " and " }{TEXT 0 1 "2" }{TEXT 229 99 " in the last procedure cal
l were local to the procedure call, so they have no affect on the glob
al " }{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 18 
" in our worksheet." }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "
" {TEXT 229 112 "We will see several uses for local and global variabl
es later in this worksheet and in the following worksheets." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 0 {PARA 3 "" 0 
"" {TEXT 228 16 " Another example" }}{PARA 0 "" 0 "" {TEXT 229 250 "He
re is another example of converting an execution group into a procedur
e. Suppose we have a large integer and we want to know what one of its
 digits is. For example, suppose we want to know what is the 15th digi
t (from the right) of the integer 47!." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "47!;" }}}{PARA 0 "" 0 "" {TEXT 229 152 "You could just
 start counting from the last digit on the right, but that is tedious,
 error prone, and will not work for finding the 257th digit in 200!." 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "200!;" }}}{PARA 0 "" 0 "" 
{TEXT 229 153 "The length command can be used to find out just how man
y digits there are in an integer. The next command shows that 200! has
 a lot more than 257 digits." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "length( % );" }}}{PARA 0 "" 0 "" {TEXT 229 167 "Let us find a sequ
ence of Maple commands that will find the 'th digit (from the right) o
f an integer . Take for example  to be 98765 and  to be 3 (so the answ
er is 7)." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "n := 98765;" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "i := 3;" }}}{PARA 0 "" 0 "" 
{TEXT 229 148 "The integer  has its decimal point to the right of its \+
first digit. The following command moves the decimal point to the left
 of the i'th digit of ." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "e
valf( 10^(-i)*n );" }}}{PARA 0 "" 0 "" {TEXT 229 29 "The next command \+
returns the " }{TEXT 0 4 "frac" }{TEXT 229 142 "tional part of the las
t result (the part to the right of the decimal point), leaving the dig
it we want just on the right of the decimal point." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 10 "frac( % );" }}}{PARA 0 "" 0 "" {TEXT 229 
144 "The next command moves the decimal point over to the right one pl
ace, leaving the digit we want by itself just to the left of the decim
al point." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "10*%;" }}}{PARA 
0 "" 0 "" {TEXT 229 26 "Finally, the next command " }{TEXT 0 5 "trunc"
 }{TEXT 229 87 "ates off the fractional part of the last result leavin
g us with just the digit we want." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 11 "trunc( % );" }}}{PARA 0 "" 0 "" {TEXT 229 101 "Now let us put
 these commands together in an execution group. (Notice that we really
 do not need the " }{TEXT 0 5 "evalf" }{TEXT 229 23 " in the third com
mand.)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "n := 98765:\n" }
{MPLTEXT 1 0 8 "i := 3:\n" }{MPLTEXT 1 0 11 "10^(-i)*n:\n" }{MPLTEXT 
1 0 11 "frac( % ):\n" }{MPLTEXT 1 0 6 "10*%:\n" }{MPLTEXT 1 0 12 "trun
c( % );\n" }}}{PARA 0 "" 0 "" {TEXT 229 184 "This execution group perf
orms a useful calculation, but it is not easy enough to use and reuse.
 So now let us put our commands into the body of a procedure. We will \+
call the procedure " }{TEXT 0 9 "get_digit" }{TEXT 229 55 " and this p
rocedure will take in two numbers as inputs." }}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 23 "get_digit := proc(n,i)\n" }{MPLTEXT 1 0 15 "    10
^(-i)*n;\n" }{MPLTEXT 1 0 15 "    frac( % );\n" }{MPLTEXT 1 0 10 "    \+
10*%;\n" }{MPLTEXT 1 0 16 "    trunc( % );\n" }{MPLTEXT 1 0 5 "end;\n"
 }}}{PARA 0 "" 0 "" {TEXT 229 40 "Let us try it out with a procedure c
all." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "get_digit( 98765, 3 \+
);" }}}{PARA 0 "" 0 "" {TEXT 229 48 "Now we can easily find the 257'th
 digit of 200!." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "get_digit
( 200!, 257 );" }}}{PARA 0 "" 0 "" {TEXT 229 207 "Of course, there is \+
no easy way to verify this result. The best that you can do is to test
 this procedure on a lot of verifiable inputs until you have convinced
 yourself that the procedure is always correct." }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 ""
 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}}{SECT 0 
{PARA 3 "" 0 "" {TEXT 228 31 " Maple functions are procedures" }}
{PARA 0 "" 0 "" {TEXT 229 169 "A function in Maple is really like a pr
ocedure. Below we define a procedure,  a Maple function, and an expres
sion, each of them equivalent to the mathematical function ." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "f1 := x^2+2*x-1;    # The ma
thematical function as an expression," }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "f2 := x->x^2+2*x-1; # as a Maple function," }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "f3 := proc(x)       # as a p
rocedure.\n" }{MPLTEXT 1 0 13 "   x^2+2*x-1\n" }{MPLTEXT 1 0 6 "end; \+
\n" }}}{PARA 0 "" 0 "" {TEXT 229 51 "Let us see how Maple remembers th
e definitions of  " }{TEXT 0 2 "f1" }{TEXT 229 3 ",  " }{TEXT 0 2 "f2"
 }{TEXT 229 7 ", and  " }{TEXT 0 2 "f3" }{TEXT 229 4 ".   " }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "eval( f1 );     # f1 was defined as
 an expression." }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "eval( f2
 );     # f2 was defined as a function." }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "eval( f3 );     # f3 was defined as a procedure." }}}
{PARA 0 "" 0 "" {TEXT 229 36 "Now we will check the data types of " }
{TEXT 0 2 "f1" }{TEXT 229 2 ", " }{TEXT 0 2 "f2" }{TEXT 229 6 ", and "
 }{TEXT 0 2 "f3" }{TEXT 229 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 58 "whattype( eval(f1) );   # f1 was defined as an expression." }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "whattype( eval(f2) );   # f
2 was defined as a function." }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 56 "whattype( eval(f3) );   # f3 was defined as a procedure." }}}
{PARA 0 "" 0 "" {TEXT 229 33 "Notice that Maple considers both " }
{TEXT 0 2 "f2" }{TEXT 229 5 " and " }{TEXT 0 2 "f3" }{TEXT 229 15 " to
 be of type " }{TEXT 0 9 "procedure" }{TEXT 229 42 ", so Maple treats \+
functions as procedures." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "
#?whattype" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{SECT 0 {PARA 4 "" 0 "
examples" {TEXT 230 8 "Examples" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 16 "whattype(x + y);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "whattype(-x);" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "whattype(x^y);" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "whattype([x,y,z]);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "whattype(2+4*I);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "whattype(a);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 5 "a:=1:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "whattype(a);"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "b:=\"hello\":" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "whattype(b);" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}}{SECT 0 {PARA 3 "" 0 "" {TEXT
 228 48 " How a mathematical function is like a procedure" }}{PARA 0 "
" 0 "" {TEXT 229 260 "Here is a simple procedure that implements the m
athematical function . The procedure has two formal parameters and onl
y one command in the body of the procedure. Whatever that command comp
utes is the return value of the procedure when the procedure is called
. " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "plus := proc(x,y)\n" }
{MPLTEXT 1 0 8 "   x+y;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 ""
 {TEXT 229 40 "Here are a few calls to this procedure. " }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "plus( 3, 4 ); " }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 14 "plus( -3, 4 );" }}}{PARA 0 "" 0 "" {TEXT 
229 131 "We can \"compose\" procedure calls just as we can compose fun
ctions. The following composition will compute the sum of three number
s." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "plus( 5, plus(3,4) ); \+
 # Add three numbers." }}}{PARA 0 "" 0 "" {TEXT 229 70 "The actual par
ameters in a procedure call may be unassigned variables." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "plus( variable1, variable2 );" }}}
{PARA 0 "" 0 "" {TEXT 229 43 "In the next example, how are the variabl
es " }{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 56 
" in the procedure call related to the formal parameters " }{TEXT 0 1 
"x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 36 " in the definit
ion of the procedure?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "plu
s( x+y, x-y );" }}}{PARA 0 "" 0 "" {TEXT 229 19 "The procedure call " 
}{TEXT 0 14 "plus(x+y, x-y)" }{TEXT 229 52 " can be a bit confusing. H
ere, the formal parameter " }{TEXT 0 1 "x" }{TEXT 229 57 " (in the pro
cedure definition) gets the actual parameter " }{TEXT 0 3 "x+y" }{TEXT
 229 53 " (from the procedure call), and the formal parameter " }{TEXT
 0 1 "y" }{TEXT 229 27 " gets the actual parameter " }{TEXT 0 3 "x-y" 
}{TEXT 229 118 ". You should think of the formal parameters as \"place
 holders\" for the actual parameters. And remember, the variables " }
{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 71 " in t
he procedure call are global variables while the formal parameter " }
{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 68 " in t
he body of the procedure are local variables. So the variables " }
{TEXT 0 1 "x" }{TEXT 229 5 " and " }{TEXT 0 1 "y" }{TEXT 229 40 " in t
he procedure call are not the same " }{TEXT 0 1 "x" }{TEXT 229 5 " and
 " }{TEXT 0 1 "y" }{TEXT 229 32 " that are in the procedure body." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 289 "This is just like in algebra
 and calculus. If , then what is ? It is . The equation  is a \"proced
ure definition\",  f is the name of the \"procedure\", and the  in thi
s equation is a \"formal parameter\".  Then  is a \"procedure call\", \+
and  is the \"actual parameter\" for the \"formal parameter\" ." }}
{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 234 "Notice
 that mathematically,  ,  , and   are all definitions of the same func
tion f. Each one just uses a different formal parameter in the definit
ion of the function. Similarly, if we rename the formal parameters in \+
the definition of " }{TEXT 0 4 "plus" }{TEXT 229 12 ", that does " }
{TEXT 214 3 "not" }{TEXT 229 147 " change the procedure. It will still
 be the same procedure, because it will do exactly the same thing. In \+
other words, the following definition of " }{TEXT 0 4 "plus" }{TEXT 
229 55 " is not really any different from the first definition." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "plus := proc(u,v)\n" }
{MPLTEXT 1 0 15 "        u + v;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0
 "" 0 "" {TEXT 229 49 "Here is a way to use Maple to confirm this clai
m." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "evalb( proc(u,v) u+v e
nd = proc(x,y) x+y end );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 215 8 "Ex
ercise" }{TEXT 229 92 ": Make a small change in the last command so th
at the two procedures are no longer the same." }}{EXCHG {PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}}{SECT 0 
{PARA 3 "" 0 "" {TEXT 228 21 " Anonymous procedures" }}{PARA 0 "" 0 ""
 {TEXT 229 198 "When we define a procedure we almost always give it a \+
name. But we do not have to. We can have unnamed procedures just as we
 can have unnamed functions or expressions. Unnamed procedures are cal
led " }{TEXT 216 20 "anonymous procedures" }{TEXT 229 151 ". Here is a
n anonymous procedure that takes a string and a positive integer as in
put and returns the string truncated to the integer number of letters.
" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "proc(x::string, n::posin
t)\n" }{MPLTEXT 1 0 11 "  local i;\n" }{MPLTEXT 1 0 23 "  seq( x[i], i
=1..n );\n" }{MPLTEXT 1 0 12 "  cat( % );\n" }{MPLTEXT 1 0 5 "end;\n" 
}}}{PARA 0 "" 0 "" {TEXT 229 75 "Right now the procedure is anonymous.
 But we can still call this procedure." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "%( \"this is a long name\", 11 );" }}}{PARA 0 "" 0 ""
 {TEXT 229 68 "We can give the procedure a name, so that it is no long
er anonymous." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "shorten := \+
%%;" }}}{PARA 0 "" 0 "" {TEXT 229 46 "Now we can call the procedure by
 its new name." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "shorten( \+
\"Aren't we having fun?\", 15 );" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 167 "Here is an anonymous procedure that rev
erses the letters in a string. The following command defines the anony
mous procedure and then calls it, all in a single command." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "x := (proc(x) local i; cat(seq(x[-i
], i=1..length(x))) end)( \"try it out\" );" }}}{PARA 0 "" 0 "" {TEXT 
229 100 "Notice that the assignment operator was acting on the result \+
of the call to the anonymous procedure." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 2 "x;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 300 "The la
st few commands were meant to emphasize that defining and naming a pro
cedure are two distinct steps and procedures do not have to have names
 to be used. Anonymous procedures can be used anywhere anonymous funct
ions can be used. But anonymous functions are more common than anonymo
us procedures." }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}}}{SECT 0 {PARA 3 "" 0 "" {TEXT 228 31 " Pro
cedures and data structures" }}{PARA 0 "" 0 "" {TEXT 229 111 "The next
 few examples are meant to show how knowledge of data structures can b
e useful for writing procedures. " }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 139 "Here are a few simple procedure definit
ions. These three procedures compute the average of two, three, and fo
ur input numbers respectively." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 19 "avg2 := proc(x,y) \n" }{MPLTEXT 1 0 54 "    (x+y)/2;    # Comput
e the average of two numbers.\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "
" 0 "" {TEXT 229 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "avg3
 := proc(x,y,z) \n" }{MPLTEXT 1 0 56 "    (x+y+z)/3;  # Compute the av
erage of three numbers.\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 ""
 {TEXT 229 0 "" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "avg4 := pr
oc(a,b,c,d) \n" }{MPLTEXT 1 0 56 "   (a+b+c+d)/4;  # Compute the avera
ge of four numbers.\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" 
{TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 40 "Here are a few calls to
 our procedures. " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "avg2( 1
0, 3 );\n" }{MPLTEXT 1 0 12 "evalf( % );\n" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 19 "avg3( -1, 34, 12 );" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "avg4( 50, 32, 100, 1 ); \n" }{MPLTEXT 1 0 12 "evalf( \+
% );\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "avg4( 3, 3, 3, 3 \+
); " }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 473 "What if we want to com
pute the average of 27 numbers? Do we have to write a procedure that h
as 27 formal parameters? The next procedure solves the problem of how \+
we can average any number of  numbers without having to write an infin
ite number of procedures. This procedure has only one input parameter,
 but that input is a data structure (in this case a list) that can hol
d any number of numbers. This is an example of using a data structure \+
to solve a programming problem." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 15 "avg := proc(L)\n" }{MPLTEXT 1 0 48 "   local i, N, S;         \+
   # Local variables.\n" }{MPLTEXT 1 0 66 "   N := nops( L );         \+
  # How many numbers we are averaging.\n" }{MPLTEXT 1 0 63 "   S := ad
d( L[i], i=1..N ); # Add up the numbers in the list.\n" }{MPLTEXT 1 0 
57 "   S/N;                      # This is the return value.\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 229 14 "The procedure
 " }{TEXT 0 3 "avg" }{TEXT 229 45 " determines how many numbers are in
 the list " }{TEXT 0 1 "L" }{TEXT 229 24 " and puts the result in " }
{TEXT 0 1 "N" }{TEXT 229 33 " (a local variable). It uses the " }{TEXT
 0 3 "add" }{TEXT 229 84 " command to add up the numbers in the list a
nd stores the sum in the local variable " }{TEXT 0 1 "S" }{TEXT 229 
18 ". Then it divides " }{TEXT 0 1 "S" }{TEXT 229 4 " by " }{TEXT 0 1 
"N" }{TEXT 229 457 " to get the average. (Notice the use of comments i
nside the procedure to help explain what is being done.) This example \+
uses three local variables. Notice how the local variables are used to
 hold temporary results that come up while we are trying to compute ou
r main result. Remember that the local variables only \"live\" inside \+
a procedure call. They do not exist after the procedure has returned a
nd they do not survive from one procedure call to the next." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" 
}}{PARA 0 "" 0 "" {TEXT 229 23 "Here are some calls to " }{TEXT 0 3 "a
vg" }{TEXT 229 2 ". " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "avg(
 [2,3,4,5,6,7] ); " }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "evalf
( % );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "L := [12, 32.3, P
i, 67, 100, exp(2), 5.5, 44, 66, 100] ;" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "avg( L );" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
11 "evalf( % );" }}}{PARA 0 "" 0 "" {TEXT 229 30 "Remember, the global
 variable " }{TEXT 0 1 "L" }{TEXT 229 80 " in this last procedure call
 is not the same variable as the parameter variable " }{TEXT 0 1 "L" }
{TEXT 229 22 " in the definition of " }{TEXT 0 3 "avg" }{TEXT 229 1 ".
" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 28 "When we wrote the procedure " }{TEXT 0 
3 "avg" }{TEXT 229 33 ", we were thinking that the list " }{TEXT 0 1 "
L" }{TEXT 229 346 " represented a list of numbers. It turns out that t
he procedure works on lists of some other data types but it also does \+
not work with lists of certain data types. There is a sophisticated wa
y for us to force our procedure to work only in the way that we origin
ally thought of it, as an average of a list of numbers. We will use wh
at is called a " }{TEXT 217 16 "type declaration" }{TEXT 229 38 " in t
he list of formal parameters for " }{TEXT 0 3 "avg" }{TEXT 229 239 " t
o tell Maple exactly what kind of data types the actual parameters are
 supposed to be. When the procedure is called, Maple will check the da
ta type of the actual parameters and see if they are of the correct ty
pe (this is referred to as " }{TEXT 218 13 "type checking" }{TEXT 229 
141 "). If the actual parameters are not of the data type declared for
 the formal parameters, then Maple will return an appropriate error me
ssage." }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 
45 "Here we tell Maple that the formal parameter " }{TEXT 0 1 "L" }
{TEXT 229 34 " represents a \"list of numbers\".  " }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 70 "avg := proc(L::list(numeric)) # Tell Maple e
xactly what L represents.\n" }{MPLTEXT 1 0 18 "   local i, N, S;\n" }
{MPLTEXT 1 0 19 "   N := nops( L );\n" }{MPLTEXT 1 0 29 "   S := add( \+
L[i], i=1..N );\n" }{MPLTEXT 1 0 8 "   S/N;\n" }{MPLTEXT 1 0 5 "end;\n
" }}}{PARA 0 "" 0 "" {TEXT 229 38 "Now let us try this new definition \+
of " }{TEXT 0 3 "avg" }{TEXT 229 18 " on the bad input." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "L := [1,2,3,4];" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 9 "avg( L );" }}}{PARA 0 "" 0 "" {TEXT 229 107 
"The error message we got here is a bit more informative than it was b
efore. It tells us what kind of input " }{TEXT 0 3 "avg" }{TEXT 229 
64 " was expecting as opposed to the kind of input we passed to it. " 
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 
229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 31 "Now consider this next exampl
e." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "avg(2,3,4,5,6,7);  # W
hat's wrong with this input?" }}}{PARA 0 "" 0 "" {TEXT 229 28 "Notice \+
that only the number " }{TEXT 0 1 "2" }{TEXT 229 29 " was passed to th
e procedure " }{TEXT 0 3 "avg" }{TEXT 229 127 " (read the error messag
e carefully). All the other elements of the expression sequence in the
 function call were ignored since " }{TEXT 0 3 "avg" }{TEXT 229 26 " w
as defined to take only " }{TEXT 219 3 "one" }{TEXT 229 18 " input. An
d since " }{TEXT 0 1 "2" }{TEXT 229 637 " is not a list, we got the er
ror message. This last command demonstrates two things. First of all, \+
Maple has the unusual property of allowing procedure calls with more p
arameters than the procedure was written to accept. We will see in the
 next section why Maple chooses to behave this way. Compare this with \+
mathematical functions; if the function f is defined by , then the \"f
unction call\"  is considered an error. But in Maple, the  would be ig
nored and only the   would be passed to the function (i.e., procedure)
.  Maple will complain however if a procedure is passed too few parame
ters as the following procedure call demonstrates." }}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 36 "avg3(0,1);   # avg3 expects 3 inputs" }}}
{PARA 0 "" 0 "" {TEXT 229 46 "The other thing that we learn from the c
ommand" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "avg(2,3,4,5,6,7);"
 }}}{PARA 0 "" 0 "" {TEXT 229 156 " is that our solution to the proble
m of averaging an arbitrary number of numbers is not really optimal. T
he last command should have been written like this:" }}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 21 "avg( [2,3,4,5,6,7] );" }}}{PARA 0 "" 0 "" 
{TEXT 229 96 "But those brackets in the function call are awkward. Com
pare the following sequence of commands." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "avg2(2,3);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "avg3(2,3,4);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "avg4(2,
3,4,5);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "avg( [2,3,4,5,6]
 );" }}}{PARA 0 "" 0 "" {TEXT 229 268 "Why should the last command hav
e to be typed in differently from the previous three? Looking at it fr
om this point of view, the brackets solved one problem but they create
d another problem. How are users of our procedure supposed to remember
 that the correct usage of " }{TEXT 0 3 "avg" }{TEXT 229 21 " is the n
on intuitive" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "avg( [2,3,4,
5,6] );" }}}{PARA 0 "" 0 "" {TEXT 229 43 "instead of the more obvious,
 but incorrect," }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "avg(2,3,4
,5,6);" }}}{PARA 0 "" 0 "" {TEXT 229 106 "In the next section we will \+
see how Maple provides a way to solve this dilemma caused by the way w
e wrote " }{TEXT 0 3 "avg" }{TEXT 229 1 "." }}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 ""
 {TEXT 229 0 "" }}}{SECT 0 {PARA 3 "" 0 "" {TEXT 228 40 " The args exp
ression sequence (optional)" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" 
{TEXT 229 496 "In a previous section we solved the problem of how to w
rite a procedure that would compute the average of any number of input
 numbers. We solved the problem using a data structure (a list). But o
ur solution was not all that appealing. Recall that our solution requi
red that the procedure call have brackets in it so that the procedure \+
would be passed only one argument, the list. The brackets made the pro
cedure awkward to use. In this section we will see how to remove the n
eed for the brackets." }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0
 "" {TEXT 229 22 "Here is the procedure " }{TEXT 0 3 "avg" }{TEXT 229 
54 " as we defined previously (without the type checking)." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "avg := proc(L)\n" }{MPLTEXT 1 0 17 
"  local i, N, S;\n" }{MPLTEXT 1 0 18 "  N := nops( L );\n" }{MPLTEXT 
1 0 28 "  S := add( L[i], i=1..N );\n" }{MPLTEXT 1 0 7 "  S/N;\n" }
{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 229 47 "Here is an ex
ample of a call to this procedure." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "avg( [2,3,4,5,6,7,8] );" }}}{PARA 0 "" 0 "" {TEXT 
229 51 "What we would like to be able to do is to call the " }{TEXT 0 
3 "avg" }{TEXT 229 21 " procedure like this." }}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 19 "avg(2,3,4,5,6,7,8);" }}}{PARA 0 "" 0 "" {TEXT 229 
264 "Notice that in the proper procedure call the input is a list and \+
in the improper procedure call the input is an expression sequence. Bo
th lists and expression sequences are data structures capable of holdi
ng any number of numbers. Can we rewrite the definition of " }{TEXT 0 
3 "avg" }{TEXT 229 333 " to have an expression sequence as the formal \+
parameter instead of a list? The answer is no. We cannot have a formal
 parameter represent an expression sequence data structure like we had
 a formal parameter represent a list data structure. The reason has to
 do with the way Maple passes parameters. Every procedure call is of t
he form" }}{PARA 209 "" 0 "" {TEXT 0 15 "procedure_name(" }{TEXT 206 
1 " " }{TEXT 220 40 "expression-sequence-of-actual-parameters" }{TEXT 
206 1 " " }{TEXT 0 1 ")" }}{PARA 0 "" 0 "" {TEXT 229 8 "and the " }
{TEXT 0 4 "proc" }{TEXT 229 50 " command that defines the procedure is
 of the form" }}{PARA 200 "" 0 "" {TEXT 0 23 "procedure_name := proc("
 }{TEXT 206 1 " " }{TEXT 221 40 "expression-sequence-of-formal-paramet
ers" }{TEXT 206 1 " " }{TEXT 0 1 ")" }{TEXT 206 1 " " }{TEXT 222 15 "M
aple-statement" }{TEXT 206 2 "s " }{TEXT 0 3 "end" }{TEXT 206 1 "." }}
{PARA 0 "" 0 "" {TEXT 229 36 "Maple will take the elements of the " }
{TEXT 223 40 "expression-sequence-of-actual-parameters" }{TEXT 229 90 
" in the procedure call and match those elements up, one for one, with
 the elements of the " }{TEXT 224 40 "expression-sequence-of-formal-pa
rameters" }{TEXT 229 220 " in the procedure definition. There is no wa
y to have Maple take some of the elements from the expression sequence
 of actual parameters and pass them into a single formal parameter tha
t represents an expression sequence." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" 
{TEXT 229 245 "However, writing procedures that take an arbitrary numb
er of parameters is a common thing to do in Maple, so Maple provides a
 special solution to the problem we are up against. Maple provides eve
ry procedure with a special local variable called " }{TEXT 0 4 "args" 
}{TEXT 229 23 " that holds the entire " }{TEXT 225 40 "expression-sequ
ence-of-actual-parameters" }{TEXT 229 79 " from a procedure call, and \+
Maple also provides another special local variable " }{TEXT 0 5 "nargs
" }{TEXT 229 47 " that holds the number of actual parameters in " }
{TEXT 0 4 "args" }{TEXT 229 6 " (so  " }{TEXT 0 5 "nargs" }{TEXT 229 
16 " is the same as " }{TEXT 0 12 "nops([args])" }{TEXT 229 3 " )." }}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT 229 57 "Here are two more procedures that make simple use of the
 " }{TEXT 0 4 "args" }{TEXT 229 5 " and " }{TEXT 0 5 "nargs" }{TEXT 
229 131 " variables. The first simply returns its actual parameter lis
t and the second counts how many actual parameters it was called with.
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "quote_them := proc()\n"
 }{MPLTEXT 1 0 8 "  args;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{EXCHG {PARA 
0 "> " 0 "" {MPLTEXT 1 0 21 "count_them := proc()\n" }{MPLTEXT 1 0 9 "
  nargs;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 229 36 "
Here are some examples of their use." }}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "quote_them( a, b, c, d, e, f, g, h, i, j );\n" }
{MPLTEXT 1 0 44 "count_them( a, b, c, d, e, f, g, h, i, j );\n" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "quote_them( a, [b, c], \{d, \+
e\}, f=g, h..i, j );\n" }{MPLTEXT 1 0 47 "count_them( a, [b, c], \{d, \+
e\}, f=g, h..i, j );\n" }}}{PARA 0 "" 0 "" {TEXT 229 26 "Why was the l
ast result 6?" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" 
{TEXT 229 23 "Here is how we can use " }{TEXT 0 4 "args" }{TEXT 229 5 
" and " }{TEXT 0 5 "nargs" }{TEXT 229 26 " to rewrite the procedure " 
}{TEXT 0 3 "avg" }{TEXT 229 1 "." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 14 "avg := proc()\n" }{MPLTEXT 1 0 14 "  local i, S;\n" }{MPLTEXT 
1 0 35 "  S := add( args[i], i=1..nargs );\n" }{MPLTEXT 1 0 11 "  S/na
rgs;\n" }{MPLTEXT 1 0 5 "end;\n" }}}{PARA 0 "" 0 "" {TEXT 229 54 "Noti
ce how strange this seems at first. The procedure " }{TEXT 0 3 "avg" }
{TEXT 229 108 " is now defined to take no parameters! But it does take
 parameters and it gets those parameters through the " }{TEXT 0 4 "arg
s" }{TEXT 229 363 " expression sequence. (Notice how we are still usin
g a data structure to solve the problem of how to pass an arbitrary nu
mber of numbers to our procedure. Instead of using a list data structu
re, now we are using an expression sequence data structure. And instea
d of the data structure being help in a formal parameter, now it is he
ld in a special local variable.)" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 52 "Here are some procedure calls to our new
 version of " }{TEXT 0 3 "avg" }{TEXT 229 1 "." }}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 11 "avg(2,3,4);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "avg(2,3,4,5,6,7);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" 
{TEXT 226 8 "Exercise" }{TEXT 229 35 ": Notice what happens when we ca
ll " }{TEXT 0 3 "avg" }{TEXT 229 20 " with no parameters." }}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "avg();" }}}{PARA 0 "" 0 "" {TEXT 
229 25 "Modify the definition of " }{TEXT 0 3 "avg" }{TEXT 229 79 " so
 that it returns a better error message when it is called with no argu
ments." }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{PARA 0 "" 0 "" {TEXT 229 0 "" }}
{PARA 0 "" 0 "" {TEXT 229 15 "The procedures " }{TEXT 0 4 "avg2" }
{TEXT 229 2 ", " }{TEXT 0 4 "avg3" }{TEXT 229 6 ", and " }{TEXT 0 4 "a
vg4" }{TEXT 229 234 " that we defined previously each represent a math
ematical function, i.e., a real valued function of two, three, and fou
r variables respectively (you can easily write a mathematical formula \+
for each of these functions). The version of " }{TEXT 0 3 "avg" }{TEXT
 229 27 " that we just defined does " }{TEXT 227 3 "not" }{TEXT 229 
87 " represent a simple mathematical function. There is no easy way to
 define a domain for " }{TEXT 0 3 "avg" }{TEXT 229 125 " using common \+
mathematical language and, similarly, there is no easy way to use math
ematical notation to write a formula for " }{TEXT 0 3 "avg" }{TEXT 
229 117 ". This example shows how the computer science notion of a pro
cedure can extend the mathematical notion of a function." }}{PARA 0 ""
 0 "" {TEXT 229 0 "" }}{PARA 0 "" 0 "" {TEXT 229 0 "" }}}}
{MARK "0 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 1 1 1 1 }{PAGENUMBERS 0 1 2
 33 1 1 }